"use strict";
var _a, _b, _c;
const React48 = require("react");
const wagmi = require("wagmi");
const reactDom = require("react-dom");
const ethers = require("ethers");
const _interopDefaultLegacy = (e2) => e2 && typeof e2 === "object" && "default" in e2 ? e2 : { default: e2 };
function _interopNamespace(e2) {
  if (e2 && e2.__esModule)
    return e2;
  const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k2 in e2) {
      if (k2 !== "default") {
        const d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: () => e2[k2]
        });
      }
    }
  }
  n2.default = e2;
  return Object.freeze(n2);
}
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
const React48__namespace = /* @__PURE__ */ _interopNamespace(React48);
const React48__default = /* @__PURE__ */ _interopDefaultLegacy(React48);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function() {
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", {
    value: true
  });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var buffer$1 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$3 = 0, len = code.length; i$3 < len; ++i$3) {
  lookup[i$3] = code[i$3];
  revLookup[code.charCodeAt(i$3)] = i$3;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr2[curByte++] = tmp >> 16 & 255;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i];
  i += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s2 * 128;
};
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr2) {
  return toString$1.call(arr2) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
(function(exports2) {
  var base642 = base64Js;
  var ieee754$1 = ieee754;
  var isArray2 = isarray;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  Buffer2.TYPED_ARRAY_SUPPORT = commonjsGlobal.TYPED_ARRAY_SUPPORT !== void 0 ? commonjsGlobal.TYPED_ARRAY_SUPPORT : typedArraySupport();
  exports2.kMaxLength = kMaxLength();
  function typedArraySupport() {
    try {
      var arr2 = new Uint8Array(1);
      arr2.__proto__ = {
        __proto__: Uint8Array.prototype,
        foo: function() {
          return 42;
        }
      };
      return arr2.foo() === 42 && typeof arr2.subarray === "function" && arr2.subarray(1, 1).byteLength === 0;
    } catch (e2) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error("If encoding is specified then the first argument must be a string");
      }
      return allocUnsafe(this, arg);
    }
    return from2(this, arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  Buffer2._augment = function(arr2) {
    arr2.__proto__ = Buffer2.prototype;
    return arr2;
  };
  function from2(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from2(null, value, encodingOrOffset, length);
  };
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    Buffer2.prototype.__proto__ = Uint8Array.prototype;
    Buffer2.__proto__ = Uint8Array;
    if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      Object.defineProperty(Buffer2, Symbol.species, {
        value: null,
        configurable: true
      });
    }
  }
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size2 < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(that, size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size2).fill(fill, encoding) : createBuffer(that, size2).fill(fill);
    }
    return createBuffer(that, size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(null, size2, fill, encoding);
  };
  function allocUnsafe(that, size2) {
    assertSize(size2);
    that = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size2; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(null, size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(null, size2);
  };
  function fromString(that, string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength2(string2, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string2, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array2) {
    var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array2[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array2, byteOffset, length) {
    array2.byteLength;
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array2 = new Uint8Array(array2);
    } else if (length === void 0) {
      array2 = new Uint8Array(array2, byteOffset);
    } else {
      array2 = new Uint8Array(array2, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array2;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike(that, array2);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray2(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer3(b2) {
    return !!(b2 != null && b2._isBuffer);
  };
  Buffer2.compare = function compare2(a2, b2) {
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError("Arguments must be Buffers");
    }
    if (a2 === b2)
      return 0;
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a2[i] !== b2[i]) {
        x2 = a2[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!isArray2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer2, pos);
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      string2 = "" + string2;
    }
    var len = string2.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string2).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    var i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    var length = this.length | 0;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect5() {
    var str = "";
    var max2 = exports2.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
      if (this.length > max2)
        str += " ... ";
    }
    return "<Buffer " + str + ">";
  };
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end - start;
    var len = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr2.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr2, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read(arr2, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string2.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string2.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length);
  }
  function latin1Write(buf, string2, offset, length) {
    return asciiWrite(buf, string2, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write5(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length);
        case "ascii":
          return asciiWrite(this, string2, offset, length);
        case "latin1":
        case "binary":
          return latin1Write(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex2(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes3 = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes3.length; i += 2) {
      res += String.fromCharCode(bytes3[i] + bytes3[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer2.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer2(sliceLen, void 0);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul5 = 1;
    var i = 0;
    while (++i < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul5 = 1;
    while (byteLength3 > 0 && (mul5 *= 256)) {
      val += this[offset + --byteLength3] * mul5;
    }
    return val;
  };
  Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul5 = 1;
    var i = 0;
    while (++i < byteLength3 && (mul5 *= 256)) {
      val += this[offset + i] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul5 = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul5 *= 256)) {
      val += this[offset + --i] * mul5;
    }
    mul5 *= 128;
    if (val >= mul5)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul5 = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul5 *= 256)) {
      this[offset + i] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul5 = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul5 *= 256)) {
      this[offset + i] = value / mul5 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i = 0, j2 = Math.min(buf.length - offset, 2); i < j2; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i = 0, j2 = Math.min(buf.length - offset, 4); i < j2; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul5 = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul5 = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul5 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul5 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer2.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (code2 < 256) {
          val = code2;
        }
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes3 = Buffer2.isBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
      var len = bytes3.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes3[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex2(n2) {
    if (n2 < 16)
      return "0" + n2.toString(16);
    return n2.toString(16);
  }
  function utf8ToBytes(string2, units2) {
    units2 = units2 || Infinity;
    var codePoint;
    var length = string2.length;
    var leadSurrogate = null;
    var bytes3 = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string2.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units2 -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units2 -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units2 -= 3) > -1)
            bytes3.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units2 -= 3) > -1)
          bytes3.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units2 -= 1) < 0)
          break;
        bytes3.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units2 -= 2) < 0)
          break;
        bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units2 -= 3) < 0)
          break;
        bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units2 -= 4) < 0)
          break;
        bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes3;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units2) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units2 -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src6, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src6.length)
        break;
      dst[i + offset] = src6[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
})(buffer$1);
window.global = (_a = window.global) != null ? _a : window;
window.Buffer = (_b = window.Buffer) != null ? _b : buffer$1.Buffer;
window.process = (_c = window.process) != null ? _c : {
  env: {}
};
const index$2 = "";
var walletConnectWallet_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjI4IiBoZWlnaHQ9IjI4IiBmaWxsPSIjM0I5OUZDIi8+CjxwYXRoIGQ9Ik04LjM4OTY5IDEwLjM3MzlDMTEuNDg4MiA3LjI3NTM4IDE2LjUxMTggNy4yNzUzOCAxOS42MTAzIDEwLjM3MzlMMTkuOTgzMiAxMC43NDY4QzIwLjEzODIgMTAuOTAxNyAyMC4xMzgyIDExLjE1MjkgMTkuOTgzMiAxMS4zMDc4TDE4LjcwNzYgMTIuNTgzNUMxOC42MzAxIDEyLjY2MDkgMTguNTA0NSAxMi42NjA5IDE4LjQyNzEgMTIuNTgzNUwxNy45MTM5IDEyLjA3MDNDMTUuNzUyMyA5LjkwODcgMTIuMjQ3NyA5LjkwODcgMTAuMDg2MSAxMi4wNzAzTDkuNTM2NTUgMTIuNjE5OEM5LjQ1OTA5IDEyLjY5NzMgOS4zMzM1IDEyLjY5NzMgOS4yNTYwNCAxMi42MTk4TDcuOTgwMzkgMTEuMzQ0MkM3LjgyNTQ3IDExLjE4OTMgNy44MjU0NyAxMC45MzgxIDcuOTgwMzkgMTAuNzgzMkw4LjM4OTY5IDEwLjM3MzlaTTIyLjI0ODUgMTMuMDEyTDIzLjM4MzggMTQuMTQ3NEMyMy41Mzg3IDE0LjMwMjMgMjMuNTM4NyAxNC41NTM1IDIzLjM4MzggMTQuNzA4NEwxOC4yNjQ1IDE5LjgyNzdDMTguMTA5NiAxOS45ODI3IDE3Ljg1ODQgMTkuOTgyNyAxNy43MDM1IDE5LjgyNzdDMTcuNzAzNSAxOS44Mjc3IDE3LjcwMzUgMTkuODI3NyAxNy43MDM1IDE5LjgyNzdMMTQuMDcwMiAxNi4xOTQ0QzE0LjAzMTQgMTYuMTU1NyAxMy45Njg2IDE2LjE1NTcgMTMuOTI5OSAxNi4xOTQ0QzEzLjkyOTkgMTYuMTk0NCAxMy45Mjk5IDE2LjE5NDQgMTMuOTI5OSAxNi4xOTQ0TDEwLjI5NjYgMTkuODI3N0MxMC4xNDE3IDE5Ljk4MjcgOS44OTA1MyAxOS45ODI3IDkuNzM1NjEgMTkuODI3OEM5LjczNTYgMTkuODI3OCA5LjczNTYgMTkuODI3NyA5LjczNTYgMTkuODI3N0w0LjYxNjE5IDE0LjcwODNDNC40NjEyNyAxNC41NTM0IDQuNDYxMjcgMTQuMzAyMiA0LjYxNjE5IDE0LjE0NzNMNS43NTE1MiAxMy4wMTJDNS45MDY0NSAxMi44NTcgNi4xNTc2MyAxMi44NTcgNi4zMTI1NSAxMy4wMTJMOS45NDU5NSAxNi42NDU0QzkuOTg0NjggMTYuNjg0MSAxMC4wNDc1IDE2LjY4NDEgMTAuMDg2MiAxNi42NDU0QzEwLjA4NjIgMTYuNjQ1NCAxMC4wODYyIDE2LjY0NTQgMTAuMDg2MiAxNi42NDU0TDEzLjcxOTQgMTMuMDEyQzEzLjg3NDMgMTIuODU3IDE0LjEyNTUgMTIuODU3IDE0LjI4MDUgMTMuMDEyQzE0LjI4MDUgMTMuMDEyIDE0LjI4MDUgMTMuMDEyIDE0LjI4MDUgMTMuMDEyTDE3LjkxMzkgMTYuNjQ1NEMxNy45NTI2IDE2LjY4NDEgMTguMDE1NCAxNi42ODQxIDE4LjA1NDEgMTYuNjQ1NEwyMS42ODc0IDEzLjAxMkMyMS44NDI0IDEyLjg1NzEgMjIuMDkzNiAxMi44NTcxIDIyLjI0ODUgMTMuMDEyWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==";
const $$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: walletConnectWallet_default
}, Symbol.toStringTag, { value: "Module" }));
var rainbowWallet_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfNjJfMzI5KSIvPgo8cGF0aCBkPSJNMjAgMzhIMjZDNTYuOTI3OSAzOCA4MiA2My4wNzIxIDgyIDk0VjEwMEg5NEM5Ny4zMTM3IDEwMCAxMDAgOTcuMzEzNyAxMDAgOTRDMTAwIDUzLjEzMDkgNjYuODY5MSAyMCAyNiAyMEMyMi42ODYzIDIwIDIwIDIyLjY4NjMgMjAgMjZWMzhaIiBmaWxsPSJ1cmwoI3BhaW50MV9yYWRpYWxfNjJfMzI5KSIvPgo8cGF0aCBkPSJNODQgOTRIMTAwQzEwMCA5Ny4zMTM3IDk3LjMxMzcgMTAwIDk0IDEwMEg4NFY5NFoiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik0yNiAyMEwyNiAzNkgyMEwyMCAyNkMyMCAyMi42ODYzIDIyLjY4NjMgMjAgMjYgMjBaIiBmaWxsPSJ1cmwoI3BhaW50M19saW5lYXJfNjJfMzI5KSIvPgo8cGF0aCBkPSJNMjAgMzZIMjZDNTguMDMyNSAzNiA4NCA2MS45Njc1IDg0IDk0VjEwMEg2NlY5NEM2NiA3MS45MDg2IDQ4LjA5MTQgNTQgMjYgNTRIMjBWMzZaIiBmaWxsPSJ1cmwoI3BhaW50NF9yYWRpYWxfNjJfMzI5KSIvPgo8cGF0aCBkPSJNNjggOTRIODRWMTAwSDY4Vjk0WiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzYyXzMyOSkiLz4KPHBhdGggZD0iTTIwIDUyTDIwIDM2TDI2IDM2TDI2IDUySDIwWiIgZmlsbD0idXJsKCNwYWludDZfbGluZWFyXzYyXzMyOSkiLz4KPHBhdGggZD0iTTIwIDYyQzIwIDY1LjMxMzcgMjIuNjg2MyA2OCAyNiA2OEM0MC4zNTk0IDY4IDUyIDc5LjY0MDYgNTIgOTRDNTIgOTcuMzEzNyA1NC42ODYzIDEwMCA1OCAxMDBINjhWOTRDNjggNzAuODA0IDQ5LjE5NiA1MiAyNiA1MkgyMFY2MloiIGZpbGw9InVybCgjcGFpbnQ3X3JhZGlhbF82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik01MiA5NEg2OFYxMDBINThDNTQuNjg2MyAxMDAgNTIgOTcuMzEzNyA1MiA5NFoiIGZpbGw9InVybCgjcGFpbnQ4X3JhZGlhbF82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik0yNiA2OEMyMi42ODYzIDY4IDIwIDY1LjMxMzcgMjAgNjJMMjAgNTJMMjYgNTJMMjYgNjhaIiBmaWxsPSJ1cmwoI3BhaW50OV9yYWRpYWxfNjJfMzI5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzYyXzMyOSIgeDE9IjYwIiB5MT0iMCIgeDI9IjYwIiB5Mj0iMTIwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMxNzQyOTkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDAxRTU5Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQxX3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYgOTQpIHJvdGF0ZSgtOTApIHNjYWxlKDc0KSI+CjxzdG9wIG9mZnNldD0iMC43NzAyNzciIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl82Ml8zMjkiIHgxPSI4MyIgeTE9Ijk3IiB4Mj0iMTAwIiB5Mj0iOTciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzYyXzMyOSIgeDE9IjIzIiB5MT0iMjAiIHgyPSIyMyIgeTI9IjM3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY0MDAwIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ0X3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYgOTQpIHJvdGF0ZSgtOTApIHNjYWxlKDU4KSI+CjxzdG9wIG9mZnNldD0iMC43MjM5MjkiIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ1X2xpbmVhcl82Ml8zMjkiIHgxPSI2OCIgeTE9Ijk3IiB4Mj0iODQiIHkyPSI5NyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZGNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTkwMSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfNjJfMzI5IiB4MT0iMjMiIHkxPSI1MiIgeDI9IjIzIiB5Mj0iMzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGRjcwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk5MDEiLz4KPC9saW5lYXJHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDdfcmFkaWFsXzYyXzMyOSIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyNiA5NCkgcm90YXRlKC05MCkgc2NhbGUoNDIpIj4KPHN0b3Agb2Zmc2V0PSIwLjU5NTEzIiBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50OF9yYWRpYWxfNjJfMzI5IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDUxIDk3KSBzY2FsZSgxNyA0NS4zMzMzKSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEFBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDFEQTQwIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ5X3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjMgNjkpIHJvdGF0ZSgtOTApIHNjYWxlKDE3IDMyMi4zNykiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=";
const $$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: rainbowWallet_default
}, Symbol.toStringTag, { value: "Module" }));
var metaMaskWallet_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjI4IiBoZWlnaHQ9IjI4IiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjQuMDg5MSAzLjExOTlMMTUuMzQ0NiA5LjYxNDU2TDE2Ljk2MTcgNS43ODI4TDI0LjA4OTEgMy4xMTk5WiIgZmlsbD0iI0UyNzYxQiIgc3Ryb2tlPSIjRTI3NjFCIiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0zLjkwMjA3IDMuMTE5OUwxMi41NzYzIDkuNjc2MDhMMTEuMDM4MyA1Ljc4MjhMMy45MDIwNyAzLjExOTlaIiBmaWxsPSIjRTQ3NjFCIiBzdHJva2U9IiNFNDc2MUIiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTIwLjk0MjkgMTguMTc0NUwxOC42MTM5IDIxLjc0MjZMMjMuNTk3IDIzLjExMzZMMjUuMDI5NSAxOC4yNTM2TDIwLjk0MjkgMTguMTc0NVoiIGZpbGw9IiNFNDc2MUIiIHN0cm9rZT0iI0U0NzYxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMi45NzkyOSAxOC4yNTM2TDQuNDAzMDEgMjMuMTEzNkw5LjM4NjA3IDIxLjc0MjZMNy4wNTcxMyAxOC4xNzQ1TDIuOTc5MjkgMTguMjUzNloiIGZpbGw9IiNFNDc2MUIiIHN0cm9rZT0iI0U0NzYxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNOS4xMDQ4MyAxMi4xNDU2TDcuNzE2MjYgMTQuMjQ2MUwxMi42NjQyIDE0LjQ2NThMMTIuNDg4NCA5LjE0ODc3TDkuMTA0ODMgMTIuMTQ1NloiIGZpbGw9IiNFNDc2MUIiIHN0cm9rZT0iI0U0NzYxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTguODg2NCAxMi4xNDU2TDE1LjQ1ODkgOS4wODcyNUwxNS4zNDQ2IDE0LjQ2NThMMjAuMjgzNyAxNC4yNDYxTDE4Ljg4NjQgMTIuMTQ1NloiIGZpbGw9IiNFNDc2MUIiIHN0cm9rZT0iI0U0NzYxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNOS4zODYwNiAyMS43NDI2TDEyLjM1NjYgMjAuMjkyNUw5Ljc5MDMzIDE4LjI4ODhMOS4zODYwNiAyMS43NDI2WiIgZmlsbD0iI0U0NzYxQiIgc3Ryb2tlPSIjRTQ3NjFCIiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xNS42MzQ3IDIwLjI5MjVMMTguNjEzOSAyMS43NDI2TDE4LjIwMDkgMTguMjg4OEwxNS42MzQ3IDIwLjI5MjVaIiBmaWxsPSIjRTQ3NjFCIiBzdHJva2U9IiNFNDc2MUIiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTE4LjYxMzkgMjEuNzQyNkwxNS42MzQ3IDIwLjI5MjVMMTUuODcxOSAyMi4yMzQ4TDE1Ljg0NTYgMjMuMDUyMUwxOC42MTM5IDIxLjc0MjZaIiBmaWxsPSIjRDdDMUIzIiBzdHJva2U9IiNEN0MxQjMiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTkuMzg2MDYgMjEuNzQyNkwxMi4xNTQ0IDIzLjA1MjFMMTIuMTM2OCAyMi4yMzQ4TDEyLjM1NjYgMjAuMjkyNUw5LjM4NjA2IDIxLjc0MjZaIiBmaWxsPSIjRDdDMUIzIiBzdHJva2U9IiNEN0MxQjMiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTEyLjE5ODQgMTcuMDA1Nkw5LjcyMDAyIDE2LjI3NjJMMTEuNDY4OSAxNS40NzY1TDEyLjE5ODQgMTcuMDA1NloiIGZpbGw9IiMyMzM0NDciIHN0cm9rZT0iIzIzMzQ0NyIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTUuNzkyOCAxNy4wMDU2TDE2LjUyMjMgMTUuNDc2NUwxOC4yOCAxNi4yNzYyTDE1Ljc5MjggMTcuMDA1NloiIGZpbGw9IiMyMzM0NDciIHN0cm9rZT0iIzIzMzQ0NyIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNOS4zODYwNiAyMS43NDI2TDkuODA3OTEgMTguMTc0NUw3LjA1NzEyIDE4LjI1MzZMOS4zODYwNiAyMS43NDI2WiIgZmlsbD0iI0NENjExNiIgc3Ryb2tlPSIjQ0Q2MTE2IiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xOC4xOTIxIDE4LjE3NDVMMTguNjEzOSAyMS43NDI2TDIwLjk0MjkgMTguMjUzNkwxOC4xOTIxIDE4LjE3NDVaIiBmaWxsPSIjQ0Q2MTE2IiBzdHJva2U9IiNDRDYxMTYiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTIwLjI4MzcgMTQuMjQ2MUwxNS4zNDQ2IDE0LjQ2NThMMTUuODAxNiAxNy4wMDU3TDE2LjUzMTEgMTUuNDc2NUwxOC4yODg4IDE2LjI3NjJMMjAuMjgzNyAxNC4yNDYxWiIgZmlsbD0iI0NENjExNiIgc3Ryb2tlPSIjQ0Q2MTE2IiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik05LjcyMDAyIDE2LjI3NjJMMTEuNDc3NyAxNS40NzY1TDEyLjE5ODQgMTcuMDA1N0wxMi42NjQyIDE0LjQ2NThMNy43MTYyNiAxNC4yNDYxTDkuNzIwMDIgMTYuMjc2MloiIGZpbGw9IiNDRDYxMTYiIHN0cm9rZT0iI0NENjExNiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNNy43MTYyNiAxNC4yNDYxTDkuNzkwMzMgMTguMjg4OEw5LjcyMDAyIDE2LjI3NjJMNy43MTYyNiAxNC4yNDYxWiIgZmlsbD0iI0U0NzUxRiIgc3Ryb2tlPSIjRTQ3NTFGIiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xOC4yODg4IDE2LjI3NjJMMTguMjAwOSAxOC4yODg4TDIwLjI4MzcgMTQuMjQ2MUwxOC4yODg4IDE2LjI3NjJaIiBmaWxsPSIjRTQ3NTFGIiBzdHJva2U9IiNFNDc1MUYiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTEyLjY2NDIgMTQuNDY1OEwxMi4xOTg0IDE3LjAwNTdMMTIuNzc4NCAyMC4wMDI1TDEyLjkxMDIgMTYuMDU2NUwxMi42NjQyIDE0LjQ2NThaIiBmaWxsPSIjRTQ3NTFGIiBzdHJva2U9IiNFNDc1MUYiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTE1LjM0NDYgMTQuNDY1OEwxNS4xMDczIDE2LjA0NzdMMTUuMjEyOCAyMC4wMDI1TDE1LjgwMTYgMTcuMDA1N0wxNS4zNDQ2IDE0LjQ2NThaIiBmaWxsPSIjRTQ3NTFGIiBzdHJva2U9IiNFNDc1MUYiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTE1LjgwMTYgMTcuMDA1NkwxNS4yMTI4IDIwLjAwMjVMMTUuNjM0NyAyMC4yOTI1TDE4LjIwMDkgMTguMjg4OEwxOC4yODg4IDE2LjI3NjJMMTUuODAxNiAxNy4wMDU2WiIgZmlsbD0iI0Y2ODUxQiIgc3Ryb2tlPSIjRjY4NTFCIiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik05LjcyMDAyIDE2LjI3NjJMOS43OTAzMyAxOC4yODg4TDEyLjM1NjYgMjAuMjkyNUwxMi43Nzg0IDIwLjAwMjVMMTIuMTk4NCAxNy4wMDU2TDkuNzIwMDIgMTYuMjc2MloiIGZpbGw9IiNGNjg1MUIiIHN0cm9rZT0iI0Y2ODUxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTUuODQ1NiAyMy4wNTIxTDE1Ljg3MTkgMjIuMjM0OEwxNS42NTIyIDIyLjA0MTRIMTIuMzM5TDEyLjEzNjggMjIuMjM0OEwxMi4xNTQ0IDIzLjA1MjFMOS4zODYwNiAyMS43NDI2TDEwLjM1MjggMjIuNTMzNkwxMi4zMTI2IDIzLjg5NThIMTUuNjc4NkwxNy42NDcyIDIyLjUzMzZMMTguNjEzOSAyMS43NDI2TDE1Ljg0NTYgMjMuMDUyMVoiIGZpbGw9IiNDMEFEOUUiIHN0cm9rZT0iI0MwQUQ5RSIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTUuNjM0NyAyMC4yOTI1TDE1LjIxMjggMjAuMDAyNUgxMi43Nzg0TDEyLjM1NjYgMjAuMjkyNUwxMi4xMzY4IDIyLjIzNDhMMTIuMzM5IDIyLjA0MTRIMTUuNjUyMkwxNS44NzE5IDIyLjIzNDhMMTUuNjM0NyAyMC4yOTI1WiIgZmlsbD0iIzE2MTYxNiIgc3Ryb2tlPSIjMTYxNjE2IiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0yNC40NTgzIDEwLjAzNjRMMjUuMjA1MyA2LjQ1MDcyTDI0LjA4OTEgMy4xMTk5TDE1LjYzNDcgOS4zOTQ4NUwxOC44ODY0IDEyLjE0NTZMMjMuNDgyNyAxMy40OTAzTDI0LjUwMjIgMTIuMzAzOEwyNC4wNjI4IDExLjk4NzRMMjQuNzY1OCAxMS4zNDU5TDI0LjIyMSAxMC45MjRMMjQuOTI0IDEwLjM4NzlMMjQuNDU4MyAxMC4wMzY0WiIgZmlsbD0iIzc2M0QxNiIgc3Ryb2tlPSIjNzYzRDE2IiBzdHJva2Utd2lkdGg9IjAuMDg3ODg0NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0yLjc5NDcyIDYuNDUwNzJMMy41NDE3NCAxMC4wMzY0TDMuMDY3MTcgMTAuMzg3OUwzLjc3MDI0IDEwLjkyNEwzLjIzNDE1IDExLjM0NTlMMy45MzcyMiAxMS45ODc0TDMuNDk3OCAxMi4zMDM4TDQuNTA4NDcgMTMuNDkwM0w5LjEwNDgzIDEyLjE0NTZMMTIuMzU2NiA5LjM5NDg1TDMuOTAyMDcgMy4xMTk5TDIuNzk0NzIgNi40NTA3MloiIGZpbGw9IiM3NjNEMTYiIHN0cm9rZT0iIzc2M0QxNiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjMuNDgyNyAxMy40OTAzTDE4Ljg4NjQgMTIuMTQ1NkwyMC4yODM3IDE0LjI0NjFMMTguMjAwOSAxOC4yODg4TDIwLjk0MjkgMTguMjUzNkgyNS4wMjk1TDIzLjQ4MjcgMTMuNDkwM1oiIGZpbGw9IiNGNjg1MUIiIHN0cm9rZT0iI0Y2ODUxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNOS4xMDQ4NCAxMi4xNDU2TDQuNTA4NDggMTMuNDkwM0wyLjk3OTI5IDE4LjI1MzZINy4wNTcxM0w5Ljc5MDMzIDE4LjI4ODhMNy43MTYyNiAxNC4yNDYxTDkuMTA0ODQgMTIuMTQ1NloiIGZpbGw9IiNGNjg1MUIiIHN0cm9rZT0iI0Y2ODUxQiIgc3Ryb2tlLXdpZHRoPSIwLjA4Nzg4NDUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTUuMzQ0NiAxNC40NjU4TDE1LjYzNDcgOS4zOTQ4NUwxNi45NzA1IDUuNzgyOEgxMS4wMzgzTDEyLjM1NjYgOS4zOTQ4NUwxMi42NjQyIDE0LjQ2NThMMTIuNzY5NiAxNi4wNjUzTDEyLjc3ODQgMjAuMDAyNUgxNS4yMTI4TDE1LjIzMDQgMTYuMDY1M0wxNS4zNDQ2IDE0LjQ2NThaIiBmaWxsPSIjRjY4NTFCIiBzdHJva2U9IiNGNjg1MUIiIHN0cm9rZS13aWR0aD0iMC4wODc4ODQ1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cg==";
const $$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: metaMaskWallet_default
}, Symbol.toStringTag, { value: "Module" }));
var injectedWallet_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAAB0CAYAAABdcbZdAAAACXBIWXMAACxLAAAsSwGlPZapAAA0N0lEQVR4nO29WZAl15nf9zvn5Hb3urV2VXcXem8ADWLhMiCHNBHU0ByZljSjsUMjjUbhsCK8KMKhkByhF9shv/rN8ovDluyQI+TRyPYoLIvjmdF4yFmI4QyJhSAIYmks3Y3eqrq2W3XXzDyLH07mrazqBsEGugG0jS/iVOZd6mbm9z/f/uVJ4ZxzfEoPLMmP+wQ+pQ9HnwL4gNOnAD7g9CmADzh9CuADTp8C+IDTpwA+4PQpgA84fQrgA06fAviA06cAPuD0KYAPOAUf9wl8WHJW46zBpAOcNTirsUYjnAVs8S2JExIpA4SUCKGQcQOpQoQKP87T/9D04ADoLM5ZrM7AZDibQzbAmRHoES7dwdkcZzXYDOcsuAJAIUFInAhBBCAVNpnBBnVE0ICwhZAeTBEkUID8INADA6DVGSYfk/ZuYMcb2NEmbuMFVLaOzG4R2ZtIkQO53woLwgEOEOAk1kbgAnABmVzAhguYcB4391lUYxFVXyDoHCeIm6i48TFf8c9G4pNaD3RGo8c98lEPvf4icnQFNbpCoC8hxATEGOQOiBQhM2SQecCUBUUBXvUHASPA+mF1CDbCuQjsDLgYXEIujmMSP4KVLxLUu6jaDMEnFNBPlgQ6i80nOJ1i997FjNZhuAZbzyPSdxHpuyh5AxEaRKghFhBICCVEAUgJSoJSIMD/EYAD58BYsBasQ2U56CHoPow3IBe4XGD0NWz6LoxWIDDY+iKitojunkWENWSQfKLs5idKAk06Itu5StZ7F/vqPyHWV4j0FYL2CGIDkYW69YCFAmpdUC0IWhDNgoxAhqDq3tah8I62AWfAjMHm4DLIdz2AZgCjddAacg0jAZmETGJ7EblYJhfLpGf/Y6LZk0Rzp4hb8x8zp/bpEwFg1l8n213HvfkvCNNLBOllUFcRwRgZjBAtIK5DVIfGCoSzEHYheRxkF9QMqA4QglAgYvbBA68/rQcODU6DGYLrg+1D+irkG5BtwOg6ZANI+7A3xuYJLk+wdhWjVjDBCubMrxN1jhLOHEUF8cfCs5I+NhVauvxm7xpm5y3YeQux9SySGwTuJnQtxAriGNqzEM1DNAf1UxDMQzAH0QUQTZBtEHX2QQuKrSiPVmxzfGhhIEjBjcCNvQTrW6A3ILgE2aYf4ioy1ZAOUb1XEdkazlzBrD2ESc8isl2YO4cMoo9NrX5sEpiP98jHe4y+/4+o9V8gGTyPms+9qowNtBOozUMyDzNfhegMRKchPAUkxQjxklV6myX9LJckQFRsJCmQgbkF+irk16D3uzBe86O34VVrKnFbIePgPOPwPNGX/ivi9iJRe/Eec+hno48FwL13X4L1P4O1P6eW/glS9ZHBHqLjoNb2Y+4ZSE5AfAKiUyBqXspEyL5zIsGVUvZe25JcZVsBXBTqdfqeAVfayauQ34TsBmz+Pow3YbQBO2OsbmDyBkY+hV74EnrhS3TO/wJCHD7u/aWPVIXatI+Z9HE3vovc+gFy5weEzauQSEgEtBagvuJH67MQHoVwBeRswW/hnRFgGt+VQE73ywG3q9AqeAVortwv/0WCSEDWQAYQdCBagHwToqsQNkG/gxynSIbQew4jAZ2TL5xEJjOo2gxCfjSJgI9QAh2jd19gePUFuq/8A2Q9R9Y1zGioJVCrwfJfgfoFqD8GwTE8gy3YrPI7iilootx/r3Hw+HceZcamfK3Zl05VjADcENLLflz/ZzDYgOEG7AoYStxIsbHy96ideobk5FcJk+a9Z+Ed6L4D6Ar7tPP8bxBtPUu8+V2C6G1EzUBiYWEVWg9D67y3dbLuRzXP7qqAVAA8IHmHpPCOGtRWXhxSm7ftF9+rJgSc9up1+GPovw791+DmczCxMLbk41Wy5lNkrSdpfunvo6IYeZ+91PuuQs14BzPagZt/jBq9RJhfhBkHtRiSGNqPQPMRD2K04P/J4RkFeDCq4BTvOctB4OShzysguumP3mEUSe8pUPYOnzv/+1KBiKBx1h9DhjC4AWoXZJ9w9C5mqJCjAfmtfxvXPkrYOYpQ94/N9xVAZw2Taz9k8NYfcuTmP4UG0AUaDlpL0H4IjvwahB0I28CIqfSIgNvFCLyT4fZt4gFprL5HxcG5kw2sglNMBlF6phz6P4Bs/7uqDs3HoP4oOAW7L0PvZch2SUbvkIwusfVsg+jhX8Y9/EvEze4H5OD7030FcPvF3yRe/w6zt/6wkDqgJmDhC9C+4EfSLmb/LrgxLs8gyxnuDdHaYLRFyYAwjgniiLg7D4Q+62IOOzIFiaq0FnQg1DgEpAJv+zRZb5N8kpJNJlijkUqilKTeqSOjCBmFIH3FAimh+3MQzkPtIci+5eNLNaHd/1OyyxnD7UsEX/svkEoh5L1n930B0KQD9GSIuP4nqOHLROZKAV4NanVoPQKNk1BbBpuhszF5PmbS75EPx2TDMb3NHnmmyTODVIqklhDXYrqrqySNNnG9Qxg3mAJ4IJw45IW6w8CBV5v+PZOPSYd90tEeW5evMBmNGY9GWG0IAoUKFd35DlGjTtSoUet0CKOYIEoQUQvqy15jtF4CsQluk3C4iRm9jhxnZJtvEzbnCVr3Pla8L07M3rs/Yvfdlzj+0t/26rJUne3T0DkNq7/mc5mBxPausnNri96tLd5+6U12NvbYubXLzWs75Jkhz33YkNQjklrIZ55+mOPnz3D8/Gnmz34GHwvKAqQ7gVjSYQkEpHdSBjfe4dobb3L19Td54Y9fZjScMBqkOAdBqAhCxdJKh+58i+5CmzNPnqW7NMfs0hzh/FGwEZgYNn4AOz/0Y3MbBsAQ1lb+c5oP/yLN89+416y+9xK4d+N1xKVvMfPmv4SWg5qDOtB9DLoXYOYCuD79Gxv0Nzd58Y9+yK0bO6xf32HrxhidaXRqMCYvfBfP7MFOjnWSq2+/wunP9Dj9+Bp/9e+dRojAx2vacDuAVRt4CMBKBPKjZ3/IK392kZ/8+UXGgyFKWaS0PkfjcnCC3lpGEG0ThAEvfe8yC8sd5lfafO5rTzCzuMjM4iJ0TvjzDdsw/l0QGqSmu/Z/kEUpWxrmLtxbEO8ZgGUFPL/xAvH2j4nGr0PTQRL60ToJ8RIELXZuXGPt8nXWL13n1efeYXdnwN72EK1jAqVQUUSz3iSIFEEkkSog1w6dO3o9gxEBWWbZj9nK9om7lMCC0tSgjcSKmJmFhCiRRLEEZzGZwWSG4TDFGMtkmHPz8oBBb8DGjW2ajYTlU330ZMzc6hkIO4jGCZ8GtHtg9oj3rqJ7P8HIefTZryBViLxHudN7BqDVGTqbIJ//RwTqBlFj4u1eowPNeZj7OZwxuOE2z//Ot3ntpRu8+sPr7NyCZkfS6ihOXVim0W7SaDeYX10maTRImnVqzVbh0Gh2Nsc0Z1s0u028R6oPOTOHHJqDZ8kUSOuKrItg+ZFzJN0FTnzmDN25OmESESUh+WTMZDAiHQy59e4NRntDhntDrl68xs6tlCsXh1x6/VnOPbbIuc8s8s1flwS1Dqp9AuY+B+oi2CG0DNHec7D2KoPHfpWkPU/SWrgnfL9nAE7WXmN49YfM6jeQUea9zXrLq5XuObLhiEuvXeLSTy7ze7/1OiKA+kybz3zlJIur8ywen+fYuWNEtZCoFhLGdaRSSBWgVIhzDudA56BCgQoEwo32T8BVw4jqdvoFDkqenb586OE5jp6aJU9PEoYCIQVCUjRIWazR5OmIfKLJJjk331lj4+omt65u8taP3mZ9bcLVK5ew5g84+/gpzj55htrM2eIYBoYXCcwEaXOGz/9jgnPfwJ3/xj1Jt90TAHU6xO68g7vxPQLVByW8kxLPQm0OaotMdods3tzm0sWbZFaxsNBm8VibC188zezKHHPL8ywc76JCiQqlj69uC9LL/UJl5pPKWVQDefjpNhCmDU846s24YIXiYCAvi20MIsZqi8kd9XZCd6nN/LEOQhrWrvZYf3eXy2/dYmahw8qJOWqrxyDuQu0IxJcR2qB0RrDxHG7hJOneUyQzRz407+8JgP31SwTX/oTWO/8cFoVPTscKOuegcRRqbbbffJO19T5X1zK+/MtPcvbJVc4+sUp3pc0+w8ZF7tN6tehEJWC/U8L60BDw3vavsj91WItSVDaqZGKKcynzo0WogRJIJZGBYOlUg6VTTeAETzzzCJdfvc6l167zp7/9IutbE9ZubjF/ahlqs+AiqL3uVakd0ln/HsPry2wHS6z83K9+aN5/qDDCOX+h13/7H9LqPUtr91nkvINGy49jvwBRAlGN/mjCbj+jN8hZWO1Sb0TUGiFBNT851YIVAFy1bvd+iev3Up/F79+2/17ptRLEYjsV5OL/psULgRGKyVgzGeesvb1FsxHQqgfMdhLQzo/1F2DvBuzdwG1ohuF5htE55v7G/1Y4NB9cjj6UBPpWvwli/Xmku44MLQQKwhpEM6CKRK6ekNQkYbPBrAyoz0R+hrsM8nz/B5XcT2cdSGkddlDKz+6QPrtNjcLPBl753uFcaLnr9ofZLz+pMKBRVzSaMfVwDoxBGgN6AlZ5RynuQrQHYYyINEG2QTjSZHtrhPUZZP2Dp9o+FIDZYJtRb42Zje8QNS00hZe4pAv1o/7KrQZnCIOAUEoIFewNKmcgC/4L3/JXgieryehDieqfCiCHwK/QHSv3d0qxVfZL8Gxl39n9fGw2nu7XwhCEwdtn7bWHFR7AZA+yPkQjonybINtm/Y0/pn38ScLVjwFA5xx6603St7/LTGyQERAISGYgakPYADsqeOwgN74vU4tCiMTtoEEFiwqwB8pD7yeBVNJq0zd+yv57AHhY6koAodg/9L4tXGRbvmf3PxP4QnB9CcJ1ZKQRscW9+S1sLcasXEAFHywu/MAAWj3B7l2H9ZdRofOSpCSEda86hfQqsizrlLPRSQ+0hP0cZjEslUayAiiBl8Yp36sx3mEbWH2/uj0seRx6/1B4UR63ClQpcYeBda5wigvVeqfPUUV1vwFBCApEmKF6F7H9a+SjHqr9weLCDwzgeHcDt/EK0bU/8HnOQEEY+v5MFfn4x5TZkWLIitRBAcwhL7L8Fyf8hKDYWoqAHe4cLtxJbd7JBnLovarUOe+NSunPTZuKRJUS6Iqab8XRmYJr981o+X/Wgcn9qQQJRA3IR5DnNHfeQG+/Qf/GayQfNYDDGz8hHFwjEf2iOzr0zouKCyAmXoqs2PckLdzG8AMq1O2r0jDAZhlmZJiMMqJ6TNyMPJglk6CC2/vdKVfqsnK/+r7bP4c8Jx3lZKOMeiv2ZaBAQl6xe7YCXpnFOwx0FUBb6ZyLOpA5CFPiQKN7b5G+9W14+KsfCIcPCKAj33qLYLyJkrlXDyqAIMJXByy+/aAAUFa6x1wBqGNfrVYBVGKKbzqeMO5NWL82ZG6lyXzYRDaiQlL2eT+1mT/lfD0JuE0aKz8iBXo8prc2YnttyPHTHaJmRBRGTGeM5c7q88D75X4BnLX7h1ExqBCkQqkc0i3s9ps4axBFau9u6K4BdM7irEG/80cwuYQKwCqJUBFCJYDxoBi7r4oQYGWRRKnYpwNODPvflQJcyvbNXW68scv3vrPO576yQCtZoNacKeyrKCSh/C0q0ngnlVm9iNKmFt9TgrK9cO/GNq89t8WPf7DFX/yVY8w+1GKu2fT3W+hDjku5Py3sV0A1le9a49WuxZuXIPK2MJwg0w3U5BXydIQKY1QQ3RUedw2gSUfkkwHB9o+RcttnvFTo+0Nk7MOGUl3aSs3GluBwUPpKwArGjrYmDHcmvPRn69xay9i4mfLulQk6W+famz3OPTXDkdUWS6stVDPZV6flJJiqxOpZV52g8lhuGlammyPWrvS5ebnPGz/ssX4zZX0t4zvfusbcYsTcQsRTXz5C0opIWvHtarLq3JQSeUCNmv3PBCAkToY4JZCTPYI0Y7R5haS9iOrcXdH37gHUGXo8QKWbiHjim6NF0fAjS/VJRULkvsSU708vuPKeFGRDzca1PmuXB9y4PGYwsqTaJ5YnE8tOz/LOj3fJxxaMYeXRuQpAct8JKeO3Kd3J6bE468A4br7T49rbA6691Wevb8lyPx8mKWxt5Az3NDPdHZZWGyyGEChVUZMcBLCqQm0ZSlS8UxxOCJABTgoEOcoYJjs3CKM63HcA0yHpYANl9hDOYaXEKYWYqsp836a5AlArfAxY2r+SXEUCpWDz0jY/fHaHHzy7zfGnjtKZDzjWUdR/sklnuc3MSpvv/su3uXwl5ciPt/kbp+rIQCECdaA3t/jxQ68P2RYlsGmOTnP+4Leu0OtLen3Bz3/zODs3+/Ru9jn92SOsXx9z6/qIf/XPrvD0M/M8/Yxh7kSnEjpUJoypODXGVqTR7jsyzoFQOBVipEIIQyQ0u9d+RFRr0Fg6dVd43D2A413SrctEwoIUOClwQuCcQzhTqNDCGFdtlCxCgWm7X2nrivcsvPzcDjs7OfW5Gr/0nzzEZHPMeGvE9jtw5kKN8z8/S6tpuPTKDm/+ZIftGyMaczH12Rj0YQTfB8BYstebsH1tyLXrmoe/MM/Xv7DA6pkab/wg42JvjyeeSDCfa6ADxT/5L/vcXM/50XM9/sKpFgdDiKq945D6pACvlEZvDJ0QOCmLtg4LWxfh6HkOesvvT3cNoM0G6MEt4uJATggcsvAJiunn8FJXSfpi3QFbd5s36mDzVkquBc12wMqpiB2RwsAhcNRrMDcLpx5tMu6nbK2NMdZhp8wx+8d6PycGQAjSVDPo5eS5pd0NOHmuRrstqCcgcDRqlqgbEc0mLJ9sUutIciP2bdoBtXkohKh+Vs3OOMO0fiDEVAmJyRboUSGh9xPA0Q5m8y3fryIFTsip8+CcQdjC3RKFTSpBqgbvpfPixL5namFvz1JvKmZmFDAgmwwZ9kZMJpp8d4jb2OGhE3VqtVkeeqRDfVYSRg6ybF/axfRPQe8VQgh0bhiPDc26oFXXdBoT8h1NNhiTpob+xoB2bEhmHX/5bx1HTwz5REOmC6+yBKbqvBxyaqYg2n2HBoPD4QoBsBJkug3ZAKMzVJj8zHjcFYBW59jRDrZ3rdR6SERxjtYD6Ky3fdYeDNxFqRoqM0zgc6NKQhCwcqrJxvURb72yy86Lm6Q7OVLrwsF0CCy4nO6coNFRJLY4XlYB77C3+V7SqKHekMyt1Bjsaa69tsfLseH0+SYm1QjhCAKHdAbSjKUjAqcFzoSQZ5UA3lYmaalCK4BWVajzk9xZ47eIfUWU7mHzISZP7yOAVmOzEW7cK9hSSlI50yqG2lG8lvsXNE2pUaJfuWDH0mqd/l5OpuHSy3tkmSPPHCa3ZGPNuJ9RiwVhoAhrAYwK58DaQ/nS8ljw3gAK4ljSng9pzcUMB4a3Xx2QBILeRkqeWtJhTjwQ2LogCYJ9bTGs2Lrp9YqD0njYG51+r9BQ046A4mt6gtWpX0blLuiuADTZGJvuYsebB71nbDGztFcRggI4/AlPZyhA4ZFW48HMg//40x0M0BsJ/tVvbJAkgiQWGKnYvjbixmuO04+1/IIGsfLSOz25giFTFVoCdwjA8uXQ0qiHNLoRn/3GCu+8tMP3nu1x6ScDtBVoJ7h2sc/yMCbOc2rzyb7dLjMrB2I+KuBx+0Qu1K0zxg9XqlH/kyYdYLIxOptwN3T3KlRnOD3BqQqAU+kzOGcRZXal6hhWBcIW6rQMyXILBpJazmNPNlg92+CVl1psXRuxfX3I1tURL/9ozDvvZBz7QZ/jZ2qsnq6zdLa1PzkOAPQzODHWQZaDMXzhqy0eOpvw2FfmeesHW+ysTxisjfmzPx9Ri0bUYvj8F1ssHk1YOpr4mPeww1IN6Keq8zCgxUR3Bmft/hxAgJ7gshE2Hd4NJHcHoLNFG5/T+8l5KHR7VU1U1Eo1cBfVIL783+LiEChn6bRCWl3FULdIYpBGs7MxQcYhNgy4fGWMQaBzx9zxOjKQSCUrIQu8vxtenLzxKq3bCQmDiPZsxGQrRVjHaDcjqMWkuWG0Z7j4kxHaCGqJpL1YLxlSAahyTbAfMpUe5/Q6K3wqJdABNscZP+6G7g7AwgBjtZdA5/zA2zpn90/MX0zJyDJ8YF/FlZ9b9sOLzCFMhtLwyFMNlmZqrM5DNtYcfbTL0Udm+D//8RVeeWPMi89tce6xJvXZiFo39l4hlcO9l/NZvqj2t/THNJOAZjtg8ettXmlblM156hePsbGh2dzU/Jv/5W2e3LSM+4af/2YJYGn/KweqXnfZ7l+CdXDW75tGBM5oMDnO3J0NfL8azB1pms8tt9YVJ1IAOp2R1XhPVobY3yJwxuFyhxtr3MT69QZ6KXovI+1nOG2YaVlOPCT46397hQuf60AQ8vbrE7Y3TSHZFek+XNa5U1HWgsscdmQgdTAy0M9JeynZKEfnlvlazqOPxzzzK7M88cUuBCEvvTTCTZz3RWTleqwAW7nG8pa3A1rI7U/6kmdOFMMDebfViLsCUBTOPEIeiE99UqIyu5zb/6dqsI44dEE+G+OsQKeWG1cn7G5mpANTNF07rHZYbQmEoxE6HjoZMzcfEkaSvV1DmrmKfa2q6EPq+rCaE4LRwLC1nrF1M2XcN2D8sYx2WOMInKXVhIXlgOUjEUEg2OkZnOZgLHvHUTkW7Afv7E+k0n9wzhXxtPQlpbugu/u2CkCGGBEdiBzsdGZV4h1b2EDPremsvy1OU4osh+HA8Xvf2uCl53bZuDaCWogLAgySNAU9MNDLCGVOPbHMtCWTXKBNca/81BYdYuBhxpYlCCW5cT3jB8/u8ud/tMO1dycQKYRSWCfJMhgPDflQwyDlyKygUSuF2kvNHVfIuO3YsqK1bbE+jsU6S4VdWBHiVOSr9ndBd2UDpYpwKsHK2vTgUw1lnfesrAGhEFN1VWVe5cLKF9oRxgGEAb005I2LKdevTPjVh5swyglxSCmQzoE2vP39HjcuDtnZ0qye69CZjbw03NHxPGwMmdojahGiFqOadf7k/76JcYJOAp12hHIWKQShBLeTMskyfvxijzCJWD3dQjVChLaQlzaucl23OWluHzhXBc9hnSgK9g4XNpBRAxXX7waSuwQwCJFBAmEdV3bTTZ2qqUFkmhMtvZYSwJKfTux/ZkAEgjBSzB2pM+5NuLkx4fqbAwY9Q3/XYLWj38tZvz7m0hsjBgNLrRMxdySh3lAHFpY4AJ6o7FN+p3Q2BLVGQHepRu4UWxs5l14bcvS4YbibY3LL3mbGrvC52P7IsTwfsrzaRMgiiJ1qGVeZpK4CZCl6lgMzfmr/3D67ZAwqur8F3SCqoWptZHMBO/AxuyzyyFKCVaUEFhUJ6y9+v9PssMoBjEOGQCj4xb+6wovf3+GF7+/wr3/jJlEkCEPJoGd546Wcm2/t8dply9GzbR77yjxHTzUg1TDW4BR3XGLyTiGFEzA2LC8nLB5t8spPxmxf7/Pb/3qbcycUg5GjP4IXvrdNv2/Z6xvi5S6rj8zw1OdnfCqturBFVbvY0ussttOCbimFbr+6ZPYTScQNZFi/qzQa3K0ESoWsdwlmHsJcA2FAWjfN00rrVanf0Qin8Quslp5ZcaHTNooC3NRBrplrR3z+6S6nH+nw1sUBO+tDejdH7O71qXWbqKUm33imy8JiwMJCCKPMx3KGfU/0MIiHqfw4c4jAEijNN3/lCLfWZrm1nnHjtW1G4xG93RFzx9p0Ttc5vljj4YebdBpQUxbGU8O1D2I1K1OGF9b6JaGdLmLoQnVaNy2g2MJRc802Iqwjw7tbluTuqhFCoKImQXtxGsPYyizy5qWKpsE5uW8PDzOxtB9FZj+qwdyMot2NmThJFAukg91exsxinaWHWpw47xnZrgPDbJ+JVU/0PTMxBwNrYTznlxcT4kTR6MaYQY4xjvHAMLvUYO5YndnjDY4djZBGI3VRiZjmgCvq8oAdtLePqtPi9vlmLYiwiQjiu75P4q7LSaoxR7RwloEVSAPSOA+iAWO8QZbCIozASYMoPLbpCg1lNmbK0IqtGmQEgSQINU9+vsneasjeuSbtbsT5x9qcu9AGpWGiYVcXwBXo2SqKP40qAbe2fgHDfMxsPWB2LuTU4iJvvl7j4nKDrzwzT60TkHQU3Br572vLgUSEd0srHm5xcUaXIlZ4nn5M15w1FPVMh9FAYwERt+/6zt27BjCstUlmj9OzCmlAaYs1/kSsFVjjyz5em5WJbIGz2t/QWDY6iQpwAv9aWu+QWAdrQxpWEM8ovvTzc9QToD/hQM8Nh6TvNgDfSxqrsSn+mEMDI4tEcHw5Yq47SysGOckhTYuEe/m/h1RnWYmYuuQGN005+tntjCv45Ce6MV51Gu1fh0cuoJp339x71wDKKCGqz2BkjENjbe5PrJA+X0GyhWorVWixYu70VrE7LOJTxkzgVdRYowKFCiVxN/DVhrJTugS8Eo3sU+V3D2c17qjG8UwvWwaloB4r6nXp7+fQBcdLG36n5Pk0bLiD2ixMiivivqratIYilAiodY+jks5dIOHprgEMojpxex7iOSx7mCzDGG9PpBEYi18wXlqENYiSocbsX2hVnZZMEHBQouQ02Yxy+/9bTYiX/1PZTF9Mha/ywWHQDlB5nnjualscvzgXxO0TReB7WsqWf+MnqittitVgNdbaQmWyP9k1mNxgbISWEZ3jnyHpfAQSqKIaQoXIlc/jeq9hdnsY7RDSIZVXE6aQDmksgrI+aPbLS1oUcYf0tb3ydrIKH6d2qqyzVZ2UquTdaf9On1W3Bw9UCW+oSBP+/HDcfocUTF3vvOz5LMOFErh8+lASL3GlvXPo3KJzi80tNmhj4wXqsysEUe392H8b3TWAQiqUVESLZ3HpLew2+zaw8EiF9eYM63DCIoRAKDPVKNvbfk0Xh6TWiVGBQIWSMCzaE6uA+qPe9YXdRu8TXdx2qNs8ZTcFIZsYdGYwmUVPNHEsqUWCMCyCu3KUQXsZapmK6ixyvSRNZOMoQdJAfoBFDz7wzS3NM88wGV5n/O6fonOLkAKpCo+qwMBYhywyMirUGG3Jc8P3nt1F5w6t4eyZJq12SLMVMr+QIGOFjBTEwbRf9L0XoKvuHwL5MP63+TNu/8MD360mGQo1ai2McrKxZjLSrN0c0+vl7O5m7O5pHjqecGI1YelYOFWbzhi/woV1her0jqnJCyksHBhRP0Kw8uRdZ2BK+sAAdlbOYa4cp58sYNINvzSHEmhtCwAlxpRq0aGcxjmJs5KX307pDzT9geXN6xPiWJHEkuXFmFZD0Wgqut2YMFFEsaLZjAhDQRBJ4kQhpUQoUay2VNqinwJgSVP1WHqMeL/DWO8RGsdorMlSS55ZhnsZaWpIJ4aN9Ql7A0N/aNjeyRhNLMOxwTiBCwSLS2GRcSrVp506K0b7pxqYYrEik/sFhDKX0Fw4R/PC1z8oDB8cwKQ1R9BZRs6cxG7fKsowyjs0ZYHAOq8+hQBrvWYMBCKATDv6I81mz6KUIFCC0UjTqEkadUV3JiOKFFEsabVj4lgQx4p6I0AFgiCQqEgUku8nD3DAO71Na06bjbwUlOotn3iblOeOvX5OmlrSiWGwl3sAU8OtzYzRxDCaWMYTwyRzTDJLnAQYinRg0TJBoTKnXmehfvcl0eG0xcZzBJ2jNBZPflAYPjiAUWOG2srj1B/pMfnD7/vVj5XFZD4OFAJMsK/TTWpRsSSoCZ76TJ13Lo8RwtBpSbR2aOO4tpFOL7oUKiEEtVgSh5IoErRbXlqTSNJqKMJAEoS+w2wK3hTAg56NK1J91jomYzNdvqs/0EwmlnFq2ekbstyRa4suvFCHn5RBAEEgaLUFcQa1TLKwFLOyHLKwoCCb4HKLNdYnNQrP02i8yci9ZJvUYiYWefxJ4sXzNBdPfFAYPtwiB7XF08yqiCt/+N94HZFqdBIUTLSoUPoaIRItBYFxKG149EyMNYbBUBMK47MvSpBmDlOEXnm+P2O1taTWMhnB3lhji3xAKd0C/LLWPnXuC+NQtHuI/YUvLIhCdQpdAOx8m60sHC/lIAwdUSwIAy/dUkIc+puQlQIpBaOxZTSGxx6ps3IkIEksbmimjso0UDeumCgWnTlMZgr7L5h58pepLT9SVDc+BgDD2gz1eYlor+L0Ji7bxGjrn9EnhVenovC6lE/cSumY60rmZwMW5yN2t8dEISSxII6KGWshzQVGe0BTXfgGxjGxjpH0Q1caisp7SRygyx4nuy89SP9cLOn8iAv9KgQQQWIFNSdoOr+Ml1SCOBCowIMWh14jKAlpBnHs7fCx5ZB2SyIxHrQyZChSZcZ6EE1hA11ucaKGjRKaRy8Uz5v44F72hwSwSVhrEj36K7ir38Vc+y46K4M9QRD5Ziec9Z1jzuK0ozUbcmwlAqn4k++OiS1I4UjqZZd3sV5A0StiyvKidexKWIsd/dgxKkozWEitlyQD5LLw4osQrVx8PnD+gkOEv3G4GLomSIygrgUn+vgbduTBZWuqQrK7p6k1I7qNiIfPxCibwyT3iSLrphLoHRfQmZ0OMzHY1hFc6wyzpz//oddLuydLbS1//q/QY0Bv7TXkZBucT5XlWdmsI5HS4ZRXb8EoZ64Z0DgZc/GtBpNxxl4/Z66rPMOKWwpL6bLgE+dWsBU7drqOK13LuCYQzuezdfE9CxhVhGLan58IQSiB0A4FKBxxMeuFgKG0rAwEeiC4MFbem6ykbEvKct8pLsOQ5eWEkyfqhEJjtUGnrmL3vNo0pd1LHSa16EyT6YDGyuM0PvNLSBl86BD3ngDYWDrJZPE00eIZ9Pr3EdJilMDmElNw2ATeHikHJrOEkbczK8sxGxuOdGzIc1eoLLEfFVQyVtJCpmBQh14X8raaPi3JwbTPiAjMBOzY4YxD1SWqKbGpLbJkDlPh3K411CXUjPN3QReS6SpSp4vYLcsdM7MR8/MRS4th0Qro1aQ13m6XyWptHFpbHzZoi0kdqnWEZPEMreOP356r/QB0TwBM2ot0zz5NnAje/mfPY4FIGLJQEhQqUSmBUhaUJJ1YIjSRdHz+iSavXZRMUuhtD6nXJfWaQB3SLGUBtIdlt+bozQmixQiEREqFEqCkQyhIugGTNU26bsj3DMlyRGM1JO1rTO6wucUhp62Q48mYnrOoiWWsIQbiQ37FaGTJtCDTki8/2WFpVrLYhXwrL2ydz7V7IPdVps6945KPHdlYsPjU15k5+yU6q0/eC9bfu/VCk4VzhM15mqd+E9O/Tt6/horsNBiTgSyKmd7JIfUr0jebitPHI2a6EX/6PYPRht6eZqblHaGy/cRY78jsOscklIiaolFLiGRAJBVhJKaF48lrOeYypFcs+a4lumUxO9A5XYMauKZAp2CwGOfoC4OIcibKMswdQgrCQjVnuSPPHZNcsrCYsLBY4/SxgNBq9F7uMyql3dMObXxbogfQB+16bLGyjWq3WPzyf0gwc+Jesf3eASiTNjKq0zr1eUZXJMO9TWye+3hQgMktolg+SxYBtbMQGUOrFhAliqWlhN3djL1df5+6Um7qtlvnVdNEglECESmSMCRSBYAhmD3rx2WLW3Ow7RB74NbAhhZbc0RdRTQXkAsfnmjrCPMAERhMsRyMKWub1jsi2gjanYiFhZjjRxMaocWMLTa1/rtlvFdmdAr7Z7VPWGstiLoLhHOnSZYe9g9evkd07xY9Fz5IOvq1/5S17/0Gw41r5KOr3plwIFTZDyIRQuCUxCkY9zOixDJTC/jyF2d469KYty8F3Ly6Ry0WJImglgishdw4hgpMJAljRSOOiQNFpAIC7ei9M2L3pRHZ1QwXQBIIdCwR25ZsN2PyWsbC0w26Tycwo0hzS5YZalGACDRWCTLnyI0PYfZGBhkGiCDgs1+YY6krWJqV5NuDwsZV1abzQbr2UpenBptZTGrIspjuyadZ+uK/h6gtFQz7WTsIfjrd41XrHbJ9gu6FbxC353j7t/4hVhhCq5FKgPVqVAiBDTyYIHBjjc4N7brg7LGQIwsRz8eSfj9juJeSZwaTCUwOkxhsJAliRSOKSaKAWqzYfaGPuayx1zSf/Q8W6W9n9LcyRus5C6frLJ6u8dL/fAu3Zhi9nHL0F2eYSMdEWOpmRB5KdAj9iYHM3/s/c6TB0lLCkSMJp1cESmvynibL9lNjufY2z2hHnnqJM9phJoZ8AvlEcPRrv07r7C+QHP/yvWU39+GxAyKsE8+fJAgDakvnsKN19OgWQV7Eh0Igc5+dwVlfQnHeW4xDTSMMqNUCjq0kbG0LtqVguJtirCPNHblwOCUICsmrRYp6HLDbc4iRQ2aOow832LwqfM6zb+keiVg53+DGsRpBSxFZSUMFqMAhnSUKAmwgyCXkTiADRZwErCzXWFoMObIQUFO5L8Cm2nuZRTnQFC0lRpdt+V6N6tRC2CaM27TP/lskRx5G1uaqnLon/L4vT25R7VVUe5XVX/w7bLz4O2y8+DsEoUEVqRIhipxkIBAIrPJjMEgJw5wwUnzhsRZb/YTtPjz//A7btzIGvZS0WCwhjhSNKKQVhTTjgM2xIEGg64rjKw3EniUNNCOd0okCljoxP/fXj5BnjixzNImJlSUWlnoWkCuFkQIXBswu1Tm3XOdLTzcIbIYyGePtyXQl6IPeppneS6GzQgIzw2QInTPnaZ/5Ap0n/ybvXXn+cHSPASyLbv4Emw//JQg71BaOc+0P/kci7Yi1Lgr0AmkkAoNUAqskLgRrfVUgtgMaStFoB9R+rsO16zlXb2T8caNX1AoVjTCiEYQ0ZMDK6TY3tgy7/RFv/u42w36O6RuaSUAriOjImPrxhMw4UuPIlEJJS2ANsVAkYUBaC3j8sTbn5wLOzSnUcIDJDZnxCe6yb0nnhdosQSukT481eerXYl/83DdpPfx12ue/zkHw7i3dp4dfeRCD1jL1lcdQgWTz5e9AukWebiOD/RSbUfu3VyEEVjq/xNpEEMaOUDnmWzHprCLLQpJYkYYSKyVxUHigQjF7pMb4SMroSMrWG2PSzJBlvp0j6xnGt3LqMzVUJIiEYJBRlD0EgfTJ9DAQdJuSdk3QDI1fCKi4W0lXKhm6kDhbBOm2UJv5xHm12WnTPvtV6seeIpo/W+EJ3Evpg/v69DIPYrT4KNHio5wYb7H5o/+HzR/9AQwGhLEjSAT+sXy+mo+Txb4AZ8i1QY0gDHNaSI52BN26Yq+uyIUiCSIioYhswPzZLo0oYul4gxf+1yuM93LG/ZzajOJdLcl3LY8849c7qzdjTAjS+mVRIqWIlCBSEOYT7FAwdhKRlA24hY2z+6qybBM0adFakVmGA8nMuUeYOfc0c1/9u/tJWO+53Rcu3wcAq+qiqk7/Mqq1SufU57j6+/89qR6Q7g2oO4cKJC7w+kkqn+V3oUBJv4aKNobRQDMcOFygEdYRSEkog2KEBEgWlhSLM03muzVuvrnLzYu7rF8cMNoyXHt5wK03LvPQ5+Z46LNzNJfbOKExQhMqhRQChyPNNGmoyPxjj/aT04XatMZhsqIX1lgmewbtQrQNWP3G36Jx4ks0TnzJL/4HRQxVKVLeY7qPEljaw1KdrlBf1kT1JvWLP0DvvEvWu0o+2cGGjsAWD5uyIKyv8zkp8cl6n5LKMw9y2YwtpfD3a0iFRBAliiiB5nmFzR3pQDO4lVHvxNTbETde26W1MKY+N6K9MoOSEoVECh+bSleqRq8mld4vD5UAugJAUwTsVjVR9QXC+gKdc88QL14gmjtd8MDdL9ym9NE8xdpZEBLVWUV1Vjnz73fY/sm32Xn122y99PtEkSWKHElTIZVDBD6TLKXz7RJCFJkNh5z2agJCIYRCiuplCNpRRKc1oT0/4egFOP3EAqefmOef/9cvsruWsvv7a5z+0nGEcCjlfK0QX26SpUOiwaXljSgOnTnfO2Mc2VCTZZBlgtrqWeYufI25C18jOfUXD13zfUaP+w5gtddz3wNTndN0H2/TPPUV6osPMbr+OoMbr5P3bhGE1i+9XVf+SSlF0c7mQO6IJ45hqcIEfulGBG8/t04SKuJA8dnHjiFcAi7EaUXiaswEMxx/fJ7t60O2rw8xTmKFwAKp1bjUEg0dYWoRoV+A3hVdZc46som3c3kGmhb15VN0lk6z+OX/iLC9QthZLq6u7MG4f2qzSh/Rc+QP9vSJsEE4ExO2j6DPPYNMZnFRm/HVF8AMyfUYMTbIwDc8ycAD6IwjmjjkxNfWcmcwzuJw9NZHyBxkDo+eXfH9LEWDjLXe9ffdHQIVS6xwaGfJMYyzHJcaopEj0CCKPCbO5zqNdmSZwIkGIqlRm3+YxrFHaR57lObq5/xt0ap+8HI/AvDgIwPwEDlb5E4D2p/5a7TO/gXseJMb3/7vGFx/g/61i4x31gkj56UxkZhM+PXNti30Msa9EcN8QiwkuQoY7KbsvDFg540BDz+9Qm849oVdBb10wtXtHd567haNhZju6QYWTWoz+nrMTn9EayuluW6IMgEh5CnYzJDlkGcCIxs0jpymsXya1W/83Wmyorigj0xlHqaPEEBx+27hoYmogwzqLD7z9+nuXUf3rrP1o/+LrHeTtHeDvd5134aeO2a0JdjKSNcM64MeJskh0Sx/eQZVF1gMf/ybr/m0V27J+jlb1we8+cIasgUz5xOOPNFhV++xnU7Yzkb01/p01zOW1iwyNeQI9owkaiwSdpeod5aYf+IvEXZPEHYfIpxd3V+MoGz7n4L30YL48UhgqVLLa5UhQobEC+eIWvPY+VXycY/J1lWCrWtw/cdkgyF6OKLe2yMaGuS2Zmc0JHKCRAjaczH14xEzozr9yyPyiUEPDXqocZHDJY7OyRqNYxHxUkA/m9BLh2ylQ8xWTrQnaI0TiJuIZoOgXad+5Bxx9yjR7FHaZ76Cai4hG0scWNxD3LbzkdLHBCAcDDMoZrJEJLOoZJaFr/xnkPdxWZ/dN7/NrUtvsn7pIu0f/ZhOf4v2u5vc3NrBtf2ty7LhaDwc0X1knuHlERuvDth8tU9uYOZ8jeWnOsyfa6GFZULO+mDAzXGfm+M+8t2M+laH2WyG/NSjdE+cZvHkaZae+CYimUXEswdPvbLS4EflrLwX3ZenWH8wcgd3hZi2lunxDtl4RDYesnb1Che3L3Fx+xL/bfI/0JmPmFmIeGhmhloYUQtDalIy3sgYb2TkfUNrJaZ1NMFKx9hoJlpzdXebrZ0JW9sTfm3jb/JI+zSPts6wevIkcb1F3GgQNeaK1fgDDtyO9jFLXZU+Rgk8TJUMztSc+CJx0FwiaDrqziGai7hbyzRvrXLy2u8zGfXZ29rjpuvTSGIaScRMK8Y2DE4K1Iwkb1r6ImM4yhhmOaMs59bmGDVosDSa53PHnmF1/gTHFh6iu3QEKdXt7X7iPV98rPQJksAqVaXxvVNR3/ruP+XfbHyH39v8NjsLW7RbEe1myGwzIgj9/RNhoIqWdsP2MGUwyumPNOk1wdeaz/C11jP8nX/nH/hm5MN3QU2PXdInB7iSPqEAHqbDp+gZubW7xo29t7mx9w7/+8X/iev5BtfyDTaCPcJQTB9orHNHrmE2q7EkZzmi5vh3j/81Tsxe4MTcoxydPc700T93OM4nmT5BKvSn0Z0ZOdc5QiOKWG0c4cb2RS6NrrM4usZb6bvoPCPP/VPDFAGKkDO1YxyLlzkeH+HLy1+lO7NCp3P0fY/zSaYHRALvRLdXtvPJBvl4k1eu/BFX9m5xpb+BFo6jjVmONmZ5+uTXiWrzhLUFfzfMT/mtB4UeYABvJ2dznM0ZTnpMTMZE5zgBsQyIVUgr6SKVjzkfVMAO0/+nAPz/I33wG9M+pU8EfQrgA06fAviA06cAPuD0KYAPOH0K4ANOnwL4gNOnAD7g9P8C87hIFQ1UAxAAAAAASUVORK5CYII=";
const $$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: injectedWallet_default
}, Symbol.toStringTag, { value: "Module" }));
var coinbaseWallet_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjI4IiBoZWlnaHQ9IjI4IiBmaWxsPSIjMkM1RkY2Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQgMjMuOEMxOS40MTI0IDIzLjggMjMuOCAxOS40MTI0IDIzLjggMTRDMjMuOCA4LjU4NzYxIDE5LjQxMjQgNC4yIDE0IDQuMkM4LjU4NzYxIDQuMiA0LjIgOC41ODc2MSA0LjIgMTRDNC4yIDE5LjQxMjQgOC41ODc2MSAyMy44IDE0IDIzLjhaTTExLjU1IDEwLjhDMTEuMTM1OCAxMC44IDEwLjggMTEuMTM1OCAxMC44IDExLjU1VjE2LjQ1QzEwLjggMTYuODY0MiAxMS4xMzU4IDE3LjIgMTEuNTUgMTcuMkgxNi40NUMxNi44NjQyIDE3LjIgMTcuMiAxNi44NjQyIDE3LjIgMTYuNDVWMTEuNTVDMTcuMiAxMS4xMzU4IDE2Ljg2NDIgMTAuOCAxNi40NSAxMC44SDExLjU1WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==";
const $$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: coinbaseWallet_default
}, Symbol.toStringTag, { value: "Module" }));
var braveWallet_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjc3MCIgaGVpZ2h0PSIyNzcwIiB2aWV3Qm94PSItMTAwIC0xMDAgMjk3MCAyOTcwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOndoaXRlIj48bGluZWFyR3JhZGllbnQgaWQ9ImEiIHkxPSI1MSUiIHkyPSI1MSUiPjxzdG9wIG9mZnNldD0iLjQiIHN0b3AtY29sb3I9IiNmNTAiLz48c3RvcCBvZmZzZXQ9Ii42IiBzdG9wLWNvbG9yPSIjZmYyMDAwIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgxPSIyJSIgeTE9IjUxJSIgeTI9IjUxJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmY0NTJhIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmYyMDAwIi8+PC9saW5lYXJHcmFkaWVudD48cGF0aCBmaWxsPSJ1cmwoI2EpIiBkPSJtMjM5NSA3MjMgNjAtMTQ3LTE3MC0xNzZjLTkyLTkyLTI4OC0zOC0yODgtMzhsLTIyMi0yNTJIOTkyTDc2OSAzNjNzLTE5Ni01My0yODggMzdMMzExIDU3NWw2MCAxNDctNzUgMjE4IDI1MCA5NTNjNTIgMjA0IDg3IDI4MyAyMzQgMzg3bDQ1NyAzMTBjNDQgMjcgOTggNzQgMTQ3IDc0czEwMy00NyAxNDctNzRsNDU3LTMxMGMxNDctMTA0IDE4Mi0xODMgMjM0LTM4N2wyNTAtOTUzeiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0xOTM1IDUyNHMyODcgMzQ3IDI4NyA0MjBjMCA3NS0zNiA5NC03MiAxMzNsLTIxNSAyMzBjLTIwIDIwLTYzIDU0LTM4IDExMyAyNSA2MCA2MCAxMzQgMjAgMjEwLTQwIDc3LTExMCAxMjgtMTU1IDEyMGE4MjAgODIwIDAgMCAxLTE5MC05MGMtMzgtMjUtMTYwLTEyNi0xNjAtMTY1czEyNi0xMTAgMTUwLTEyNGMyMy0xNiAxMzAtNzggMTMyLTEwMnMyLTMwLTMwLTkwLTg4LTE0MC04MC0xOTJjMTAtNTIgMTAwLTgwIDE2Ny0xMDVsMjA3LTc4YzE2LTggMTItMTUtMzYtMjAtNDgtNC0xODMtMjItMjQ0LTVzLTE2MyA0My0xNzMgNTdjLTggMTQtMTYgMTQtNyA2Mmw1OCAzMTVjNCA0MCAxMiA2Ny0zMCA3Ny00NCAxMC0xMTcgMjctMTQyIDI3cy05OS0xNy0xNDItMjctMzUtMzctMzAtNzdjNC00MCA0OC0yNjggNTctMzE1IDEwLTQ4IDEtNDgtNy02Mi0xMC0xNC0xMTMtNDAtMTc0LTU3LTYwLTE3LTE5NiAxLTI0NCA2LTQ4IDQtNTIgMTAtMzYgMjBsMjA3IDc3YzY2IDI1IDE1OCA1MyAxNjcgMTA1IDEwIDUzLTQ3IDEzMi04MCAxOTJzLTMyIDY2LTMwIDkwIDExMCA4NiAxMzIgMTAyYzI0IDE1IDE1MCA4NSAxNTAgMTI0cy0xMTkgMTQwLTE1OSAxNjVhODIwIDgyMCAwIDAgMS0xOTAgOTBjLTQ1IDgtMTE1LTQzLTE1Ni0xMjAtNDAtNzYtNC0xNTAgMjAtMjEwIDI1LTYwLTE3LTkyLTM4LTExM2wtMjE1LTIzMGMtMzUtMzctNzEtNTctNzEtMTMxczI4Ny00MjAgMjg3LTQyMGwyNzMgNDRjMzIgMCAxMDMtMjcgMTY4LTUwIDY1LTIwIDExMC0yMiAxMTAtMjJzNDQgMCAxMTAgMjIgMTM2IDUwIDE2OCA1MGMzMyAwIDI3NS00NyAyNzUtNDd6bS0yMTUgMTMyOGMxOCAxMCA3IDMyLTEwIDQ0bC0yNTQgMTk4Yy0yMCAyMC01MiA1MC03MyA1MHMtNTItMzAtNzMtNTBhMTMyMDAgMTMyMDAgMCAwIDAtMjU1LTE5OGMtMTYtMTItMjctMzMtMTAtNDRsMTUwLTgwYTg3MCA4NzAgMCAwIDEgMTg4LTczYzE1IDAgMTEwIDM0IDE4NyA3M2wxNTAgODB6Ii8+PHBhdGggZmlsbD0idXJsKCNiKSIgZD0ibTE5OTkgMzYzLTIyNC0yNTNIOTkyTDc2OSAzNjNzLTE5Ni01My0yODggMzdjMCAwIDI2MC0yMyAzNTAgMTIzbDI3NiA0N2MzMiAwIDEwMy0yNyAxNjgtNTAgNjUtMjAgMTEwLTIyIDExMC0yMnM0NCAwIDExMCAyMiAxMzYgNTAgMTY4IDUwYzMzIDAgMjc1LTQ3IDI3NS00NyA5MC0xNDYgMzUwLTEyMyAzNTAtMTIzLTkyLTkyLTI4OC0zOC0yODgtMzgiLz48L3N2Zz4=";
const $$0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: braveWallet_default
}, Symbol.toStringTag, { value: "Module" }));
var systemFontStack = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
var fontStacks = {
  rounded: `SFRounded, ui-rounded, "SF Pro Rounded", ${systemFontStack}`,
  system: systemFontStack
};
var radiusScales = {
  large: {
    actionButton: "9999px",
    connectButton: "12px",
    modal: "24px",
    modalMobile: "28px"
  },
  medium: {
    actionButton: "10px",
    connectButton: "8px",
    modal: "16px",
    modalMobile: "18px"
  },
  none: {
    actionButton: "0px",
    connectButton: "0px",
    modal: "0px",
    modalMobile: "0px"
  },
  small: {
    actionButton: "4px",
    connectButton: "4px",
    modal: "8px",
    modalMobile: "8px"
  }
};
var blurs = {
  large: {
    modalOverlay: "blur(20px)"
  },
  none: {
    modalOverlay: "blur(0px)"
  },
  small: {
    modalOverlay: "blur(4px)"
  }
};
var baseTheme = ({
  borderRadius = "large",
  fontStack = "rounded",
  overlayBlur = "none"
}) => ({
  blurs: {
    modalOverlay: blurs[overlayBlur].modalOverlay
  },
  fonts: {
    body: fontStacks[fontStack]
  },
  radii: {
    actionButton: radiusScales[borderRadius].actionButton,
    connectButton: radiusScales[borderRadius].connectButton,
    menuButton: radiusScales[borderRadius].connectButton,
    modal: radiusScales[borderRadius].modal,
    modalMobile: radiusScales[borderRadius].modalMobile
  }
});
var darkGrey = "#1A1B1F";
var accentColors$2 = {
  blue: {
    accentColor: "#3898FF",
    accentColorForeground: "#FFF"
  },
  green: {
    accentColor: "#4BD166",
    accentColorForeground: darkGrey
  },
  orange: {
    accentColor: "#FF983D",
    accentColorForeground: darkGrey
  },
  pink: {
    accentColor: "#FF7AB8",
    accentColorForeground: darkGrey
  },
  purple: {
    accentColor: "#7A70FF",
    accentColorForeground: "#FFF"
  },
  red: {
    accentColor: "#FF6257",
    accentColorForeground: "#FFF"
  }
};
var defaultAccentColor$2 = accentColors$2.blue;
var darkTheme = ({
  accentColor = defaultAccentColor$2.accentColor,
  accentColorForeground = defaultAccentColor$2.accentColorForeground,
  ...baseThemeOptions
} = {}) => ({
  ...baseTheme(baseThemeOptions),
  colors: {
    accentColor,
    accentColorForeground,
    actionButtonBorder: "rgba(255, 255, 255, 0.04)",
    actionButtonBorderMobile: "rgba(255, 255, 255, 0.08)",
    actionButtonSecondaryBackground: "rgba(255, 255, 255, 0.08)",
    closeButton: "rgba(224, 232, 255, 0.6)",
    closeButtonBackground: "rgba(255, 255, 255, 0.08)",
    connectButtonBackground: darkGrey,
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(255, 255, 255, 0.075), rgba(255, 255, 255, 0.15))",
    connectButtonText: "#FFF",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(0, 0, 0, 0) 9.49%, rgba(120, 120, 120, 0.2) 71.04%), #1A1B1F",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(120, 120, 120, 0.2) 9.49%, rgba(0, 0, 0, 0) 71.04%), #1A1B1F",
    error: "#FF494A",
    generalBorder: "rgba(255, 255, 255, 0.08)",
    generalBorderDim: "rgba(255, 255, 255, 0.04)",
    menuItemBackground: "rgba(224, 232, 255, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.5)",
    modalBackground: "#1A1B1F",
    modalBorder: "rgba(255, 255, 255, 0.08)",
    modalText: "#FFF",
    modalTextDim: "rgba(224, 232, 255, 0.3)",
    modalTextSecondary: "rgba(255, 255, 255, 0.6)",
    profileAction: "rgba(224, 232, 255, 0.1)",
    profileActionHover: "rgba(224, 232, 255, 0.2)",
    profileForeground: "rgba(224, 232, 255, 0.05)",
    selectedOptionBorder: "rgba(224, 232, 255, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
darkTheme.accentColors = accentColors$2;
var accentColors$1 = {
  blue: {
    accentColor: "#3898FF",
    accentColorForeground: "#FFF"
  },
  green: {
    accentColor: "#4BD166",
    accentColorForeground: "#000"
  },
  orange: {
    accentColor: "#FF983D",
    accentColorForeground: "#000"
  },
  pink: {
    accentColor: "#FF7AB8",
    accentColorForeground: "#000"
  },
  purple: {
    accentColor: "#7A70FF",
    accentColorForeground: "#FFF"
  },
  red: {
    accentColor: "#FF6257",
    accentColorForeground: "#FFF"
  }
};
var defaultAccentColor$1 = accentColors$1.blue;
var midnightTheme = ({
  accentColor = defaultAccentColor$1.accentColor,
  accentColorForeground = defaultAccentColor$1.accentColorForeground,
  ...baseThemeOptions
} = {}) => ({
  ...baseTheme(baseThemeOptions),
  colors: {
    accentColor,
    accentColorForeground,
    actionButtonBorder: "rgba(255, 255, 255, 0.04)",
    actionButtonBorderMobile: "rgba(255, 255, 255, 0.1)",
    actionButtonSecondaryBackground: "rgba(255, 255, 255, 0.08)",
    closeButton: "rgba(255, 255, 255, 0.7)",
    closeButtonBackground: "rgba(255, 255, 255, 0.08)",
    connectButtonBackground: "#000",
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.12))",
    connectButtonText: "#FFF",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(0, 0, 0, 0) 9.49%, rgba(120, 120, 120, 0.1) 71.04%), #050505",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(120, 120, 120, 0.1) 9.49%, rgba(0, 0, 0, 0) 71.04%), #050505",
    error: "#FF494A",
    generalBorder: "rgba(255, 255, 255, 0.08)",
    generalBorderDim: "rgba(255, 255, 255, 0.04)",
    menuItemBackground: "rgba(255, 255, 255, 0.08)",
    modalBackdrop: "rgba(0, 0, 0, 0.7)",
    modalBackground: "#000",
    modalBorder: "rgba(255, 255, 255, 0.08)",
    modalText: "#FFF",
    modalTextDim: "rgba(255, 255, 255, 0.2)",
    modalTextSecondary: "rgba(255, 255, 255, 0.6)",
    profileAction: "rgba(255, 255, 255, 0.1)",
    profileActionHover: "rgba(255, 255, 255, 0.2)",
    profileForeground: "rgba(255, 255, 255, 0.06)",
    selectedOptionBorder: "rgba(224, 232, 255, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
midnightTheme.accentColors = accentColors$1;
var Browser_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA3OCA3OCI+PGcgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGZpbGw9InVybCgjYSkiIGQ9Ik0zOSA3NmMyMC40MzQgMCAzNy0xNi41NjYgMzctMzdTNTkuNDM0IDIgMzkgMiAyIDE4LjU2NiAyIDM5czE2LjU2NiAzNyAzNyAzN1ptMC01YzE3LjY3MyAwIDMyLTE0LjMyNyAzMi0zMkM3MSAyMS4zMjcgNTYuNjczIDcgMzkgNyAyMS4zMjcgNyA3IDIxLjMyNyA3IDM5YzAgMTcuNjczIDE0LjMyNyAzMiAzMiAzMloiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMzkgNzZjMjAuNDM0IDAgMzctMTYuNTY2IDM3LTM3UzU5LjQzNCAyIDM5IDIgMiAxOC41NjYgMiAzOXMxNi41NjYgMzcgMzcgMzdabTAtNWMxNy42NzMgMCAzMi0xNC4zMjcgMzItMzJDNzEgMjEuMzI3IDU2LjY3MyA3IDM5IDcgMjEuMzI3IDcgNyAyMS4zMjcgNyAzOWMwIDE3LjY3MyAxNC4zMjcgMzIgMzIgMzJaIi8+PC9nPjxjaXJjbGUgY3g9IjM5IiBjeT0iMzkiIHI9IjMwIiBmaWxsPSJ1cmwoI2MpIi8+PGNpcmNsZSBjeD0iMzkiIGN5PSIzOSIgcj0iMzAiIGZpbGw9InVybCgjZCkiIGZpbGwtb3BhY2l0eT0iLjciIHN0eWxlPSJtaXgtYmxlbmQtbW9kZTpzY3JlZW4iLz48ZyBmaWx0ZXI9InVybCgjZSkiPjxjaXJjbGUgY3g9IjM5IiBjeT0iMzkiIHI9IjI5LjUiIHN0cm9rZT0iIzAwMCIvPjwvZz48ZyBmaWx0ZXI9InVybCgjZikiPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjMiIGQ9Im01NS42ODEgNTMuNTk3LTguOTczLTE4Ljg2NWMtLjU0LTEuMTQ3LTEuMzE2LTEuOTI0LTIuNDI5LTIuNDYzbC0xOC44MjQtOC45MWMtMi40MjktMS4xNDctNC4yNS42MDctMy4xMDMgMy4xMDUgMS4xNDcgMi40OTcgOC45NCAxOC44MzEgOC45NCAxOC44MzEuNTA1IDEuMDggMS4yNDggMS44MjIgMi40MjggMi40M2wxOC44NTggOC45NDNjMi4zNjEgMS4xMTQgNC4xODMtLjc0MiAzLjEwMy0zLjA3MVptLTEyLjM4LTEzLjZjMCAyLjMyOC0xLjkyMyA0LjI1Mi00LjI1IDQuMjUyLTIuMzI4IDAtNC4yNTEtMS45MjQtNC4yNTEtNC4yNTJhNC4yNTUgNC4yNTUgMCAwIDEgNC4yNS00LjI1MmMyLjMyOCAwIDQuMjUgMS44OSA0LjI1IDQuMjUyWiIvPjwvZz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii44IiBkPSJtNTUuNjgxIDUyLjU5Ny04Ljk3My0xOC44NjVjLS41NC0xLjE0Ny0xLjMxNi0xLjkyNC0yLjQyOS0yLjQ2M2wtMTguODI0LTguOTFjLTIuNDI5LTEuMTQ3LTQuMjUuNjA3LTMuMTAzIDMuMTA1IDEuMTQ3IDIuNDk3IDguOTQgMTguODMxIDguOTQgMTguODMxLjUwNSAxLjA4IDEuMjQ4IDEuODIyIDIuNDI4IDIuNDNsMTguODU4IDguOTQzYzIuMzYxIDEuMTE0IDQuMTgzLS43NDIgMy4xMDMtMy4wNzFabS0xMi4zOC0xMy42YzAgMi4zMjgtMS45MjMgNC4yNTItNC4yNSA0LjI1Mi0yLjMyOCAwLTQuMjUxLTEuOTI0LTQuMjUxLTQuMjUyYTQuMjU1IDQuMjU1IDAgMCAxIDQuMjUtNC4yNTJjMi4zMjggMCA0LjI1IDEuODkgNC4yNSA0LjI1MloiLz48cGF0aCBmaWxsPSJ1cmwoI2cpIiBkPSJtNTUuNjgxIDUyLjU5Ny04Ljk3My0xOC44NjVjLS41NC0xLjE0Ny0xLjMxNi0xLjkyNC0yLjQyOS0yLjQ2M2wtMTguODI0LTguOTFjLTIuNDI5LTEuMTQ3LTQuMjUuNjA3LTMuMTAzIDMuMTA1IDEuMTQ3IDIuNDk3IDguOTQgMTguODMxIDguOTQgMTguODMxLjUwNSAxLjA4IDEuMjQ4IDEuODIyIDIuNDI4IDIuNDNsMTguODU4IDguOTQzYzIuMzYxIDEuMTE0IDQuMTgzLS43NDIgMy4xMDMtMy4wNzFabS0xMi4zOC0xMy42YzAgMi4zMjgtMS45MjMgNC4yNTItNC4yNSA0LjI1Mi0yLjMyOCAwLTQuMjUxLTEuOTI0LTQuMjUxLTQuMjUyYTQuMjU1IDQuMjU1IDAgMCAxIDQuMjUtNC4yNTJjMi4zMjggMCA0LjI1IDEuODkgNC4yNSA0LjI1MloiIG9wYWNpdHk9Ii4xNCIvPjxwYXRoIGZpbGw9InVybCgjaCkiIGZpbGwtb3BhY2l0eT0iLjA4IiBkPSJNNjEuMjQ4IDU2LjAwOGMuMTY2LS4yMTcuMjUtLjMyNS4zNzgtLjY2Ljc1NC0xLjk1LTEuMTgzLTMuOTUtMy4xNTctMy4yNi0uMzM4LjExOC0uOTA0LjUyMi0yLjAzNSAxLjMzMkEyOS44NjMgMjkuODYzIDAgMCAxIDM5IDU5LjAwM2EyOS44NjMgMjkuODYzIDAgMCAxLTE3LjQyNS01LjU3N2MtMS4xMzItLjgwOS0xLjY5Ny0xLjIxMy0yLjAzNS0xLjMzMS0xLjk3NC0uNjktMy45MTEgMS4zMTMtMy4xNTYgMy4yNjMuMTI5LjMzNC4yMTIuNDQyLjM3OC42NTkgNS4xMTggNi42NzkgMTMuMTc2IDEwLjk4NiAyMi4yNCAxMC45ODYgOS4wNjggMCAxNy4xMjktNC4zMSAyMi4yNDYtMTAuOTk1WiIvPjxwYXRoIGZpbGw9InVybCgjaSkiIGZpbGwtb3BhY2l0eT0iLjIiIGQ9Ik02Mi4yNiA0MC4wNTFDNjMuODA1IDQxLjk0NyA2NyA0MS40NDUgNjcgMzljMC0xNS40NjQtMTIuNTM2LTI4LTI4LTI4UzExIDIzLjUzNiAxMSAzOWMwIDIuNDQ1IDMuMTk1IDIuOTQ2IDQuNzQgMS4wNTFDMjEuMjQxIDMzLjMwNyAyOS42MTggMjkgMzkgMjljOS4zODIgMCAxNy43NTggNC4zMDcgMjMuMjYgMTEuMDUxWiIvPjxwYXRoIGZpbGw9InVybCgjaikiIGQ9Ik0zOSA0NWE2IDYgMCAxIDEgMC0xMS45OTkgNiA2IDAgMCAxIDAgMTJaIi8+PHBhdGggc3Ryb2tlPSIjZmZmIiBzdHJva2Utb3BhY2l0eT0iLjI0IiBzdHJva2Utd2lkdGg9Ii4xMjUiIGQ9Ik0zNi43MjggNDQuNDg2YTUuOTM4IDUuOTM4IDAgMSAwIDQuNTQ1LTEwLjk3MSA1LjkzOCA1LjkzOCAwIDAgMC00LjU0NSAxMC45NzFaIi8+PGcgZmlsdGVyPSJ1cmwoI2spIj48cGF0aCBmaWxsPSIjMUExQjFGIiBkPSJNMzkgNDZhNiA2IDAgMSAxIDAtMTEuOTk5IDYgNiAwIDAgMSAwIDEyWiIvPjwvZz48cGF0aCBmaWxsPSJ1cmwoI2wpIiBkPSJNMzkgNDQuNWE1LjUgNS41IDAgMSAxIDAtMTEgNS41IDUuNSAwIDAgMSAwIDExWiIvPjxwYXRoIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLW9wYWNpdHk9Ii4yNCIgc3Ryb2tlLXdpZHRoPSIuMjUiIGQ9Ik0zNi45NDQgNDMuOTY2YTUuMzc2IDUuMzc2IDAgMSAwIDQuMTE0LTkuOTM0IDUuMzc2IDUuMzc2IDAgMCAwLTQuMTE0IDkuOTM0WiIvPjxwYXRoIGZpbGw9InVybCgjbSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTM2LjcwNCA0NC41NDRhNi4wMDIgNi4wMDIgMCAwIDAgOC4yOTctNS41NDMgNiA2IDAgMSAwLTguMjk3IDUuNTQzWm0uMTkxLS40NjNhNS41IDUuNSAwIDEgMCA0LjIxLTEwLjE2MyA1LjUgNS41IDAgMCAwLTQuMjEgMTAuMTYzWiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0idXJsKCNuKSIgZmlsbC1vcGFjaXR5PSIuMDYiIGQ9Ik0zNi44OTcgNDIuMTJBNS45OCA1Ljk4IDAgMCAwIDM5IDQyLjVjMS40NiAwIDIuODU4LS41MjYgMy44OS0xLjQ2NC4yNTYtLjIzMy43MDEtLjAyMi41NC4yODVhNSA1IDAgMCAxLTkuMDQ5LS40MDZjLS4wOTgtLjIzOC4yMzctLjM4My40MTEtLjE5NWE1LjU2NSA1LjU2NSAwIDAgMCAyLjEwMyAxLjRaIi8+PGcgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGZpbGw9InVybCgjbykiIGQ9Ik0zOSA3MWMxNy42NzMgMCAzMi0xNC4zMjcgMzItMzJDNzEgMjEuMzI3IDU2LjY3MyA3IDM5IDcgMjEuMzI3IDcgNyAyMS4zMjcgNyAzOWMwIDE3LjY3MyAxNC4zMjcgMzIgMzIgMzJabTAtMmMxNi41NjkgMCAzMC0xMy40MzEgMzAtMzBDNjkgMjIuNDMxIDU1LjU2OSA5IDM5IDkgMjIuNDMxIDkgOSAyMi40MzEgOSAzOWMwIDE2LjU2OSAxMy40MzEgMzAgMzAgMzBaIi8+PHBhdGggZmlsbD0idXJsKCNwKSIgZD0iTTM5IDcxYzE3LjY3MyAwIDMyLTE0LjMyNyAzMi0zMkM3MSAyMS4zMjcgNTYuNjczIDcgMzkgNyAyMS4zMjcgNyA3IDIxLjMyNyA3IDM5YzAgMTcuNjczIDE0LjMyNyAzMiAzMiAzMlptMC0yYzE2LjU2OSAwIDMwLTEzLjQzMSAzMC0zMEM2OSAyMi40MzEgNTUuNTY5IDkgMzkgOSAyMi40MzEgOSA5IDIyLjQzMSA5IDM5YzAgMTYuNTY5IDEzLjQzMSAzMCAzMCAzMFoiLz48L2c+PHBhdGggZmlsbD0idXJsKCNxKSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMzkgNzZjMjAuNDM0IDAgMzctMTYuNTY2IDM3LTM3UzU5LjQzNCAyIDM5IDIgMiAxOC41NjYgMiAzOXMxNi41NjYgMzcgMzcgMzdabTAtMWMxOS44ODIgMCAzNi0xNi4xMTggMzYtMzZTNTguODgyIDMgMzkgMyAzIDE5LjExOCAzIDM5czE2LjExOCAzNiAzNiAzNloiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxjaXJjbGUgY3g9IjM5IiBjeT0iMzkiIHI9IjMyIiBzdHJva2U9IiNmZmYiIHN0cm9rZS1vcGFjaXR5PSIuMyIgc3Ryb2tlLXdpZHRoPSIuMjUiLz48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImEiIHgxPSIzOSIgeDI9IjM5IiB5MT0iMiIgeTI9Ijc2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzE3NDI5OSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwMUU1OSIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iMzkiIHgyPSIzOSIgeTE9IjIiIHkyPSI3NiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNEMkQ4RTQiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNDMkM5RDYiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZyIgeDE9IjM0IiB4Mj0iNDYuNSIgeTE9IjQ1LjUiIHkyPSIzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNmZmYiIHN0b3Atb3BhY2l0eT0iMCIvPjxzdG9wIG9mZnNldD0iLjQ1MyIgc3RvcC1jb2xvcj0iI2ZmZiIgc3RvcC1vcGFjaXR5PSIuNjQiLz48c3RvcCBvZmZzZXQ9Ii40NTMiIHN0b3AtY29sb3I9IiMzQjNCM0IiIHN0b3Atb3BhY2l0eT0iLjIzMyIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImkiIHgxPSIzOSIgeDI9IjM5IiB5MT0iMTEiIHkyPSI0MS4yMDUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iaiIgeDE9IjM5LjAwMSIgeDI9IjM4Ljc1MSIgeTE9IjMzIiB5Mj0iNDUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRENFMUVBIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjQkVDNkQ1Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImwiIHgxPSIzOS4wMDEiIHgyPSIzOC43NzIiIHkxPSIzMy41IiB5Mj0iNDQuNSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNEQ0UxRUEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNCRUM2RDUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibSIgeDE9IjM5IiB4Mj0iMzkiIHkxPSIzMyIgeTI9IjQ1LjAwMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNGMkY0RjciLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNBM0FEQzIiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibyIgeDE9IjM5IiB4Mj0iMzkiIHkxPSI3IiB5Mj0iNzEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRDJEOEU0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjQzJDOUQ2Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9InAiIHgxPSIzOSIgeDI9IjM5IiB5MT0iNyIgeTI9IjcxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzlGQUNDNiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0UwRTNFQiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJxIiB4MT0iMzkiIHgyPSIzOSIgeTE9IjIiIHkyPSI3NiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNGMkY0RjciLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNBM0FEQzIiLz48L2xpbmVhckdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFRyYW5zZm9ybT0icm90YXRlKC00MC4wNzcgMTA4LjU1NiA2NS40MTYpIHNjYWxlKDExOC40MzUpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMjc2IiBzdG9wLWNvbG9yPSIjMjBGRjREIi8+PHN0b3Agb2Zmc2V0PSIuNDY0IiBzdG9wLWNvbG9yPSIjMTQ5OUZGIi8+PHN0b3Agb2Zmc2V0PSIuNzU1IiBzdG9wLWNvbG9yPSIjRkY2RkM2Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjQkM2N0ZGIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSg0NSAuMjY1IC0uNjQpIHNjYWxlKDk4LjExMTEpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0icmVkIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDBBM0ZGIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImgiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgwIC0yOS4zODg3IDU3LjQ4MzggMCAzOC45OTkgNjcpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3AvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9Im4iIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtLjAwMTM1IC01Ljc1MDM4IDguNDI1NTcgLS4wMDE5OSAzOS4wMDIgNDQpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3AvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48ZmlsdGVyIGlkPSJlIiB3aWR0aD0iNjgiIGhlaWdodD0iNjgiIHg9IjUiIHk9IjUiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PSIwIiByZXN1bHQ9IkJhY2tncm91bmRJbWFnZUZpeCIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJzaGFwZSIvPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMjEzOF80Nzg5NSIgc3RkRGV2aWF0aW9uPSIyIi8+PC9maWx0ZXI+PGZpbHRlciBpZD0iZiIgd2lkdGg9IjM4IiBoZWlnaHQ9IjM4IiB4PSIyMCIgeT0iMjEiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PSIwIiByZXN1bHQ9IkJhY2tncm91bmRJbWFnZUZpeCIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJzaGFwZSIvPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImVmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMjEzOF80Nzg5NSIgc3RkRGV2aWF0aW9uPSIxIi8+PC9maWx0ZXI+PGZpbHRlciBpZD0iayIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiB4PSIzMS4wMDEiIHk9IjMyIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0ic2hhcGUiLz48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzIxMzhfNDc4OTUiIHN0ZERldmlhdGlvbj0iMSIvPjwvZmlsdGVyPjwvZGVmcz48L3N2Zz4=";
const $$24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Browser_default
}, Symbol.toStringTag, { value: "Module" }));
var Firefox_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA3OCA3OCI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNNzIuMDQ5IDI2LjgyN2MtMS41NTktMy43NS00LjcyLTcuNzk4LTcuMTk1LTkuMDc4YTM3LjI2NCAzNy4yNjQgMCAwIDEgMy42MzIgMTAuODgzbC4wMDcuMDZjLTQuMDU1LTEwLjEwNS0xMC45MjktMTQuMTg2LTE2LjU0Ni0yMy4wNmE0My4zOSA0My4zOSAwIDAgMS0uODQ1LTEuMzczIDExLjMzNyAxMS4zMzcgMCAwIDEtLjM5NS0uNzQgNi41MjUgNi41MjUgMCAwIDEtLjUzNS0xLjQyLjA5Mi4wOTIgMCAwIDAtLjA4LS4wOTMuMTI4LjEyOCAwIDAgMC0uMDY5IDBjLS4wMDQgMC0uMDEyLjAwOC0uMDE3LjAxLS4wMDYuMDAyLS4wMTguMDEtLjAyNi4wMTRsLjAxNC0uMDI0QzQwLjk4NiA3LjI4IDM3LjkyNyAxNy4wNDIgMzcuNjUgMjEuOTI4YTE3Ljk0NCAxNy45NDQgMCAwIDAtOS44NzQgMy44MDRjLS4yOTUtLjI1LS42MDQtLjQ4NC0uOTI1LS43MDFhMTYuNjI5IDE2LjYyOSAwIDAgMS0uMS04Ljc2NiAyNi41NTggMjYuNTU4IDAgMCAwLTguNjM0IDYuNjcyaC0uMDE2Yy0xLjQyMS0xLjgwMi0xLjMyMi03Ljc0My0xLjI0LTguOTgzYTYuNDQgNi40NCAwIDAgMC0xLjE5Ny42MzUgMjYuMTE5IDI2LjExOSAwIDAgMC0zLjUwNiAzLjAwMyAzMS4zMTIgMzEuMzEyIDAgMCAwLTMuMzUyIDQuMDIzdi4wMDUtLjAwNmEzMC4yODcgMzAuMjg3IDAgMCAwLTQuODEyIDEwLjg2M2wtLjA0OC4yMzdhNTcuMDU4IDU3LjA1OCAwIDAgMC0uMzUzIDIuMjRjMCAuMDI2LS4wMDUuMDUxLS4wMDguMDc4YTM0LjE4MyAzNC4xODMgMCAwIDAtLjU4MiA0Ljk0NHYuMTg1YTM1Ljg2NyAzNS44NjcgMCAwIDAgNzEuMjA1IDYuMDY1Yy4wNi0uNDYzLjExLS45Mi4xNjMtMS4zODhhMzYuODgzIDM2Ljg4MyAwIDAgMC0yLjMyNi0xOC4wMTdsLjAwNC4wMDZaTTMwLjcxMyA1NC45MDJjLjE2OC4wOC4zMjUuMTY3LjQ5Ny4yNDRsLjAyNS4wMTZjLS4xNzQtLjA4My0uMzQ4LS4xNy0uNTIyLS4yNlptMzcuNzgtMjYuMnYtLjAzNGwuMDA3LjAzOC0uMDA3LS4wMDRaIi8+PHBhdGggZmlsbD0idXJsKCNjKSIgZD0iTTcyLjA1IDI2LjgyOGMtMS41NTgtMy43NS00LjcyLTcuNzk4LTcuMTk1LTkuMDc4YTM3LjI2MSAzNy4yNjEgMCAwIDEgMy42MzIgMTAuODgydi4wMzRsLjAwNy4wMzhhMzIuNDggMzIuNDggMCAwIDEtMS4xMTYgMjQuMjA3Yy00LjExIDguODItMTQuMDU2IDE3Ljg2LTI5LjYzIDE3LjQxNUMyMC45MjYgNjkuODUgNi4xMDEgNTcuMzYyIDMuMzM1IDQxLjAxMWMtLjUwNS0yLjU3OSAwLTMuODg2LjI1My01Ljk4MmEyNi43MjMgMjYuNzIzIDAgMCAwLS41NzYgNC45NDl2LjE4NWEzNS44NjcgMzUuODY3IDAgMCAwIDcxLjIwNSA2LjA2NWMuMDYtLjQ2My4xMS0uOTIxLjE2My0xLjM4OWEzNi44ODQgMzYuODg0IDAgMCAwLTIuMzI2LTE4LjAxNmwtLjAwNC4wMDVaIi8+PHBhdGggZmlsbD0idXJsKCNkKSIgZD0iTTcyLjA1IDI2LjgyOGMtMS41NTgtMy43NS00LjcyLTcuNzk4LTcuMTk1LTkuMDc4YTM3LjI2MSAzNy4yNjEgMCAwIDEgMy42MzIgMTAuODgydi4wMzRsLjAwNy4wMzhhMzIuNDggMzIuNDggMCAwIDEtMS4xMTYgMjQuMjA3Yy00LjExIDguODItMTQuMDU2IDE3Ljg2LTI5LjYzIDE3LjQxNUMyMC45MjYgNjkuODUgNi4xMDEgNTcuMzYyIDMuMzM1IDQxLjAxMWMtLjUwNS0yLjU3OSAwLTMuODg2LjI1My01Ljk4MmEyNi43MjMgMjYuNzIzIDAgMCAwLS41NzYgNC45NDl2LjE4NWEzNS44NjcgMzUuODY3IDAgMCAwIDcxLjIwNSA2LjA2NWMuMDYtLjQ2My4xMS0uOTIxLjE2My0xLjM4OWEzNi44ODQgMzYuODg0IDAgMCAwLTIuMzI2LTE4LjAxNmwtLjAwNC4wMDVaIi8+PHBhdGggZmlsbD0idXJsKCNlKSIgZD0iTTU0LjYxNSAzMS4wMzdjLjA3OC4wNTUuMTUuMTEuMjIzLjE2NGExOS41MjUgMTkuNTI1IDAgMCAwLTMuMzMtNC4zNDRjLTExLjE1MS0xMS4xNS0yLjkyMi0yNC4xNy0xLjUzNS0yNC44MzdsLjAxNC0uMDJDNDAuOTc4IDcuMjc0IDM3LjkyIDE3LjAzNyAzNy42NDMgMjEuOTIzYy40MTgtLjAyOS44MzItLjA2NCAxLjI2LS4wNjRhMTguMSAxOC4xIDAgMCAxIDE1LjcxMiA5LjE3NnYuMDAyWiIvPjxwYXRoIGZpbGw9InVybCgjZikiIGQ9Ik0zOC45MjMgMzMuMjY4Yy0uMDYuODkyLTMuMjExIDMuOTY5LTQuMzEzIDMuOTY5LTEwLjE5OCAwLTExLjg1NCA2LjE2OS0xMS44NTQgNi4xNjkuNDUxIDUuMTk1IDQuMDcxIDkuNDc2IDguNDQ3IDExLjczMy4yLjEwNC40MDMuMTk3LjYwNS4yOS4zNTIuMTU0LjcwMy4yOTggMS4wNTQuNDNhMTUuOTEgMTUuOTEgMCAwIDAgNC42NjYuOWMxNy44NzguODM5IDIxLjMzOS0yMS4zNzUgOC40MzgtMjcuODI1YTEyLjM4MSAxMi4zODEgMCAwIDEgOC42NDggMi4xQTE4LjEgMTguMSAwIDAgMCAzOC45IDIxLjg1N2MtLjQyNSAwLS44NDIuMDM2LTEuMjYuMDY0YTE3Ljk0MyAxNy45NDMgMCAwIDAtOS44NzMgMy44MDRjLjU0Ni40NjMgMS4xNjQgMS4wODEgMi40NjQgMi4zNjMgMi40MzMgMi4zOTcgOC42NzUgNC44ODEgOC42ODkgNS4xNzJsLjAwMi4wMDhaIi8+PHBhdGggZmlsbD0idXJsKCNnKSIgZD0iTTM4LjkyMyAzMy4yNjhjLS4wNi44OTItMy4yMTEgMy45NjktNC4zMTMgMy45NjktMTAuMTk4IDAtMTEuODU0IDYuMTY5LTExLjg1NCA2LjE2OS40NTEgNS4xOTUgNC4wNzEgOS40NzYgOC40NDcgMTEuNzMzLjIuMTA0LjQwMy4xOTcuNjA1LjI5LjM1Mi4xNTQuNzAzLjI5OCAxLjA1NC40M2ExNS45MSAxNS45MSAwIDAgMCA0LjY2Ni45YzE3Ljg3OC44MzkgMjEuMzM5LTIxLjM3NSA4LjQzOC0yNy44MjVhMTIuMzgxIDEyLjM4MSAwIDAgMSA4LjY0OCAyLjFBMTguMSAxOC4xIDAgMCAwIDM4LjkgMjEuODU3Yy0uNDI1IDAtLjg0Mi4wMzYtMS4yNi4wNjRhMTcuOTQzIDE3Ljk0MyAwIDAgMC05Ljg3MyAzLjgwNGMuNTQ2LjQ2MyAxLjE2NCAxLjA4MSAyLjQ2NCAyLjM2MyAyLjQzMyAyLjM5NyA4LjY3NSA0Ljg4MSA4LjY4OSA1LjE3MmwuMDAyLjAwOFoiLz48cGF0aCBmaWxsPSJ1cmwoI2gpIiBkPSJNMjYuMDk3IDI0LjU0MmMuMjkuMTg1LjUzLjM0Ni43NC40OTFhMTYuNjI4IDE2LjYyOCAwIDAgMS0uMS04Ljc2NSAyNi41NTcgMjYuNTU3IDAgMCAwLTguNjMzIDYuNjcxYy4xNzQtLjAwNCA1LjM3Ny0uMDk4IDcuOTkzIDEuNjAzWiIvPjxwYXRoIGZpbGw9InVybCgjaSkiIGQ9Ik0zLjMyNyA0MS4wMTNjMi43NjggMTYuMzUgMTcuNTkgMjguODQzIDM0LjQxNCAyOS4zMTUgMTUuNTczLjQ0IDI1LjUyLTguNiAyOS42My0xNy40MTVhMzIuNDggMzIuNDggMCAwIDAgMS4xMTUtMjQuMjA3di0uMDM0YzAtLjAyNy0uMDA1LS4wNDMgMC0uMDM1bC4wMDcuMDZjMS4yNzIgOC4zMDctMi45NTMgMTYuMzUxLTkuNTYgMjEuODAybC0uMDIuMDQ2Yy0xMi44NzEgMTAuNDg0LTI1LjE4OCA2LjMyNC0yNy42NzcgNC42MjctLjE3NC0uMDg0LS4zNDgtLjE3LS41MjItLjI2LTcuNTAzLTMuNTg3LTEwLjYwNC0xMC40Mi05LjkzOC0xNi4yODZhOS4yMSA5LjIxIDAgMCAxLTguNDk1LTUuMzQ0IDEzLjUyOCAxMy41MjggMCAwIDEgMTMuMTg2LS41MyAxNy44NiAxNy44NiAwIDAgMCAxMy40NjQuNTNjLS4wMTQtLjI5Mi02LjI1Ni0yLjc3Ni04LjY5LTUuMTczLTEuMy0xLjI4Mi0xLjkxNy0xLjg5OS0yLjQ2NC0yLjM2My0uMjk1LS4yNS0uNjA0LS40ODQtLjkyNS0uNy0uMjEzLS4xNDYtLjQ1My0uMzAzLS43NC0uNDkyLTIuNjE2LTEuNzAxLTcuODE4LTEuNjA4LTcuOTktMS42MDNoLS4wMTdjLTEuNDIyLTEuODAyLTEuMzIyLTcuNzQyLTEuMjQtOC45ODMtLjQyLjE2OS0uODIyLjM4Mi0xLjE5OC42MzZhMjYuMTA1IDI2LjEwNSAwIDAgMC0zLjUwNSAzLjAwMiAzMS4zMTUgMzEuMzE1IDAgMCAwLTMuMzY2IDQuMDEzdi4wMDYtLjAwNmEzMC4yODcgMzAuMjg3IDAgMCAwLTQuODEyIDEwLjg2M2MtLjAxOC4wNzMtMS4yOTIgNS42NDQtLjY2NCA4LjUzM2wuMDA3LS4wMDJaIi8+PHBhdGggZmlsbD0idXJsKCNqKSIgZD0iTTUxLjUwNyAyNi44NTVhMTkuNTI3IDE5LjUyNyAwIDAgMSAzLjMzIDQuMzQ5Yy4xOTguMTQ5LjM4Mi4yOTcuNTM4LjQ0IDguMTMyIDcuNDk2IDMuODcxIDE4LjA5IDMuNTU0IDE4Ljg0IDYuNjA1LTUuNDQyIDEwLjgyNi0xMy40OTEgOS41NTktMjEuOEM2NC40MyAxOC41NjggNTcuNTUgMTQuNDg3IDUxLjk0MiA1LjYxM2E0My40MDEgNDMuNDAxIDAgMCAxLS44NDQtMS4zNzMgMTEuMjkgMTEuMjkgMCAwIDEtLjM5Ni0uNzQgNi41MjUgNi41MjUgMCAwIDEtLjUzNC0xLjQyLjA5My4wOTMgMCAwIDAtLjA4Mi0uMDkzLjEyNy4xMjcgMCAwIDAtLjA2NyAwYy0uMDA1IDAtLjAxMi4wMDgtLjAxOC4wMWwtLjAyNi4wMTRjLTEuMzg3LjY1OC05LjYxNCAxMy42ODYgMS41MzYgMjQuODI3bC0uMDA0LjAxNloiLz48cGF0aCBmaWxsPSJ1cmwoI2spIiBkPSJNNTUuMzc1IDMxLjY1YTcuNDk1IDcuNDk1IDAgMCAwLS41MzgtLjQ0MWMtLjA3My0uMDU1LS4xNDUtLjExLS4yMjMtLjE2NGExMi4zODIgMTIuMzgyIDAgMCAwLTguNjQ3LTIuMWMxMi45IDYuNDUgOS40MzkgMjguNjU4LTguNDM4IDI3LjgyNWExNS45NSAxNS45NSAwIDAgMS00LjY2Ny0uOSAxOC44ODUgMTguODg1IDAgMCAxLTEuMDUzLS40MzEgMTMuMjQ4IDEzLjI0OCAwIDAgMS0uNjA1LS4yODlsLjAyNS4wMTZjMi40OTMgMS43MDIgMTQuODA2IDUuODYgMjcuNjc3LTQuNjI3bC4wMi0uMDQ2Yy4zMjItLjc1IDQuNTgyLTExLjM0NS0zLjU1My0xOC44NGwuMDAyLS4wMDRaIi8+PHBhdGggZmlsbD0idXJsKCNsKSIgZD0iTTIyLjc1NiA0My40czEuNjU1LTYuMTcgMTEuODUzLTYuMTdjMS4xMDIgMCA0LjI1Ny0zLjA3NiA0LjMxMy0zLjk2OGExNy44NiAxNy44NiAwIDAgMS0xMy40NjMtLjUzIDEzLjUyOSAxMy41MjkgMCAwIDAtMTMuMTg2LjUzIDkuMjEgOS4yMSAwIDAgMCA4LjQ5NSA1LjM0NGMtLjY2NCA1Ljg2NCAyLjQzNiAxMi42OTYgOS45MzggMTYuMjg2LjE2OC4wOC4zMjUuMTY3LjQ5Ny4yNDQtNC4zOC0yLjI2Mi03Ljk5Ni02LjU0MS04LjQ0Ny0xMS43MzNWNDMuNFoiLz48cGF0aCBmaWxsPSJ1cmwoI20pIiBkPSJNNzIuMDQ5IDI2LjgyN2MtMS41NTktMy43NS00LjcyLTcuNzk4LTcuMTk1LTkuMDc4YTM3LjI2MSAzNy4yNjEgMCAwIDEgMy42MzIgMTAuODgzbC4wMDcuMDZjLTQuMDU1LTEwLjEwNS0xMC45MjktMTQuMTg2LTE2LjU0Ni0yMy4wNmE0My4zOSA0My4zOSAwIDAgMS0uODQ0LTEuMzczIDExLjMzNyAxMS4zMzcgMCAwIDEtLjM5Ni0uNzQgNi41MjUgNi41MjUgMCAwIDEtLjUzNC0xLjQyLjA5Mi4wOTIgMCAwIDAtLjA4Mi0uMDkzLjEyOC4xMjggMCAwIDAtLjA2NyAwYy0uMDA1IDAtLjAxMi4wMDgtLjAxOC4wMWwtLjAyNi4wMTQuMDE0LS4wMjRDNDAuOTg2IDcuMjggMzcuOTI4IDE3LjA0MiAzNy42NSAyMS45MjhjLjQxOC0uMDI4LjgzMy0uMDY0IDEuMjYtLjA2NGExOC4xIDE4LjEgMCAwIDEgMTUuNzEzIDkuMTc3IDEyLjM4IDEyLjM4IDAgMCAwLTguNjQ4LTIuMWMxMi45IDYuNDUgOS40MzkgMjguNjU4LTguNDM4IDI3LjgyNmExNS45NTIgMTUuOTUyIDAgMCAxLTQuNjY2LS45IDE4LjkzMyAxOC45MzMgMCAwIDEtMS4wNTQtLjQzMmMtLjIwMi0uMDkzLS40MDUtLjE4NS0uNjA1LS4yODlsLjAyNS4wMTZhMTkuMDQgMTkuMDQgMCAwIDEtLjUyMi0uMjZjLjE2OC4wOC4zMjUuMTY3LjQ5Ny4yNDQtNC4zOC0yLjI2My03Ljk5Ni02LjU0Mi04LjQ0Ny0xMS43MzMgMCAwIDEuNjU1LTYuMTcgMTEuODUzLTYuMTcgMS4xMDIgMCA0LjI1Ny0zLjA3NiA0LjMxMy0zLjk2OC0uMDEzLS4yOTItNi4yNTUtMi43NzYtOC42ODgtNS4xNzMtMS4zLTEuMjgxLTEuOTE4LTEuODk5LTIuNDY1LTIuMzYyLS4yOTUtLjI1LS42MDQtLjQ4NS0uOTI1LS43MDJhMTYuNjI4IDE2LjYyOCAwIDAgMS0uMS04Ljc2NSAyNi41NTcgMjYuNTU3IDAgMCAwLTguNjM0IDYuNjcxaC0uMDE2Yy0xLjQyMi0xLjgwMS0xLjMyMi03Ljc0Mi0xLjI0LTguOTgzLS40Mi4xNjktLjgyMi4zODItMS4xOTcuNjM2YTI2LjExMiAyNi4xMTIgMCAwIDAtMy41MDYgMy4wMDIgMzEuMzA0IDMxLjMwNCAwIDAgMC0zLjM1MiA0LjAyM3YuMDA2LS4wMDdhMzAuMjg3IDMwLjI4NyAwIDAgMC00LjgxMiAxMC44NjRsLS4wNDguMjM2Yy0uMDY4LjMxNi0uMzcgMS45MTktLjQxNCAyLjI2M2E0MS43MjQgNDEuNzI0IDAgMCAwLS41MyA1di4xODVhMzUuODY2IDM1Ljg2NiAwIDAgMCA3MS4yMDYgNi4wNjRjLjA2LS40NjIuMTEtLjkyLjE2My0xLjM4OGEzNi44ODUgMzYuODg1IDAgMCAwLTIuMzI2LTE4LjAxNmwuMDAyLS4wMDJabS0zLjU1OCAxLjg0Mi4wMDYuMDM4LS4wMDYtLjAzOFoiLz48L2c+PGRlZnM+PHJhZGlhbEdyYWRpZW50IGlkPSJjIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjQuOTk5IDEwLjMyOSkgc2NhbGUoNzQuNzY4KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjEyOSIgc3RvcC1jb2xvcj0iI0ZGQkQ0RiIvPjxzdG9wIG9mZnNldD0iLjE4NiIgc3RvcC1jb2xvcj0iI0ZGQUMzMSIvPjxzdG9wIG9mZnNldD0iLjI0NyIgc3RvcC1jb2xvcj0iI0ZGOUQxNyIvPjxzdG9wIG9mZnNldD0iLjI4MyIgc3RvcC1jb2xvcj0iI0ZGOTgwRSIvPjxzdG9wIG9mZnNldD0iLjQwMyIgc3RvcC1jb2xvcj0iI0ZGNTYzQiIvPjxzdG9wIG9mZnNldD0iLjQ2NyIgc3RvcC1jb2xvcj0iI0ZGMzc1MCIvPjxzdG9wIG9mZnNldD0iLjcxIiBzdG9wLWNvbG9yPSIjRjUxNTZDIi8+PHN0b3Agb2Zmc2V0PSIuNzgyIiBzdG9wLWNvbG9yPSIjRUIwODc4Ii8+PHN0b3Agb2Zmc2V0PSIuODYiIHN0b3AtY29sb3I9IiNFNTAwODAiLz48L3JhZGlhbEdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0iZCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDM3LjIzOSA0MC44NjUpIHNjYWxlKDc0Ljc2OCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9Ii4zIiBzdG9wLWNvbG9yPSIjOTYwRTE4Ii8+PHN0b3Agb2Zmc2V0PSIuMzUxIiBzdG9wLWNvbG9yPSIjQjExOTI3IiBzdG9wLW9wYWNpdHk9Ii43NCIvPjxzdG9wIG9mZnNldD0iLjQzNSIgc3RvcC1jb2xvcj0iI0RCMjkzRCIgc3RvcC1vcGFjaXR5PSIuMzQzIi8+PHN0b3Agb2Zmc2V0PSIuNDk3IiBzdG9wLWNvbG9yPSIjRjUzMzRCIiBzdG9wLW9wYWNpdHk9Ii4wOTQiLz48c3RvcCBvZmZzZXQ9Ii41MyIgc3RvcC1jb2xvcj0iI0ZGMzc1MCIgc3RvcC1vcGFjaXR5PSIwIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImUiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSg0Ni40OSAtNi4zMjgpIHNjYWxlKDU0LjE2MDYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMTMyIiBzdG9wLWNvbG9yPSIjRkZGNDRGIi8+PHN0b3Agb2Zmc2V0PSIuMjUyIiBzdG9wLWNvbG9yPSIjRkZEQzNFIi8+PHN0b3Agb2Zmc2V0PSIuNTA2IiBzdG9wLWNvbG9yPSIjRkY5RDEyIi8+PHN0b3Agb2Zmc2V0PSIuNTI2IiBzdG9wLWNvbG9yPSIjRkY5ODBFIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImYiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyOC45MSA2MC4yOTcpIHNjYWxlKDM1LjU5ODEpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMzUzIiBzdG9wLWNvbG9yPSIjM0E4RUU2Ii8+PHN0b3Agb2Zmc2V0PSIuNDcyIiBzdG9wLWNvbG9yPSIjNUM3OUYwIi8+PHN0b3Agb2Zmc2V0PSIuNjY5IiBzdG9wLWNvbG9yPSIjOTA1OUZGIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjQzEzOUU2Ii8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImciIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxOC4zNDg1MiAtNC40MzYyNiA1LjE5Mzc0IDIxLjQ4MTQ1IDQwLjg1NiAzNC40NDgpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMjA2IiBzdG9wLWNvbG9yPSIjOTA1OUZGIiBzdG9wLW9wYWNpdHk9IjAiLz48c3RvcCBvZmZzZXQ9Ii4yNzgiIHN0b3AtY29sb3I9IiM4QzRGRjMiIHN0b3Atb3BhY2l0eT0iLjA2NCIvPjxzdG9wIG9mZnNldD0iLjc0NyIgc3RvcC1jb2xvcj0iIzc3MTZBOCIgc3RvcC1vcGFjaXR5PSIuNDUiLz48c3RvcCBvZmZzZXQ9Ii45NzUiIHN0b3AtY29sb3I9IiM2RTAwOEIiIHN0b3Atb3BhY2l0eT0iLjYiLz48L3JhZGlhbEdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0iaCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDM2LjMxMyA3LjU1Mykgc2NhbGUoMjUuNjEzNikiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRkZFMjI2Ii8+PHN0b3Agb2Zmc2V0PSIuMTIxIiBzdG9wLWNvbG9yPSIjRkZEQjI3Ii8+PHN0b3Agb2Zmc2V0PSIuMjk1IiBzdG9wLWNvbG9yPSIjRkZDODJBIi8+PHN0b3Agb2Zmc2V0PSIuNTAyIiBzdG9wLWNvbG9yPSIjRkZBOTMwIi8+PHN0b3Agb2Zmc2V0PSIuNzMyIiBzdG9wLWNvbG9yPSIjRkY3RTM3Ii8+PHN0b3Agb2Zmc2V0PSIuNzkyIiBzdG9wLWNvbG9yPSIjRkY3MTM5Ii8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSg1Ni42NyAtOS4xMDQpIHNjYWxlKDEwOS4yODMpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMTEzIiBzdG9wLWNvbG9yPSIjRkZGNDRGIi8+PHN0b3Agb2Zmc2V0PSIuNDU2IiBzdG9wLWNvbG9yPSIjRkY5ODBFIi8+PHN0b3Agb2Zmc2V0PSIuNjIyIiBzdG9wLWNvbG9yPSIjRkY1NjM0Ii8+PHN0b3Agb2Zmc2V0PSIuNzE2IiBzdG9wLWNvbG9yPSIjRkYzNjQ3Ii8+PHN0b3Agb2Zmc2V0PSIuOTA0IiBzdG9wLWNvbG9yPSIjRTMxNTg3Ii8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImoiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSg4My45NzYgMjUuNDg1IDI0LjkxNCkgc2NhbGUoODAuMDg0NSA1Mi41NTg4KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNGRkY0NEYiLz48c3RvcCBvZmZzZXQ9Ii4wNiIgc3RvcC1jb2xvcj0iI0ZGRTg0NyIvPjxzdG9wIG9mZnNldD0iLjE2OCIgc3RvcC1jb2xvcj0iI0ZGQzgzMCIvPjxzdG9wIG9mZnNldD0iLjMwNCIgc3RvcC1jb2xvcj0iI0ZGOTgwRSIvPjxzdG9wIG9mZnNldD0iLjM1NiIgc3RvcC1jb2xvcj0iI0ZGOEIxNiIvPjxzdG9wIG9mZnNldD0iLjQ1NSIgc3RvcC1jb2xvcj0iI0ZGNjcyQSIvPjxzdG9wIG9mZnNldD0iLjU3IiBzdG9wLWNvbG9yPSIjRkYzNjQ3Ii8+PHN0b3Agb2Zmc2V0PSIuNzM3IiBzdG9wLWNvbG9yPSIjRTMxNTg3Ii8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImsiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgzNi4zMTMgMTYuODA3KSBzY2FsZSg2OC4yMTY2KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjEzNyIgc3RvcC1jb2xvcj0iI0ZGRjQ0RiIvPjxzdG9wIG9mZnNldD0iLjQ4IiBzdG9wLWNvbG9yPSIjRkY5ODBFIi8+PHN0b3Agb2Zmc2V0PSIuNTkyIiBzdG9wLWNvbG9yPSIjRkY1NjM0Ii8+PHN0b3Agb2Zmc2V0PSIuNjU1IiBzdG9wLWNvbG9yPSIjRkYzNjQ3Ii8+PHN0b3Agb2Zmc2V0PSIuOTA0IiBzdG9wLWNvbG9yPSIjRTMxNTg3Ii8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImwiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSg1My44OTQgMjAuNTA3KSBzY2FsZSg3NC42NjYyKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjA5NCIgc3RvcC1jb2xvcj0iI0ZGRjQ0RiIvPjxzdG9wIG9mZnNldD0iLjIzMSIgc3RvcC1jb2xvcj0iI0ZGRTE0MSIvPjxzdG9wIG9mZnNldD0iLjUwOSIgc3RvcC1jb2xvcj0iI0ZGQUYxRSIvPjxzdG9wIG9mZnNldD0iLjYyNiIgc3RvcC1jb2xvcj0iI0ZGOTgwRSIvPjwvcmFkaWFsR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iNjcuMzAyIiB4Mj0iNy43NjIiIHkxPSIxMy40NjEiIHkyPSI3MC45MDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9Ii4wNDgiIHN0b3AtY29sb3I9IiNGRkY0NEYiLz48c3RvcCBvZmZzZXQ9Ii4xMTEiIHN0b3AtY29sb3I9IiNGRkU4NDciLz48c3RvcCBvZmZzZXQ9Ii4yMjUiIHN0b3AtY29sb3I9IiNGRkM4MzAiLz48c3RvcCBvZmZzZXQ9Ii4zNjgiIHN0b3AtY29sb3I9IiNGRjk4MEUiLz48c3RvcCBvZmZzZXQ9Ii40MDEiIHN0b3AtY29sb3I9IiNGRjhCMTYiLz48c3RvcCBvZmZzZXQ9Ii40NjIiIHN0b3AtY29sb3I9IiNGRjY3MkEiLz48c3RvcCBvZmZzZXQ9Ii41MzQiIHN0b3AtY29sb3I9IiNGRjM2NDciLz48c3RvcCBvZmZzZXQ9Ii43MDUiIHN0b3AtY29sb3I9IiNFMzE1ODciLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0ibSIgeDE9IjY2LjU4IiB4Mj0iMTUuOTI2IiB5MT0iMTMuMTU2IiB5Mj0iNjMuODE5IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMTY3IiBzdG9wLWNvbG9yPSIjRkZGNDRGIiBzdG9wLW9wYWNpdHk9Ii44Ii8+PHN0b3Agb2Zmc2V0PSIuMjY2IiBzdG9wLWNvbG9yPSIjRkZGNDRGIiBzdG9wLW9wYWNpdHk9Ii42MzQiLz48c3RvcCBvZmZzZXQ9Ii40ODkiIHN0b3AtY29sb3I9IiNGRkY0NEYiIHN0b3Atb3BhY2l0eT0iLjIxNyIvPjxzdG9wIG9mZnNldD0iLjYiIHN0b3AtY29sb3I9IiNGRkY0NEYiIHN0b3Atb3BhY2l0eT0iMCIvPjwvbGluZWFyR3JhZGllbnQ+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDcxLjY0djc0SDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzIDIpIi8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+";
const $$23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Firefox_default
}, Symbol.toStringTag, { value: "Module" }));
var Edge_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA3OCA3OCI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNNjguODAyIDU3LjA2NmMtLjk5Mi41MTYtMi4wMTYuOTctMy4wNjQgMS4zNTlhMjkuNDU2IDI5LjQ1NiAwIDAgMS0xMC4zNzcgMS44NWMtMTMuNjczIDAtMjUuNTgyLTkuMzk1LTI1LjU4Mi0yMS40NzdhOS4xMDYgOS4xMDYgMCAwIDEgNC43NC03Ljg5MmMtMTIuMzcxLjUyLTE1LjU1MSAxMy40MTMtMTUuNTUxIDIwLjk1NyAwIDIxLjM5IDE5LjY4NSAyMy41MyAyMy45MzQgMjMuNTMgMi4yODQgMCA1LjcyNC0uNjY1IDcuODA1LTEuMzNsLjM3Ni0uMTE1YTM3LjA4OCAzNy4wODggMCAwIDAgMTkuMjUxLTE1LjI2MyAxLjE1NiAxLjE1NiAwIDAgMC0xLjUzMi0xLjYxOVoiLz48cGF0aCBmaWxsPSJ1cmwoI2MpIiBkPSJNNjguODAyIDU3LjA2NmMtLjk5Mi41MTYtMi4wMTYuOTctMy4wNjQgMS4zNTlhMjkuNDU2IDI5LjQ1NiAwIDAgMS0xMC4zNzcgMS44NWMtMTMuNjczIDAtMjUuNTgyLTkuMzk1LTI1LjU4Mi0yMS40NzdhOS4xMDYgOS4xMDYgMCAwIDEgNC43NC03Ljg5MmMtMTIuMzcxLjUyLTE1LjU1MSAxMy40MTMtMTUuNTUxIDIwLjk1NyAwIDIxLjM5IDE5LjY4NSAyMy41MyAyMy45MzQgMjMuNTMgMi4yODQgMCA1LjcyNC0uNjY1IDcuODA1LTEuMzNsLjM3Ni0uMTE1YTM3LjA4OCAzNy4wODggMCAwIDAgMTkuMjUxLTE1LjI2MyAxLjE1NiAxLjE1NiAwIDAgMC0xLjUzMi0xLjYxOVoiIG9wYWNpdHk9Ii4zNSIvPjxwYXRoIGZpbGw9InVybCgjZCkiIGQ9Ik0zMi41NTQgNzEuNzUxYTIyLjg5NCAyMi44OTQgMCAwIDEtNi41NjItNi4xNTcgMjMuMzI5IDIzLjMyOSAwIDAgMSA4LjUyNy0zNC42ODdjLjkyNS0uNDM0IDIuNDU4LTEuMTg2IDQuNTEtMS4xNTdhOS4zNjUgOS4zNjUgMCAwIDEgNy40MjkgMy43NTggOS4yMjIgOS4yMjIgMCAwIDEgMS44MiA1LjQwNmMwLS4wNTggNy4wODMtMjMuMDEtMjMuMTI0LTIzLjAxLTEyLjY5IDAtMjMuMTI1IDEyLjAyNS0yMy4xMjUgMjIuNjA1YTM3LjYzNiAzNy42MzYgMCAwIDAgMy40OTggMTYuMTg4IDM3IDM3IDAgMCAwIDQ1LjIwOSAxOS4zNjcgMjEuODI1IDIxLjgyNSAwIDAgMS0xOC4xNTMtMi4zMTNoLS4wM1oiLz48cGF0aCBmaWxsPSJ1cmwoI2UpIiBkPSJNMzIuNTU0IDcxLjc1MWEyMi44OTQgMjIuODk0IDAgMCAxLTYuNTYyLTYuMTU3IDIzLjMyOSAyMy4zMjkgMCAwIDEgOC41MjctMzQuNjg3Yy45MjUtLjQzNCAyLjQ1OC0xLjE4NiA0LjUxLTEuMTU3YTkuMzY1IDkuMzY1IDAgMCAxIDcuNDI5IDMuNzU4IDkuMjIyIDkuMjIyIDAgMCAxIDEuODIgNS40MDZjMC0uMDU4IDcuMDgzLTIzLjAxLTIzLjEyNC0yMy4wMS0xMi42OSAwLTIzLjEyNSAxMi4wMjUtMjMuMTI1IDIyLjYwNWEzNy42MzYgMzcuNjM2IDAgMCAwIDMuNDk4IDE2LjE4OCAzNyAzNyAwIDAgMCA0NS4yMDkgMTkuMzY3IDIxLjgyNSAyMS44MjUgMCAwIDEtMTguMTUzLTIuMzEzaC0uMDNaIiBvcGFjaXR5PSIuNDEiLz48cGF0aCBmaWxsPSJ1cmwoI2YpIiBkPSJNNDYuMDUzIDQ1LjAxM2MtLjI2LjI4OS0uOTgzLjcyMi0uOTgzIDEuNjE4IDAgLjc1Mi40OTIgMS41MDMgMS4zODggMi4xMSA0LjEzMyAyLjg5MSAxMS45NjcgMi40ODYgMTEuOTk2IDIuNDg2YTE3LjIyNyAxNy4yMjcgMCAwIDAgOC43NTktMi4zOTlBMTcuNzQ4IDE3Ljc0OCAwIDAgMCA3NiAzMy41MzdjLjA4Ny02LjQ3NS0yLjMxMy0xMC43ODItMy4yNjYtMTIuNjlDNjYuNTc3IDguODggNTMuMzY2IDIgMzkgMkEzNyAzNyAwIDAgMCAyIDM4LjQ4Yy4xNDUtMTAuNTUxIDEwLjYzNy0xOS4wNzggMjMuMTI1LTE5LjA3OCAxLjAxMiAwIDYuNzkzLjA4NiAxMi4xNCAyLjg5YTIwLjk4NiAyMC45ODYgMCAwIDEgOC45MzMgOC40N2MxLjc2MyAzLjA2NCAyLjA4IDYuOTY2IDIuMDggOC41MjcgMCAxLjU2MS0uNzggMy44NDUtMi4yNTQgNS43NTJsLjAzLS4wMjhaIi8+PHBhdGggZmlsbD0idXJsKCNnKSIgZD0iTTQ2LjA1MyA0NS4wMTNjLS4yNi4yODktLjk4My43MjItLjk4MyAxLjYxOCAwIC43NTIuNDkyIDEuNTAzIDEuMzg4IDIuMTEgNC4xMzMgMi44OTEgMTEuOTY3IDIuNDg2IDExLjk5NiAyLjQ4NmExNy4yMjcgMTcuMjI3IDAgMCAwIDguNzU5LTIuMzk5QTE3Ljc0OCAxNy43NDggMCAwIDAgNzYgMzMuNTM3Yy4wODctNi40NzUtMi4zMTMtMTAuNzgyLTMuMjY2LTEyLjY5QzY2LjU3NyA4Ljg4IDUzLjM2NiAyIDM5IDJBMzcgMzcgMCAwIDAgMiAzOC40OGMuMTQ1LTEwLjU1MSAxMC42MzctMTkuMDc4IDIzLjEyNS0xOS4wNzggMS4wMTIgMCA2Ljc5My4wODYgMTIuMTQgMi44OWEyMC45ODYgMjAuOTg2IDAgMCAxIDguOTMzIDguNDdjMS43NjMgMy4wNjQgMi4wOCA2Ljk2NiAyLjA4IDguNTI3IDAgMS41NjEtLjc4IDMuODQ1LTIuMjU0IDUuNzUybC4wMy0uMDI4WiIvPjwvZz48ZGVmcz48cmFkaWFsR3JhZGllbnQgaWQ9ImMiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyNy41NzY2IDAgMCAyNi4xOTc3IDQ3LjQ0IDUzLjU1MykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9Ii43IiBzdG9wLW9wYWNpdHk9IjAiLz48c3RvcCBvZmZzZXQ9Ii45IiBzdG9wLW9wYWNpdHk9Ii41Ii8+PHN0b3Agb2Zmc2V0PSIxIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImUiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg2LjIwOTAyIC00MC45Nzk4IDMzLjEwNzU0IDUuMDE2MjcgMjIuMzk1IDU5LjUwNikiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9Ii44IiBzdG9wLW9wYWNpdHk9IjAiLz48c3RvcCBvZmZzZXQ9Ii45IiBzdG9wLW9wYWNpdHk9Ii41Ii8+PHN0b3Agb2Zmc2V0PSIxIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImYiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgtMi4zNDAyNCA1OC41MDYyMSAtMTI0LjYwNjM2IC00Ljk4NDIzIDkuNDg0IDE1LjY3NykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjMzVDMUYxIi8+PHN0b3Agb2Zmc2V0PSIuMSIgc3RvcC1jb2xvcj0iIzM0QzFFRCIvPjxzdG9wIG9mZnNldD0iLjIiIHN0b3AtY29sb3I9IiMyRkMyREYiLz48c3RvcCBvZmZzZXQ9Ii4zIiBzdG9wLWNvbG9yPSIjMkJDM0QyIi8+PHN0b3Agb2Zmc2V0PSIuNyIgc3RvcC1jb2xvcj0iIzM2Qzc1MiIvPjwvcmFkaWFsR3JhZGllbnQ+PHJhZGlhbEdyYWRpZW50IGlkPSJnIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoNzMuNzQgMTkuNDY3IDU5Ljc2Nykgc2NhbGUoMjguMTI1OCAyMi44NzE5KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiM2NkVCNkUiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM2NkVCNkUiIHN0b3Atb3BhY2l0eT0iMCIvPjwvcmFkaWFsR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iMTguOTY4IiB4Mj0iNzAuNTM3IiB5MT0iNTMuMTY0IiB5Mj0iNTMuMTY0IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzBDNTlBNCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzExNEE4QiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJkIiB4MT0iNDYuMTQiIHgyPSIxMy45NjciIHkxPSIzMC43OTEiIHkyPSI2NS44NTQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjMUI5REUyIi8+PHN0b3Agb2Zmc2V0PSIuMiIgc3RvcC1jb2xvcj0iIzE1OTVERiIvPjxzdG9wIG9mZnNldD0iLjciIHN0b3AtY29sb3I9IiMwNjgwRDciLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDc4RDQiLz48L2xpbmVhckdyYWRpZW50PjxjbGlwUGF0aCBpZD0iYSI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTAgMGg3NHY3NEgweiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiAyKSIvPjwvY2xpcFBhdGg+PC9kZWZzPjwvc3ZnPg==";
const $$22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Edge_default
}, Symbol.toStringTag, { value: "Module" }));
var Brave_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA3OCA3OCI+PHBhdGggZmlsbD0idXJsKCNhKSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtNjcuODEgMTkuNTQgMS42OS00LjJzLTIuMTQtMi4zNS00Ljc1LTVjLTIuNi0yLjY1LTguMS0xLjA5LTguMS0xLjA5TDUwLjM3IDJIMjguMzRsLTYuMjggNy4yNXMtNS41LTEuNTYtOC4xIDEuMWMtMi42IDIuNjQtNC43NSA0Ljk4LTQuNzUgNC45OGwxLjY5IDQuMjEtMi4xNSA2LjI0czYuMyAyNC4zIDcuMDQgMjcuMjhjMS40NiA1Ljg0IDIuNDUgOC4xIDYuNTggMTEuMDZhNTEzLjY2IDUxMy42NiAwIDAgMCAxMi44NSA4Ljg5YzEuMjMuNzggMi43NiAyLjEgNC4xMyAyLjEgMS4zOCAwIDIuOTEtMS4zMiA0LjE0LTIuMSAxLjIyLS43OCA4LjcyLTUuOTIgMTIuODUtOC44OSA0LjEzLTIuOTYgNS4xMi01LjIyIDYuNTgtMTEuMDYuNzQtMi45NyA3LjA0LTI3LjI4IDcuMDQtMjcuMjhsLTIuMTUtNi4yNFoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiNmZmYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTM5LjM1IDQ3LjVjLjQyIDAgMy4xMS45NyA1LjI3IDIuMSAyLjE1IDEuMTQgMy43MiAxLjk1IDQuMjIgMi4yNi41LjMyLjIuOTItLjI2IDEuMjUtLjQ2LjMzLTYuNTcgNS4xNS03LjE3IDUuNjktLjYuNTMtMS40NiAxLjQxLTIuMDYgMS40MS0uNTkgMC0xLjQ2LS44OC0yLjA1LTEuNDEtLjYtLjU0LTYuNzEtNS4zNi03LjE3LTUuNjktLjQ1LS4zMy0uNzYtLjkzLS4yNi0xLjI1LjUtLjMxIDIuMDctMS4xMiA0LjIyLTIuMjUgMi4xNi0xLjE0IDQuODUtMi4xIDUuMjYtMi4xWm0uMDQtMzQuMzZjLjIuMDEgMS4zNi4wNyAzLjAyLjYzIDEuODQuNjMgMy44MyAxLjQgNC43NSAxLjQuOTIgMCA3LjczLTEuMzIgNy43My0xLjMyczguMDYgOS45NCA4LjA2IDEyLjA2YzAgMi4xMy0xLjAxIDIuNjktMi4wMyAzLjhsLTYuMDUgNi41NGMtLjU3LjYyLTEuNzcgMS41NS0xLjA2IDMuMjQuNyAxLjcgMS43MyAzLjg0LjU4IDYuMDMtMS4xNSAyLjE4LTMuMTIgMy42My00LjM4IDMuNC0xLjI2LS4yNS00LjIzLTEuODMtNS4zMi0yLjU1LTEuMDktLjcyLTQuNTQtMy42Mi00LjU0LTQuNzMgMC0xLjExIDMuNTctMy4xIDQuMjMtMy41Ni42Ni0uNDUgMy42Ny0yLjIgMy43My0yLjkuMDYtLjY5LjA0LS44OS0uODUtMi41OS0uODktMS43LTIuNDktMy45Ny0yLjIyLTUuNDguMjYtMS41MSAyLjg0LTIuMyA0LjY4LTMgMS44NC0uNzEgNS4zOS0yLjA1IDUuODMtMi4yNi40NC0uMi4zMy0uNC0xLjAxLS41M3MtNS4xNS0uNjUtNi44Ni0uMTZjLTEuNzIuNDktNC42NSAxLjIzLTQuODkgMS42Mi0uMjQuNC0uNDUuNC0uMiAxLjc2LjI0IDEuMzYgMS41IDcuODcgMS42MiA5LjAyLjEyIDEuMTYuMzYgMS45Mi0uODcgMi4yLTEuMjIuMy0zLjI4Ljc5LTMuOTkuNzktLjcgMC0yLjc2LS41LTMuOTktLjc4LTEuMjItLjI5LS45OC0xLjA1LS44Ni0yLjIuMTItMS4xNiAxLjM4LTcuNjcgMS42Mi05LjAzLjI1LTEuMzUuMDQtMS4zNy0uMi0xLjc2LS4yNC0uNC0zLjE3LTEuMTMtNC44OS0xLjYyLTEuNzEtLjQ5LTUuNTIuMDMtNi44Ni4xNi0xLjM0LjEzLTEuNDYuMzItMS4wMS41My40NC4yMSAzLjk4IDEuNTUgNS44MyAyLjI2IDEuODQuNyA0LjQyIDEuNDkgNC42OCAzIC4yNyAxLjUxLTEuMzMgMy43OC0yLjIyIDUuNDgtLjg5IDEuNy0uOTEgMS45LS44NSAyLjYuMDYuNjggMy4wNyAyLjQ0IDMuNzMgMi44OS42Ni40NSA0LjIzIDIuNDUgNC4yMyAzLjU2IDAgMS4xLTMuNDUgNC4wMS00LjU0IDQuNzMtMS4xLjcyLTQuMDYgMi4zLTUuMzIgMi41NC0xLjI2LjI0LTMuMjMtMS4yMS00LjM4LTMuNC0xLjE1LTIuMTgtLjEyLTQuMzMuNTgtNi4wMi43LTEuNjktLjQ5LTIuNjItMS4wNi0zLjI0TDE3LjggMjkuN2MtMS4wMi0xLjEtMi4wNC0xLjY2LTIuMDQtMy43OSAwLTIuMTIgOC4wNy0xMi4wNiA4LjA3LTEyLjA2czYuODEgMS4zMyA3LjczIDEuMzNjLjkyIDAgMi45LS43OCA0Ljc0LTEuNGExMS4zIDExLjMgMCAwIDEgMy4wMy0uNjRoLjA3WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PG1hc2sgaWQ9ImIiIHdpZHRoPSI1MiIgaGVpZ2h0PSIxNCIgeD0iMTMiIHk9IjIiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik01Ni42NCA5LjI1IDUwLjM3IDJIMjguMzRsLTYuMjggNy4yNXMtNS41LTEuNTYtOC4xIDEuMWMwIDAgNy4zNC0uNjggOS44NiAzLjUgMCAwIDYuODEgMS4zMyA3LjczIDEuMzMuOTIgMCAyLjktLjc4IDQuNzQtMS40IDEuODQtLjYzIDMuMDYtLjY0IDMuMDYtLjY0czEuMjMgMCAzLjA2LjYzYzEuODQuNjMgMy44MyAxLjQgNC43NSAxLjQuOTIgMCA3LjczLTEuMzIgNy43My0xLjMyIDIuNTItNC4xOCA5Ljg2LTMuNSA5Ljg2LTMuNS0yLjYtMi42Ni04LjEtMS4xLTguMS0xLjFaIi8+PC9tYXNrPjxnIG1hc2s9InVybCgjYikiPjxwYXRoIGZpbGw9InVybCgjYykiIGQ9Ik01Ni42NCA5LjI1IDUwLjM3IDJIMjguMzRsLTYuMjggNy4yNXMtNS41LTEuNTYtOC4xIDEuMWMwIDAgNy4zNC0uNjggOS44NiAzLjUgMCAwIDYuODEgMS4zMyA3LjczIDEuMzMuOTIgMCAyLjktLjc4IDQuNzQtMS40IDEuODQtLjYzIDMuMDYtLjY0IDMuMDYtLjY0czEuMjMgMCAzLjA2LjYzYzEuODQuNjMgMy44MyAxLjQgNC43NSAxLjQuOTIgMCA3LjczLTEuMzIgNy43My0xLjMyIDIuNTItNC4xOCA5Ljg2LTMuNSA5Ljg2LTMuNS0yLjYtMi42Ni04LjEtMS4xLTguMS0xLjFaIi8+PC9nPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9IjguNzUiIHgyPSI2OS45NiIgeTE9IjM5LjA3IiB5Mj0iMzkuMDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRjUwIi8+PHN0b3Agb2Zmc2V0PSIuNDEiIHN0b3AtY29sb3I9IiNGNTAiLz48c3RvcCBvZmZzZXQ9Ii41OCIgc3RvcC1jb2xvcj0iI0ZGMjAwMCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGMjAwMCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJjIiB4MT0iMTUuMDUiIHgyPSI2NC43NSIgeTE9IjguNjgiIHkyPSI4LjY4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iI0ZGNDUyQSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGMjAwMCIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==";
const $$21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Brave_default
}, Symbol.toStringTag, { value: "Module" }));
var Chrome_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA3OCA3OCI+PHBhdGggZmlsbD0idXJsKCNhKSIgZD0iTTcxLjAzNCAyMC41YTM3LjAwMSAzNy4wMDEgMCAwIDAtNjQuMDg0IDBsMi4yMiAzOS45Nkw3MS4wMzQgMjAuNVoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMjIuOTc5IDQ4LjI1IDYuOTU4IDIwLjVBMzcgMzcgMCAwIDAgMzkgNzZsMzYuMjYtMzctNTIuMjgxIDkuMjVaIi8+PHBhdGggZmlsbD0idXJsKCNjKSIgZD0iTTU1LjAyMSA0OC4yNSAzOSA3NmEzNy4wMDEgMzcuMDAxIDAgMCAwIDMyLjAzNS01NS41SDM5bDE2LjAyMSAyNy43NVoiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMzkgNTcuNWExOC41IDE4LjUgMCAxIDAgMC0zNyAxOC41IDE4LjUgMCAwIDAgMCAzN1oiLz48cGF0aCBmaWxsPSIjMUE3M0U4IiBkPSJNMzkgNTMuNjUyYTE0LjY1IDE0LjY1IDAgMCAwIDEzLjUzNi0yMC4yNkExNC42NTMgMTQuNjUzIDAgMSAwIDM5IDUzLjY1M1oiLz48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImEiIHgxPSI2Ljk1OCIgeDI9IjcxLjAzNCIgeTE9IjI1LjEyNSIgeTI9IjI1LjEyNSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNEOTMwMjUiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNFQTQzMzUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjQzLjAwMyIgeDI9IjEwLjk2MSIgeTE9IjczLjY4NCIgeTI9IjE4LjE4NCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiMxRThFM0UiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMzNEE4NTMiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjMzLjU5OCIgeDI9IjY1LjY0IiB5MT0iNzYiIHkyPSIyMC41OTYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRkNDOTM0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkJCQzA0Ii8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PC9zdmc+";
const $$20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Chrome_default
}, Symbol.toStringTag, { value: "Module" }));
var scan_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+PHBhdGggZmlsbD0idXJsKCNhKSIgZD0iTTAgMTZjMC01LjYgMC04LjQgMS4wOS0xMC41NGExMCAxMCAwIDAgMSA0LjM3LTQuMzdDNy42IDAgMTAuNCAwIDE2IDBoMTZjNS42IDAgOC40IDAgMTAuNTQgMS4wOWExMCAxMCAwIDAgMSA0LjM3IDQuMzdDNDggNy42IDQ4IDEwLjQgNDggMTZ2MTZjMCA1LjYgMCA4LjQtMS4wOSAxMC41NGExMC4wMDEgMTAuMDAxIDAgMCAxLTQuMzcgNC4zN0M0MC40IDQ4IDM3LjYgNDggMzIgNDhIMTZjLTUuNiAwLTguNCAwLTEwLjU0LTEuMDlhMTAgMTAgMCAwIDEtNC4zNy00LjM3QzAgNDAuNCAwIDM3LjYgMCAzMlYxNloiLz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4wOCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMS4xMzMgOS41MTNDMSAxMS4xMzEgMSAxMy4xODMgMSAxNnYxNmMwIDIuODE3IDAgNC44Ny4xMzMgNi40ODYuMTMxIDEuNjA2LjM4NyAyLjY5NS44NDggMy42YTkgOSAwIDAgMCAzLjkzMyAzLjkzM2MuOTA1LjQ2MSAxLjk5NC43MTcgMy42Ljg0OEMxMS4xMyA0NyAxMy4xODMgNDcgMTYgNDdoMTZjMi44MTcgMCA0Ljg3IDAgNi40ODYtLjEzMyAxLjYwNi0uMTMxIDIuNjk1LS4zODcgMy42LS44NDhhOSA5IDAgMCAwIDMuOTMzLTMuOTMzYy40NjEtLjkwNS43MTctMS45OTQuODQ4LTMuNkM0NyAzNi44NyA0NyAzNC44MTYgNDcgMzJWMTZjMC0yLjgxNyAwLTQuODctLjEzMy02LjQ4Ny0uMTMxLTEuNjA1LS4zODctMi42OTQtLjg0OC0zLjU5OWE5IDkgMCAwIDAtMy45MzMtMy45MzNjLS45MDUtLjQ2MS0xLjk5NC0uNzE3LTMuNi0uODQ4QzM2Ljg3IDEgMzQuODE2IDEgMzIgMUgxNmMtMi44MTcgMC00Ljg3IDAtNi40ODcuMTMzLTEuNjA1LjEzMS0yLjY5NC4zODctMy41OTkuODQ4YTkgOSAwIDAgMC0zLjkzMyAzLjkzM2MtLjQ2MS45MDUtLjcxNyAxLjk5NC0uODQ4IDMuNlpNMS4wOSA1LjQ2QzAgNy42IDAgMTAuNCAwIDE2djE2YzAgNS42IDAgOC40IDEuMDkgMTAuNTRhMTAgMTAgMCAwIDAgNC4zNyA0LjM3QzcuNiA0OCAxMC40IDQ4IDE2IDQ4aDE2YzUuNiAwIDguNCAwIDEwLjU0LTEuMDlhMTAuMDAxIDEwLjAwMSAwIDAgMCA0LjM3LTQuMzdDNDggNDAuNCA0OCAzNy42IDQ4IDMyVjE2YzAtNS42IDAtOC40LTEuMDktMTAuNTRhMTAgMTAgMCAwIDAtNC4zNy00LjM3QzQwLjQgMCAzNy42IDAgMzIgMEgxNkMxMC40IDAgNy42IDAgNS40NiAxLjA5YTEwIDEwIDAgMCAwLTQuMzcgNC4zN1oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjEyIiBkPSJNMjggMTAuNUExLjUgMS41IDAgMCAxIDI5LjUgOWgzLjk1NWMuNTA2IDAgLjc2IDAgLjk3My4wMTVhNiA2IDAgMCAxIDUuNTU3IDUuNTU3Yy4wMTUuMjE0LjAxNS40NjcuMDE1Ljk3NFYxOS41YTEuNSAxLjUgMCAwIDEtMyAwdi00LjEyNWMwLS4zNDggMC0uNTIyLS4wMTQtLjY3YTMgMyAwIDAgMC0yLjY5Mi0yLjY5Yy0uMTQ3LS4wMTUtLjMyLS4wMTUtLjY2OS0uMDE1SDI5LjVhMS41IDEuNSAwIDAgMS0xLjUtMS41Wm0wIDI5YTEuNSAxLjUgMCAwIDAgMS41IDEuNWgzLjk1NWMuNTA2IDAgLjc2IDAgLjk3My0uMDE1YTYgNiAwIDAgMCA1LjU1Ny01LjU1N2MuMDE1LS4yMTQuMDE1LS40NjcuMDE1LS45NzNWMzAuNWExLjUgMS41IDAgMCAwLTMgMHY0LjEyNWMwIC4zNDggMCAuNTIyLS4wMTQuNjdhMyAzIDAgMCAxLTIuNjkyIDIuNjljLS4xNDcuMDE1LS4zMi4wMTUtLjY2OS4wMTVIMjkuNWExLjUgMS41IDAgMCAwLTEuNSAxLjVaTTE4LjUgNDFhMS41IDEuNSAwIDAgMCAwLTNoLTQuMTI1Yy0uMzQ4IDAtLjUyMiAwLS42Ny0uMDE0YTMgMyAwIDAgMS0yLjY5LTIuNjkyYy0uMDE1LS4xNDctLjAxNS0uMzItLjAxNS0uNjY5VjMwLjVhMS41IDEuNSAwIDAgMC0zIDB2My45NTVjMCAuNTA2IDAgLjc2LjAxNS45NzNhNiA2IDAgMCAwIDUuNTU3IDUuNTU3Yy4yMTQuMDE1LjQ2Ny4wMTUuOTc0LjAxNUgxOC41Wk0yMCAxMC41QTEuNSAxLjUgMCAwIDAgMTguNSA5aC0zLjk1NGMtLjUwNyAwLS43NiAwLS45NzQuMDE1YTYgNiAwIDAgMC01LjU1NyA1LjU1N0M4IDE0Ljc4NiA4IDE1LjAzOSA4IDE1LjU0NlYxOS41YTEuNSAxLjUgMCAwIDAgMyAwdi00LjEyNWMwLS4zNDggMC0uNTIyLjAxNC0uNjdhMyAzIDAgMCAxIDIuNjkyLTIuNjljLjE0Ny0uMDE1LjMyLS4wMTUuNjY5LS4wMTVIMTguNWExLjUgMS41IDAgMCAwIDEuNS0xLjVaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTI4IDkuNUExLjUgMS41IDAgMCAxIDI5LjUgOGgzLjk1NWMuNTA2IDAgLjc2IDAgLjk3My4wMTVhNiA2IDAgMCAxIDUuNTU3IDUuNTU3Yy4wMTUuMjE0LjAxNS40NjcuMDE1Ljk3NFYxOC41YTEuNSAxLjUgMCAwIDEtMyAwdi00LjEyNWMwLS4zNDggMC0uNTIyLS4wMTQtLjY3YTMgMyAwIDAgMC0yLjY5Mi0yLjY5Yy0uMTQ3LS4wMTUtLjMyLS4wMTUtLjY2OS0uMDE1SDI5LjVBMS41IDEuNSAwIDAgMSAyOCA5LjVabTAgMjlhMS41IDEuNSAwIDAgMCAxLjUgMS41aDMuOTU1Yy41MDYgMCAuNzYgMCAuOTczLS4wMTVhNiA2IDAgMCAwIDUuNTU3LTUuNTU3Yy4wMTUtLjIxNC4wMTUtLjQ2Ny4wMTUtLjk3M1YyOS41YTEuNSAxLjUgMCAwIDAtMyAwdjQuMTI1YzAgLjM0OCAwIC41MjItLjAxNC42N2EzIDMgMCAwIDEtMi42OTIgMi42OWMtLjE0Ny4wMTUtLjMyLjAxNS0uNjY5LjAxNUgyOS41YTEuNSAxLjUgMCAwIDAtMS41IDEuNVpNMTguNSA0MGExLjUgMS41IDAgMCAwIDAtM2gtNC4xMjVjLS4zNDggMC0uNTIyIDAtLjY3LS4wMTRhMyAzIDAgMCAxLTIuNjktMi42OTJjLS4wMTUtLjE0Ny0uMDE1LS4zMi0uMDE1LS42NjlWMjkuNWExLjUgMS41IDAgMCAwLTMgMHYzLjk1NWMwIC41MDYgMCAuNzYuMDE1Ljk3M2E2IDYgMCAwIDAgNS41NTcgNS41NTdjLjIxNC4wMTUuNDY3LjAxNS45NzQuMDE1SDE4LjVaTTIwIDkuNUExLjUgMS41IDAgMCAwIDE4LjUgOGgtMy45NTRjLS41MDcgMC0uNzYgMC0uOTc0LjAxNWE2IDYgMCAwIDAtNS41NTcgNS41NTdDOCAxMy43ODYgOCAxNC4wMzkgOCAxNC41NDZWMTguNWExLjUgMS41IDAgMCAwIDMgMHYtNC4xMjVjMC0uMzQ4IDAtLjUyMi4wMTQtLjY3YTMgMyAwIDAgMSAyLjY5Mi0yLjY5Yy4xNDctLjAxNS4zMi0uMDE1LjY2OS0uMDE1SDE4LjVBMS41IDEuNSAwIDAgMCAyMCA5LjVaIi8+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMjQiIHgyPSIyNCIgeTE9IjAiIHkyPSI0OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiM1OTYyN0EiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM0QTUyNjYiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48L3N2Zz4=";
const $$19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: scan_default
}, Symbol.toStringTag, { value: "Module" }));
var refresh_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAxNmMwLTUuNiAwLTguNCAxLjA5LTEwLjU0YTEwIDEwIDAgMCAxIDQuMzctNC4zN0M3LjYgMCAxMC40IDAgMTYgMGgxNmM1LjYgMCA4LjQgMCAxMC41NCAxLjA5YTEwIDEwIDAgMCAxIDQuMzcgNC4zN0M0OCA3LjYgNDggMTAuNCA0OCAxNnYxNmMwIDUuNiAwIDguNC0xLjA5IDEwLjU0YTEwLjAwMSAxMC4wMDEgMCAwIDEtNC4zNyA0LjM3QzQwLjQgNDggMzcuNiA0OCAzMiA0OEgxNmMtNS42IDAtOC40IDAtMTAuNTQtMS4wOWExMCAxMCAwIDAgMS00LjM3LTQuMzdDMCA0MC40IDAgMzcuNiAwIDMyVjE2WiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjA4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xLjEzMyA5LjUxM0MxIDExLjEzMSAxIDEzLjE4MyAxIDE2djE2YzAgMi44MTcgMCA0Ljg3LjEzMyA2LjQ4Ni4xMzEgMS42MDYuMzg3IDIuNjk1Ljg0OCAzLjZhOSA5IDAgMCAwIDMuOTMzIDMuOTMzYy45MDUuNDYxIDEuOTk0LjcxNyAzLjYuODQ4QzExLjEzIDQ3IDEzLjE4MyA0NyAxNiA0N2gxNmMyLjgxNyAwIDQuODcgMCA2LjQ4Ni0uMTMzIDEuNjA2LS4xMzEgMi42OTUtLjM4NyAzLjYtLjg0OGE5IDkgMCAwIDAgMy45MzMtMy45MzNjLjQ2MS0uOTA1LjcxNy0xLjk5NC44NDgtMy42QzQ3IDM2Ljg3IDQ3IDM0LjgxNiA0NyAzMlYxNmMwLTIuODE3IDAtNC44Ny0uMTMzLTYuNDg3LS4xMzEtMS42MDUtLjM4Ny0yLjY5NC0uODQ4LTMuNTk5YTkgOSAwIDAgMC0zLjkzMy0zLjkzM2MtLjkwNS0uNDYxLTEuOTk0LS43MTctMy42LS44NDhDMzYuODcgMSAzNC44MTYgMSAzMiAxSDE2Yy0yLjgxNyAwLTQuODcgMC02LjQ4Ny4xMzMtMS42MDUuMTMxLTIuNjk0LjM4Ny0zLjU5OS44NDhhOSA5IDAgMCAwLTMuOTMzIDMuOTMzYy0uNDYxLjkwNS0uNzE3IDEuOTk0LS44NDggMy42Wk0xLjA5IDUuNDZDMCA3LjYgMCAxMC40IDAgMTZ2MTZjMCA1LjYgMCA4LjQgMS4wOSAxMC41NGExMCAxMCAwIDAgMCA0LjM3IDQuMzdDNy42IDQ4IDEwLjQgNDggMTYgNDhoMTZjNS42IDAgOC40IDAgMTAuNTQtMS4wOWExMC4wMDEgMTAuMDAxIDAgMCAwIDQuMzctNC4zN0M0OCA0MC40IDQ4IDM3LjYgNDggMzJWMTZjMC01LjYgMC04LjQtMS4wOS0xMC41NGExMCAxMCAwIDAgMC00LjM3LTQuMzdDNDAuNCAwIDM3LjYgMCAzMiAwSDE2QzEwLjQgMCA3LjYgMCA1LjQ2IDEuMDlhMTAgMTAgMCAwIDAtNC4zNyA0LjM3WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMTIiIGQ9Ik0zNi4zNDUgMTMuMTU1YTEuNSAxLjUgMCAxIDAtMyAwdjIuMjI0YzAgLjYyNy0uNzc1LjkzNy0xLjIxOC40OTRhMTIuNzUgMTIuNzUgMCAxIDAgMCAxOC4wMzEgMS41IDEuNSAwIDEgMC0yLjEyMS0yLjEyIDkuNzUgOS43NSAwIDEgMSAwLTEzLjc5Yy42MS42MS4xNzIgMS42MTYtLjY5MSAxLjYxNkgyNi44OWExLjUgMS41IDAgMCAwIDAgM2g3Ljk1NWExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTcuOTU1WiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0zNi4zNDUgMTIuMTU1YTEuNSAxLjUgMCAxIDAtMyAwdjIuMjI0YzAgLjYyNy0uNzc1LjkzNy0xLjIxOC40OTRhMTIuNzUgMTIuNzUgMCAxIDAgMCAxOC4wMzEgMS41IDEuNSAwIDEgMC0yLjEyMS0yLjEyIDkuNzUgOS43NSAwIDEgMSAwLTEzLjc5Yy42MS42MS4xNzIgMS42MTYtLjY5MSAxLjYxNkgyNi44OWExLjUgMS41IDAgMCAwIDAgM2g3Ljk1NWExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTcuOTU1WiIvPjwvZz48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgxPSIyNCIgeDI9IjI0IiB5MT0iMCIgeTI9IjQ4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzU5NjI3QSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzRBNTI2NiIvPjwvbGluZWFyR3JhZGllbnQ+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDQ4djQ4SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+";
const $$18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: refresh_default
}, Symbol.toStringTag, { value: "Module" }));
var create_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+PHBhdGggZmlsbD0idXJsKCNhKSIgZD0iTTAgMTZjMC01LjYgMC04LjQgMS4wOS0xMC41NGExMCAxMCAwIDAgMSA0LjM3LTQuMzdDNy42IDAgMTAuNCAwIDE2IDBoMTZjNS42IDAgOC40IDAgMTAuNTQgMS4wOWExMCAxMCAwIDAgMSA0LjM3IDQuMzdDNDggNy42IDQ4IDEwLjQgNDggMTZ2MTZjMCA1LjYgMCA4LjQtMS4wOSAxMC41NGExMC4wMDEgMTAuMDAxIDAgMCAxLTQuMzcgNC4zN0M0MC40IDQ4IDM3LjYgNDggMzIgNDhIMTZjLTUuNiAwLTguNCAwLTEwLjU0LTEuMDlhMTAgMTAgMCAwIDEtNC4zNy00LjM3QzAgNDAuNCAwIDM3LjYgMCAzMlYxNloiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBmaWxsLW9wYWNpdHk9Ii43IiBkPSJNMCAxNmMwLTUuNiAwLTguNCAxLjA5LTEwLjU0YTEwIDEwIDAgMCAxIDQuMzctNC4zN0M3LjYgMCAxMC40IDAgMTYgMGgxNmM1LjYgMCA4LjQgMCAxMC41NCAxLjA5YTEwIDEwIDAgMCAxIDQuMzcgNC4zN0M0OCA3LjYgNDggMTAuNCA0OCAxNnYxNmMwIDUuNiAwIDguNC0xLjA5IDEwLjU0YTEwLjAwMSAxMC4wMDEgMCAwIDEtNC4zNyA0LjM3QzQwLjQgNDggMzcuNiA0OCAzMiA0OEgxNmMtNS42IDAtOC40IDAtMTAuNTQtMS4wOWExMCAxMCAwIDAgMS00LjM3LTQuMzdDMCA0MC40IDAgMzcuNiAwIDMyVjE2WiIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOnNjcmVlbiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjA0IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zMiAxSDE2Yy0yLjgxNyAwLTQuODcgMC02LjQ4Ny4xMzMtMS42MDUuMTMxLTIuNjk0LjM4Ny0zLjU5OS44NDhhOSA5IDAgMCAwLTMuOTMzIDMuOTMzYy0uNDYxLjkwNS0uNzE3IDEuOTk0LS44NDggMy42QzEgMTEuMTMgMSAxMy4xODMgMSAxNnYxNmMwIDIuODE3IDAgNC44Ny4xMzMgNi40ODYuMTMxIDEuNjA2LjM4NyAyLjY5NS44NDggMy42YTkgOSAwIDAgMCAzLjkzMyAzLjkzM2MuOTA1LjQ2MSAxLjk5NC43MTcgMy42Ljg0OEMxMS4xMyA0NyAxMy4xODMgNDcgMTYgNDdoMTZjMi44MTcgMCA0Ljg3IDAgNi40ODYtLjEzMyAxLjYwNi0uMTMxIDIuNjk1LS4zODcgMy42LS44NDhhOSA5IDAgMCAwIDMuOTMzLTMuOTMzYy40NjEtLjkwNS43MTctMS45OTQuODQ4LTMuNkM0NyAzNi44NyA0NyAzNC44MTYgNDcgMzJWMTZjMC0yLjgxNyAwLTQuODctLjEzMy02LjQ4Ny0uMTMxLTEuNjA1LS4zODctMi42OTQtLjg0OC0zLjU5OWE5IDkgMCAwIDAtMy45MzMtMy45MzNjLS45MDUtLjQ2MS0xLjk5NC0uNzE3LTMuNi0uODQ4QzM2Ljg3IDEgMzQuODE2IDEgMzIgMVpNMS4wOSA1LjQ2QzAgNy42IDAgMTAuNCAwIDE2djE2YzAgNS42IDAgOC40IDEuMDkgMTAuNTRhMTAgMTAgMCAwIDAgNC4zNyA0LjM3QzcuNiA0OCAxMC40IDQ4IDE2IDQ4aDE2YzUuNiAwIDguNCAwIDEwLjU0LTEuMDlhMTAuMDAxIDEwLjAwMSAwIDAgMCA0LjM3LTQuMzdDNDggNDAuNCA0OCAzNy42IDQ4IDMyVjE2YzAtNS42IDAtOC40LTEuMDktMTAuNTRhMTAgMTAgMCAwIDAtNC4zNy00LjM3QzQwLjQgMCAzNy42IDAgMzIgMEgxNkMxMC40IDAgNy42IDAgNS40NiAxLjA5YTEwIDEwIDAgMCAwLTQuMzcgNC4zN1oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjEyIiBkPSJNMjQgMTNhMS41IDEuNSAwIDAgMC0xLjUgMS41djguMmMwIC4yOCAwIC40Mi0uMDU1LjUyN2EuNS41IDAgMCAxLS4yMTguMjE4Yy0uMTA3LjA1NS0uMjQ3LjA1NS0uNTI3LjA1NWgtOC4yYTEuNSAxLjUgMCAwIDAgMCAzaDguMmMuMjggMCAuNDIgMCAuNTI3LjA1NWEuNS41IDAgMCAxIC4yMTguMjE4Yy4wNTUuMTA3LjA1NS4yNDcuMDU1LjUyN3Y4LjJhMS41IDEuNSAwIDAgMCAzIDB2LTguMmMwLS4yOCAwLS40Mi4wNTUtLjUyN2EuNS41IDAgMCAxIC4yMTgtLjIxOGMuMTA3LS4wNTUuMjQ3LS4wNTUuNTI3LS4wNTVoOC4yYTEuNSAxLjUgMCAwIDAgMC0zaC04LjJjLS4yOCAwLS40MiAwLS41MjctLjA1NWEuNS41IDAgMCAxLS4yMTgtLjIxOGMtLjA1NS0uMTA3LS4wNTUtLjI0Ny0uMDU1LS41Mjd2LTguMkExLjUgMS41IDAgMCAwIDI0IDEzWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0yNCAxMmExLjUgMS41IDAgMCAwLTEuNSAxLjV2OC4yYzAgLjI4IDAgLjQyLS4wNTUuNTI3YS41LjUgMCAwIDEtLjIxOC4yMThjLS4xMDcuMDU1LS4yNDcuMDU1LS41MjcuMDU1aC04LjJhMS41IDEuNSAwIDAgMCAwIDNoOC4yYy4yOCAwIC40MiAwIC41MjcuMDU1YS41LjUgMCAwIDEgLjIxOC4yMThjLjA1NS4xMDcuMDU1LjI0Ny4wNTUuNTI3djguMmExLjUgMS41IDAgMCAwIDMgMHYtOC4yYzAtLjI4IDAtLjQyLjA1NS0uNTI3YS41LjUgMCAwIDEgLjIxOC0uMjE4Yy4xMDctLjA1NS4yNDctLjA1NS41MjctLjA1NWg4LjJhMS41IDEuNSAwIDAgMCAwLTNoLTguMmMtLjI4IDAtLjQyIDAtLjUyNy0uMDU1YS41LjUgMCAwIDEtLjIxOC0uMjE4Yy0uMDU1LS4xMDctLjA1NS0uMjQ3LS4wNTUtLjUyN3YtOC4yQTEuNSAxLjUgMCAwIDAgMjQgMTJaIi8+PGRlZnM+PHJhZGlhbEdyYWRpZW50IGlkPSJhIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoLTQwLjA3NyA3My4zNzQgNTguNjAzKSBzY2FsZSg5NC43NDg0KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjI3NiIgc3RvcC1jb2xvcj0iIzIwRkY0RCIvPjxzdG9wIG9mZnNldD0iLjQ2NCIgc3RvcC1jb2xvcj0iIzE0OTlGRiIvPjxzdG9wIG9mZnNldD0iLjc1NSIgc3RvcC1jb2xvcj0iI0ZGNkZDNSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0JDNjdGRiIvPjwvcmFkaWFsR3JhZGllbnQ+PHJhZGlhbEdyYWRpZW50IGlkPSJiIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VHJhbnNmb3JtPSJyb3RhdGUoNDUgNS4zMDMgLTEyLjgwMykgc2NhbGUoNzguNDg4OSkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSJyZWQiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMEEzRkYiLz48L3JhZGlhbEdyYWRpZW50PjwvZGVmcz48L3N2Zz4=";
const $$17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: create_default
}, Symbol.toStringTag, { value: "Module" }));
var sign_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAC/VBMVEUAAADS0dDp6enV1NTi4uLOzc3l5eXh4eHl5eXW1dXa2trQz87e3t2ll5fne3vFdXV+PT14d3fS0dHj4+OBaGh5Pz9yOjqqX19iYmJqQUGlkJBoQUGrqqqKiomEY2PIiYn39vbx8fHz8/P6+fnu7e34+Pjv7+/19fXp6Oje3d3m5uXs7Ozd3Nzr6+ra2dnc29vf397b2trn5+fq6unk5OTV1NTj4+LZ2NfX19fX1tXg4N/i4uHh4eDQz87T0tLU09PR0M/Dw8P7+/rKyslnZ2fKlx/MzMvHx8f/00POzc2rq6uLi4z/zTilpabFxcW/v8CpqKmioqPOmyb/zDTS0dC0tLSfoKGdnZ6YmJn/103/1UjIlRn1tw+6uruxsbGEhIX/zzz/yB7boQ69vb3v0JGPkJCIiYrEqnfMmSObm5uVlZaHh4d9fX7mpwHqqwD8/PyAgIDQnSn/wxatra2RkpP/0T7/yS63trbTnyy3uLivrq+NjY9tbGxqamqUlJX9p6d4eHn+0EGCgoNtaWD2uyBwcHDWozHy05PrzI7dwIZlZWa+jRLBwcDIrnvZ29//oaH7lJRyb2hya1z/xyj1uR+5ihOPobf9ra2ZlZDph4bTgYHOtH/Gbm5WWFk/QELc3uHfenp9fHl3dnOyhRfGkQ6Snq60nKXlx43yhoXehITLd3fdvXG4YmLerzO1yNyZqb7+srK6sKL9m5v11pWuXV2UVFRXVlE2OT3DkiD/wAzoqQHd4eWpvdXR09S2w9Gbo67oo6PRoKPwnJzkxYbWuoLcvnXIq2uQg2lcX2FLTU/yyECitMqUmKDOvJPyjo55foaVinWynHDauGllY1+GdE6dhUv60kr/y0mXfD36xzPoshr3tQTi7fPisrKLk6Guk5unlZW+q4GTjID1zXetmGT6zGHSrFzGo1Xitk6mi0bywjb+vyLUmwjhowDm29qjr7zPt7f/5af83Z773Jz32Ji0lpWffoCklXTUuHK5n2rmvmWzmFWCQUFwNjYdICKb6dEPAAAAIHRSTlMAtqO8vLaztKOzs7yzJAqt+ryEd1P37uHaw769vLxsZrn7H40AAAyrSURBVFjDndYHfBpVHAdw9957C9wBNxjHcaw7IIwKArI0DAegIlGGBg2KSUyM0TpqtO5R26p177333nvvvffefvy/d9AQQl2/lOul9+7b/xv3juXkbLgazgr/Pau1syGG1mmBq9JOgWEYnuep/xSeZyCC1SrSK8lSG5QYyqzXsyzZjkaDDu3TZYbV6/VmM0UxYhdopcDSQJT/KXADZs2UtQsUzKSsqVrRzvrpjlI1bbLd4CoMgNOetjuYhCM+7eRlEkChG9ST4LUwhVbRI9qOUzmYlcVeYNtT/OtgEoukmekGWVxgW1PL0conBPzA2TJE8HqAvAwqQkqnbBHwRxsm0BkVYkxw0hVCjUVcYm8QFeh0x1horNISELI87IO/+DKXUBAQtdLnGyQGCQLpPhNPKrSkitWQfwOq4/Ygp1CYnayVIHz+IKnUEIPD7tF+h4ogmGTGW0wYRtSk0UdQqVy4mmlkM7EG8zegPpkcSo9nk4NR0edjsonxKOkLRrOZoXGDb3BETCcHBjKlcCrpjQ0ronl6JJzNJrJ/02WFl3aXEvH8CJ+y+Oi8yR8cJBi/idQwGiXho+NamCZVvjgYBV9N6eE3QqWFxxVNitALtFqUalbtGxwkzITPTBBwQvh8PkKObxAdHKOD1gqLRlHRnhS8DnuBWpsWrxji7yLxqtSwD3kYbC1DtieIHhIA/0EkbBlqmpMXDamnrN2gHkClVk1yM0v0ST5Co5F7DCEIfBU8ZGpIXF9PkAFQSaWaXp0K3aJue/7yIJHUICMwPJSKqyG4PCIYU+gLIqoPb1+81PNZJppEhsb3oLkYhOImdb6om0AgEyZSCQJzEHpUoxgPovnAmyzFOGeD0Gc6EK9oOSXUGArGqdiUJh2yxKd4xKglv72qZeGZ5hmVk82Ggp5EquXBji2IXaBgBlCR6ovUU1WNmshnGoXs6EAxnMllo3ECjWuemRxNhwkFExkIF8rZWr6QrpC0BnM8L3C9QIPf6/UORSm1YFEJjJWMV8OGftrv1FrVatZUjMdHvAq1V1MM+9Nxf1wXHk0HDUYKdZiR6F4gqYLZI3zQLTnspKq177SXp1refVVamA30gOgp85dv3PO1yIu6VbtAikWvgKUbLB76bJGYtf1Nb9Koszz1xsUXn7Pw+h9o40xwVQBJDMqrG68zqqjGMrFUY5bu0KSGBY7h7774hBNOuPic628o9niNQhuG0ZJaFLVIYUnjUJvjai2OuuluvZRUrCWc1zOMcPfF186fP//aE865/PctukAeFmIwlbO5AloIaRjHdRJh3loVFdhT+FMKzGl0yURUaN5h9d9z5rXzD4XMB3G9bWaBpCpI6aMEujdYMeB+e4POkhkKhHlQiQOsjuEoTsOyrHE4FuW59B333Iu800+f/ySIG3WCEq9nSTKvHS+FvbCzJw12p9soCoVUOe4PVgeyxUKsNF5NVhqJpEZvZqPBicBwPJUCEbyrrz702osvvX6TtWeAZlYzzESbjapby6YziWo9k42UsuahSNYfKJYrjYq3MRS1pzNpjjIPZ5bUCuO5284evuvCexF4+vwTzlx4w5adIGPWkxT6WgEzDQcFbMhWgSe1aJNCiw9fUJJKndnA8yGjJ5Avnn3b63deMHDh3adfffqhAJ5z+R8bTYNOhtKznd9GQGmdtL/CoKUHa48WRMHqjKVSdvb1O6887c2nQATvyTPPWXjD5l1gp6jwmqc57OFthRQKoYbAnf3LNXfcdtuVV15w+wXjT11477XgXbJg4fUbr70UFBkeWpOgyaIi1tR2cuDhfSBab9b7ubOf/fz8J668/bGrbn/zyrvOqF145plnXnLJgkuvv6EDFGBWrKV4f9FCO3W0Mh6GhUIaHSalh7QYwTMavDGeMmfcjbD77Ge/+GK3V9+/6rSrrrr98TvT7y55a8ElCLx803WWghyAunR6PFKulkr1bKTOKlXm0XqkkawPj8LGYYw05lbMYimdrQ489ey+++62xxGvvnDaaY9ddefjw5Vzl7x16YIFCxZevi1Q06A+wFhiQWUgF7Q2vfGcyjxQi6SjyclKKaXRpTMBf04ftyS83vhH+9662x4HvPLpFUi8K9e45owl57596YJLF66LLZy1OCvMCppnsj0tSqZs1mjtAwazGUaPZdG2zEgSffxl2DvoFVn8qtw848LSknN/XLhw3XU6QBpAEDUsgA4lTLZGNeqAoWsMKVkWfy/nGcEqiTrw9kPeTjvs8OijV3xywQUjb19zxhmFE5fcAN5MEIZcn9CwyuE0ApXFEbRL+fXIAw55Tq7D2333ww579NFPLogi79wTF90IM9wJSgzPs9EAq8lV9XiZUMDBysQclMdYZ3rAHfbiiy+++vJdyTMK9RNvfGSzmaBOEhizt8DShnqeCSthLIFD0Zvl8qA+2jjD236XXXY+5fObX05XwVv03PrAdIJOgXFMRiowsbVSvtji9BAoTx4+rtM7ELyddz5lzx1vPu/50RMXPTyvGzQ6rXzYFR0KUl5HrmgKyV6rPOzRpuMfmOXtv8/NII4tmjNvbOsuUIRp5vVgsCxURyINPKrlOZfh7bjddjcfe95J8+bNjWw1A1zDJFoFmBYKk0BhbtrjaGOnt33b22e7XXc9/7zDx+ZWhlbuBiUBHhYh15RLw57MCRJ4Ie+0ByD2DgZvO+TNm1vJx1bsAjlJEGOJpIuRLVTdtKczjf7c9uQCp71TD58zVhgKerpAA4C2oD/uL7Y0Mw+LDzy8/OjHH+z0dpnpHTKZjPf3d4O00ypQSWuZhXUCbyF4ECVGgPr6Qn3G/tHfbp1Z3xF7HiwPIPIiiaLH0hP0ezP5QIbVT0Uq9WR0pGS1Wk2laKky8TL2Tu7yoMDzkDcU67M73F2gjRYlJlmu1SZH9LF6ppksFSqFjMsqBbON4IMtb6du79Qb5xwyOhSzG2yzQZ0oWbx+i4uDl5pR4gQ7L4YkwSly3NnH7Lss73DkBe0mg2EWaNeJ0GcGh8dHeHrR80a3vYN6edDfoM1kMhkcfd2gkXNKVqsAGNXH2AFEnuTivO8g75ZleSO5oNEIoL0HKILI5Bm+WS8O8Lg+JjA5deIV095h2DsSvH1aXj5X7TNCDPauLq/uMAEoMPkmH5xM1oyCAPufWK6lD3nn1/1meTtib+yQUr46YdHpdFBiD5AWxWSuYjROjNSiBqeYD/kNJc9E4piPX7sFJgT3F3sHY+/Ywxc/Uju3viREAwgVOnqAzhFXKdBIliPlicl6YWDu3EJqvPbuMR/v99otGGx5+2PvucWLFy8aSxWmOLo3aDHQUrScTlYmqvVm1BFN5XPxqUzO+8QxR7/3wUsvHbQDeuCmvZMWjw1Uin6dV0fTIJp6gTpOpAU+V61EKUZCU+LkRK551n17Xff9t9+8tBMMYIcH8xEOGmgcqLAXaNPRMC3cxFDdIEGcTifH6WxPH3P0UUddd913H3y2w2GnzPRiBh3cwi0bNAIoin6JszolCbZoEY3OE/ftdRTkuvde+2y3PY88stODCmgZNC4ThE6HoDbJKQxzImo7df/RAEL22nffPa9ABWJvbAB5iONaXbbNAvvsRh1cnxxGnZW8GQmBnqfv2wvn6IuOPH9/AHfcB9eHPegvBntXCKBJpxPHG2g2rJaGE1UoFvY+WuaOuf+sBz/68MODd1zqGQFEGowLrtDS3wW6HSYjl5gM5MuFoXTNJnKBiXIhfx/iwDvrOJSz9t9O7q8XugNYxyT3Ag1G90R2ojoZqdXL0PtsdaR2zdGt8o7bG3Lcg/A+Ai8BHiqw7elMCPR0gf0Og25oIp6wBBz9U+U+zjhaTIz+dN20B3n/+TlzDgHPAR5AsocLnA0u77HYTANhkcMj7YTREd2Rxk0P7QXdlblnHjpx3pw5cyNhr8NkMgIJJgTNCID2XmBxwm2EFq2ecMnx0k2Lb9wbvLY2Nvfc8ZGYw4BBkKY9m73PteZM0GWxpVJwWW6GOyItWnzT4oefxto80Caq2UTO7zAYQAQTR+Zs8I4KzQRXDvXB/2zobGgK3HTTIw8vegRKQ7UNZBPNKb/bbrMZECmj8IFfwLP0zwLdDtzW1AqcJP5cNO/hOWOg1SLlxLDX77FAGxxM4sj1ARjoAgP9FgcmW4ETy1SzgLVMOOcNeCyoQSsyCh8bcHYo0OKZDfahO3Bb/IF4RmqgDeVi8kW4jD9tF9ohzAFcn9vVDfpd/W63uw9unI4rlxgBzePugws4+G/LjEbwj+7+flfI3wUG/YFQKORyeTz9+AfF5Q/6Qy5ICH/g2I4HfXDQlVAgEPDH2uA6+LjByjjL/5+sLGcD2fsLerG519oDlHIAAAAASUVORK5CYII=";
const $$16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: sign_default
}, Symbol.toStringTag, { value: "Module" }));
var login_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+PHBhdGggZmlsbD0idXJsKCNhKSIgZD0iTTAgMTZjMC01LjYgMC04LjQgMS4wOS0xMC41NGExMCAxMCAwIDAgMSA0LjM3LTQuMzdDNy42IDAgMTAuNCAwIDE2IDBoMTZjNS42IDAgOC40IDAgMTAuNTQgMS4wOWExMCAxMCAwIDAgMSA0LjM3IDQuMzdDNDggNy42IDQ4IDEwLjQgNDggMTZ2MTZjMCA1LjYgMCA4LjQtMS4wOSAxMC41NGExMC4wMDEgMTAuMDAxIDAgMCAxLTQuMzcgNC4zN0M0MC40IDQ4IDM3LjYgNDggMzIgNDhIMTZjLTUuNiAwLTguNCAwLTEwLjU0LTEuMDlhMTAgMTAgMCAwIDEtNC4zNy00LjM3QzAgNDAuNCAwIDM3LjYgMCAzMlYxNloiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAxNmMwLTUuNiAwLTguNCAxLjA5LTEwLjU0YTEwIDEwIDAgMCAxIDQuMzctNC4zN0M3LjYgMCAxMC40IDAgMTYgMGgxNmM1LjYgMCA4LjQgMCAxMC41NCAxLjA5YTEwIDEwIDAgMCAxIDQuMzcgNC4zN0M0OCA3LjYgNDggMTAuNCA0OCAxNnYxNmMwIDUuNiAwIDguNC0xLjA5IDEwLjU0YTEwLjAwMSAxMC4wMDEgMCAwIDEtNC4zNyA0LjM3QzQwLjQgNDggMzcuNiA0OCAzMiA0OEgxNmMtNS42IDAtOC40IDAtMTAuNTQtMS4wOWExMCAxMCAwIDAgMS00LjM3LTQuMzdDMCA0MC40IDAgMzcuNiAwIDMyVjE2WiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjA0IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xLjEzMyA5LjUxM0MxIDExLjEzMSAxIDEzLjE4MyAxIDE2djE2YzAgMi44MTcgMCA0Ljg3LjEzMyA2LjQ4Ni4xMzEgMS42MDYuMzg3IDIuNjk1Ljg0OCAzLjZhOSA5IDAgMCAwIDMuOTMzIDMuOTMzYy45MDUuNDYxIDEuOTk0LjcxNyAzLjYuODQ4QzExLjEzIDQ3IDEzLjE4MyA0NyAxNiA0N2gxNmMyLjgxNyAwIDQuODcgMCA2LjQ4Ni0uMTMzIDEuNjA2LS4xMzEgMi42OTUtLjM4NyAzLjYtLjg0OGE5IDkgMCAwIDAgMy45MzMtMy45MzNjLjQ2MS0uOTA1LjcxNy0xLjk5NC44NDgtMy42QzQ3IDM2Ljg3IDQ3IDM0LjgxNiA0NyAzMlYxNmMwLTIuODE3IDAtNC44Ny0uMTMzLTYuNDg3LS4xMzEtMS42MDUtLjM4Ny0yLjY5NC0uODQ4LTMuNTk5YTkgOSAwIDAgMC0zLjkzMy0zLjkzM2MtLjkwNS0uNDYxLTEuOTk0LS43MTctMy42LS44NDhDMzYuODcgMSAzNC44MTYgMSAzMiAxSDE2Yy0yLjgxNyAwLTQuODcgMC02LjQ4Ny4xMzMtMS42MDUuMTMxLTIuNjk0LjM4Ny0zLjU5OS44NDhhOSA5IDAgMCAwLTMuOTMzIDMuOTMzYy0uNDYxLjkwNS0uNzE3IDEuOTk0LS44NDggMy42Wk0xLjA5IDUuNDZDMCA3LjYgMCAxMC40IDAgMTZ2MTZjMCA1LjYgMCA4LjQgMS4wOSAxMC41NGExMCAxMCAwIDAgMCA0LjM3IDQuMzdDNy42IDQ4IDEwLjQgNDggMTYgNDhoMTZjNS42IDAgOC40IDAgMTAuNTQtMS4wOWExMC4wMDEgMTAuMDAxIDAgMCAwIDQuMzctNC4zN0M0OCA0MC40IDQ4IDM3LjYgNDggMzJWMTZjMC01LjYgMC04LjQtMS4wOS0xMC41NGExMCAxMCAwIDAgMC00LjM3LTQuMzdDNDAuNCAwIDM3LjYgMCAzMiAwSDE2QzEwLjQgMCA3LjYgMCA1LjQ2IDEuMDlhMTAgMTAgMCAwIDAtNC4zNyA0LjM3WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0idXJsKCNjKSIgZD0iTTMgMTQuMmMwLTMuOTIgMC01Ljg4Ljc2My03LjM3OGE3IDcgMCAwIDEgMy4wNi0zLjA1OUM4LjMxOCAzIDEwLjI4IDMgMTQuMiAzaDE5LjZjMy45MiAwIDUuODggMCA3LjM3OC43NjNhNyA3IDAgMCAxIDMuMDU5IDMuMDZDNDUgOC4zMTggNDUgMTAuMjggNDUgMTQuMnYxOS42YzAgMy45MiAwIDUuODgtLjc2MyA3LjM3OGE3IDcgMCAwIDEtMy4wNiAzLjA1OUMzOS42ODIgNDUgMzcuNzIgNDUgMzMuOCA0NUgxNC4yYy0zLjkyIDAtNS44OCAwLTcuMzc4LS43NjNhNyA3IDAgMCAxLTMuMDU5LTMuMDZDMyAzOS42ODIgMyAzNy43MiAzIDMzLjhWMTQuMloiLz48cGF0aCBmaWxsPSJ1cmwoI2QpIiBmaWxsLW9wYWNpdHk9Ii43IiBkPSJNMyAxNC4yYzAtMy45MiAwLTUuODguNzYzLTcuMzc4YTcgNyAwIDAgMSAzLjA2LTMuMDU5QzguMzE4IDMgMTAuMjggMyAxNC4yIDNoMTkuNmMzLjkyIDAgNS44OCAwIDcuMzc4Ljc2M2E3IDcgMCAwIDEgMy4wNTkgMy4wNkM0NSA4LjMxOCA0NSAxMC4yOCA0NSAxNC4ydjE5LjZjMCAzLjkyIDAgNS44OC0uNzYzIDcuMzc4YTcgNyAwIDAgMS0zLjA2IDMuMDU5QzM5LjY4MiA0NSAzNy43MiA0NSAzMy44IDQ1SDE0LjJjLTMuOTIgMC01Ljg4IDAtNy4zNzgtLjc2M2E3IDcgMCAwIDEtMy4wNTktMy4wNkMzIDM5LjY4MiAzIDM3LjcyIDMgMzMuOFYxNC4yWiIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOnNjcmVlbiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTMuNTk0IDkuNjQzQzMuNSAxMC43ODUgMy41IDEyLjIzMiAzLjUgMTQuMnYxOS42YzAgMS45NjggMCAzLjQxNS4wOTQgNC41NTcuMDkzIDEuMTM2LjI3NSAxLjkyOC42MTQgMi41OTRhNi41IDYuNSAwIDAgMCAyLjg0MSAyLjg0Yy42NjcuMzQgMS40NTguNTIyIDIuNTk0LjYxNSAxLjE0Mi4wOTQgMi41ODkuMDk0IDQuNTU3LjA5NGgxOS42YzEuOTY4IDAgMy40MTUgMCA0LjU1Ny0uMDk0IDEuMTM2LS4wOTMgMS45MjgtLjI3NSAyLjU5NC0uNjE0YTYuNDk5IDYuNDk5IDAgMCAwIDIuODQtMi44NDFjLjM0LS42NjYuNTIyLTEuNDU4LjYxNS0yLjU5NC4wOTQtMS4xNDIuMDk0LTIuNTg5LjA5NC00LjU1N1YxNC4yYzAtMS45NjggMC0zLjQxNS0uMDk0LTQuNTU3LS4wOTMtMS4xMzYtLjI3NS0xLjkyNy0uNjE0LTIuNTk0YTYuNSA2LjUgMCAwIDAtMi44NDEtMi44NGMtLjY2Ni0uMzQtMS40NTgtLjUyMi0yLjU5NC0uNjE1QzM3LjIxNSAzLjUgMzUuNzY4IDMuNSAzMy44IDMuNUgxNC4yYy0xLjk2OCAwLTMuNDE1IDAtNC41NTcuMDk0LTEuMTM2LjA5My0xLjkyNy4yNzUtMi41OTQuNjE0QTYuNSA2LjUgMCAwIDAgNC4yMSA3LjA1Yy0uMzQuNjY3LS41MjIgMS40NTgtLjYxNSAyLjU5NFptLjE2OS0yLjgyQzMgOC4zMTggMyAxMC4yOCAzIDE0LjJ2MTkuNmMwIDMuOTIgMCA1Ljg4Ljc2MyA3LjM3OGE3IDcgMCAwIDAgMy4wNiAzLjA1OUM4LjMxOCA0NSAxMC4yOCA0NSAxNC4yIDQ1aDE5LjZjMy45MiAwIDUuODggMCA3LjM3OC0uNzYzYTcgNyAwIDAgMCAzLjA1OS0zLjA2QzQ1IDM5LjY4MiA0NSAzNy43MiA0NSAzMy44VjE0LjJjMC0zLjkyIDAtNS44OC0uNzYzLTcuMzc4YTcgNyAwIDAgMC0zLjA2LTMuMDU5QzM5LjY4MiAzIDM3LjcyIDMgMzMuOCAzSDE0LjJjLTMuOTIgMC01Ljg4IDAtNy4zNzguNzYzYTcgNyAwIDAgMC0zLjA1OSAzLjA2WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41ODUgOS43MTJDNC41MDEgMTAuNzQ2IDQuNSAxMi4wNjMgNC41IDEzLjl2MjAuMmMwIDEuODM3IDAgMy4xNTQuMDg1IDQuMTg4LjA4NCAxLjAyMi4yNDQgMS42NzguNTE0IDIuMjA5QTUuNSA1LjUgMCAwIDAgNy41MDMgNDIuOWMuNTMuMjcgMS4xODcuNDMgMi4yMS41MTQgMS4wMzMuMDg0IDIuMzUuMDg1IDQuMTg3LjA4NWgyMC4yYzEuODM3IDAgMy4xNTQgMCA0LjE4OC0uMDg1IDEuMDIyLS4wODQgMS42NzgtLjI0NCAyLjIwOS0uNTE0YTUuNSA1LjUgMCAwIDAgMi40MDQtMi40MDRjLjI3LS41My40My0xLjE4Ny41MTQtMi4yMS4wODQtMS4wMzMuMDg1LTIuMzUuMDg1LTQuMTg3VjEzLjljMC0xLjgzNyAwLTMuMTU0LS4wODUtNC4xODgtLjA4NC0xLjAyMi0uMjQ0LTEuNjc4LS41MTQtMi4yMDlBNS41IDUuNSAwIDAgMCA0MC40OTYgNS4xYy0uNTMtLjI3LTEuMTg3LS40My0yLjIxLS41MTQtMS4wMzMtLjA4NC0yLjM1LS4wODUtNC4xODctLjA4NUgxMy45Yy0xLjgzNyAwLTMuMTU0IDAtNC4xODguMDg1LTEuMDIyLjA4NC0xLjY3OC4yNDQtMi4yMDkuNTE0QTUuNSA1LjUgMCAwIDAgNS4xIDcuNTAzYy0uMjcuNTMtLjQzIDEuMTg3LS41MTQgMi4yMVpNNC4yMDggNy4wNUMzLjUgOC40NCAzLjUgMTAuMjYgMy41IDEzLjl2MjAuMmMwIDMuNjQgMCA1LjQ2LjcwOCA2Ljg1YTYuNSA2LjUgMCAwIDAgMi44NDEgMi44NDFjMS4zOS43MDkgMy4yMS43MDkgNi44NTEuNzA5aDIwLjJjMy42NCAwIDUuNDYgMCA2Ljg1LS43MDlhNi40OTkgNi40OTkgMCAwIDAgMi44NDEtMi44NGMuNzA5LTEuMzkuNzA5LTMuMjEuNzA5LTYuODUxVjEzLjljMC0zLjY0IDAtNS40Ni0uNzA5LTYuODVhNi41IDYuNSAwIDAgMC0yLjg0LTIuODQyQzM5LjU2IDMuNSAzNy43NCAzLjUgMzQuMSAzLjVIMTMuOWMtMy42NCAwLTUuNDYgMC02Ljg1LjcwOEE2LjUgNi41IDAgMCAwIDQuMjA3IDcuMDVaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIHN0eWxlPSJtaXgtYmxlbmQtbW9kZTpvdmVybGF5Ii8+PHBhdGggZmlsbD0idXJsKCNlKSIgZD0iTTE4IDExLjM0N2MtNC43MyAyLjI0Ny04IDcuMDY4LTggMTIuNjUzIDAgNS41ODUgMy4yNyAxMC40MDYgOCAxMi42NTNWMjMuOTA4YzAtLjMgMC0uNTY1LjA0Ny0uODI5LjA0LS4yMzIuMTEtLjQ1OC4yMDQtLjY3NC4xMDctLjI0NS4yNTQtLjQ2NS40Mi0uNzE1bC45MDUtMS4zNTdhNi44NiA2Ljg2IDAgMCAwIC4yMTItLjMyN0wxOS43OSAyMGwtLjAwMy0uMDA2YTYuODYgNi44NiAwIDAgMC0uMjEyLS4zMjdsLS45MDQtMS4zNTdjLS4xNjctLjI1LS4zMTQtLjQ3LS40MjEtLjcxNWEyLjk5NCAyLjk5NCAwIDAgMS0uMjA0LS42NzRDMTggMTYuNjU3IDE4IDE2LjM5MiAxOCAxNi4wOTJ2LTQuNzQ1WiIvPjxwYXRoIGZpbGw9InVybCgjZikiIGQ9Ik0zMCAzNi42NTNjNC43My0yLjI0NyA4LTcuMDY4IDgtMTIuNjUzIDAtNS41ODUtMy4yNy0xMC40MDYtOC0xMi42NTN2MTIuNzQ1YzAgLjMgMCAuNTY1LS4wNDcuODI5LS4wNC4yMzItLjExLjQ1OC0uMjA0LjY3NC0uMTA3LjI0NS0uMjU0LjQ2NS0uNDIuNzE1bC0uOTA1IDEuMzU3YTYuODYgNi44NiAwIDAgMC0uMjEyLjMyN0wyOC4yMSAyOGwuMDAzLjAwNmMuMDM5LjA2Ny4wOTguMTU2LjIxMi4zMjdsLjkwNCAxLjM1N2MuMTY3LjI1LjMxNC40Ny40MjEuNzE1LjA5NS4yMTYuMTYzLjQ0Mi4yMDQuNjc0LjA0Ny4yNjQuMDQ3LjUyOS4wNDcuODI5djQuNzQ1WiIvPjxwYXRoIGZpbGw9IiNmZmYiIGZpbGwtb3BhY2l0eT0iLjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTIwLjA5MiAzOS43ODJhMiAyIDAgMCAxLS44NzQtLjg3NEMxOSAzOC40OCAxOSAzNy45MiAxOSAzNi44VjIzLjk2OWMwLS4zNiAwLS41NC4wMzEtLjcxNC4wMjgtLjE1NS4wNzMtLjMwNi4xMzYtLjQ1LjA3LS4xNjIuMTctLjMxMS4zNy0uNjExbC44NzEtMS4zMDZjLjIxNC0uMzIxLjMyMS0uNDgyLjM2My0uNjU1YTEgMSAwIDAgMCAwLS40NjZjLS4wNDItLjE3My0uMTQ5LS4zMzQtLjM2My0uNjU0bC0uODctMS4zMDdjLS4yLS4zLS4zLS40NS0uMzctLjYxMWExLjk5OCAxLjk5OCAwIDAgMS0uMTM3LS40NWMtLjAzLS4xNzQtLjAzLS4zNTQtLjAzLS43MTRWMTEuMmMwLTEuMTIgMC0xLjY4LjIxNy0yLjEwOGEyIDIgMCAwIDEgLjg3NC0uODc0QzIwLjUyIDggMjEuMDggOCAyMi4yIDhoMy42YzEuMTIgMCAxLjY4IDAgMi4xMDguMjE4YTIgMiAwIDAgMSAuODc0Ljg3NEMyOSA5LjUyIDI5IDEwLjA4IDI5IDExLjJ2MTIuODMxYzAgLjM2IDAgLjU0LS4wMzEuNzE0YTEuOTk4IDEuOTk4IDAgMCAxLS4xMzYuNDVjLS4wNy4xNjItLjE3LjMxMS0uMzcuNjExbC0uODcxIDEuMzA2Yy0uMjE0LjMyMS0uMzIxLjQ4Mi0uMzYzLjY1NWExIDEgMCAwIDAgMCAuNDY2Yy4wNDIuMTczLjE0OS4zMzQuMzYzLjY1NGwuODcgMS4zMDdjLjIuMy4zLjQ1LjM3MS42MTEuMDYzLjE0NC4xMDkuMjk1LjEzNi40NS4wMzEuMTc0LjAzMS4zNTQuMDMxLjcxNFYzNi44YzAgMS4xMiAwIDEuNjgtLjIxOCAyLjEwOGEyIDIgMCAwIDEtLjg3NC44NzRDMjcuNDggNDAgMjYuOTIgNDAgMjUuOCA0MGgtMy42Yy0xLjEyIDAtMS42OCAwLTIuMTA4LS4yMThaTTE5Ljc5MSAyMGwtLjAwMy0uMDA2YTYuODYgNi44NiAwIDAgMC0uMjEyLS4zMjdsLS44Ny0xLjMwNi0uMDM0LS4wNWMtLjE2Ny0uMjUtLjMxNC0uNDcxLS40MjEtLjcxNmEzIDMgMCAwIDEtLjIwNC0uNjc0QzE4IDE2LjY1NyAxOCAxNi4zOTIgMTggMTYuMDkydi00LjkzYzAtLjUyOCAwLS45ODIuMDMtMS4zNTcuMDMzLS4zOTUuMTA0LS43ODkuMjk3LTEuMTY3YTMgMyAwIDAgMSAxLjMxMS0xLjMxMWMuMzc4LS4xOTMuNzcyLS4yNjQgMS4xNjctLjI5NkMyMS4xOCA3IDIxLjYzNSA3IDIyLjE2MiA3aDMuNjc3Yy41MjcgMCAuOTgyIDAgMS4zNTYuMDMuMzk1LjAzMy43ODkuMTA0IDEuMTY3LjI5N2EzIDMgMCAwIDEgMS4zMTEgMS4zMTFjLjE5My4zNzguMjY0Ljc3Mi4yOTcgMS4xNjcuMDMuMzc1LjAzLjgzLjAzIDEuMzU3djEyLjkzYzAgLjMgMCAuNTY1LS4wNDcuODI5YTMgMyAwIDAgMS0uMjAzLjY3NGMtLjEwOC4yNDUtLjI1NS40NjUtLjQyMi43MTUtLjAxLjAxNy0uMDIyLjAzNC0uMDMzLjA1bC0uODcxIDEuMzA3YTYuODYgNi44NiAwIDAgMC0uMjExLjMyN2wtLjAwNC4wMDYuMDA0LjAwNmMuMDM4LjA2Ny4wOTcuMTU2LjIxLjMyN2wuODcyIDEuMzA2LjAzMy4wNWMuMTY3LjI1LjMxNC40NzEuNDIyLjcxNmEzIDMgMCAwIDEgLjIwMy42NzRjLjA0Ny4yNjQuMDQ3LjUyOS4wNDcuODI5djQuOTNjMCAuNTI4IDAgLjk4My0uMDMgMS4zNTctLjAzMy4zOTUtLjEwNC43ODktLjI5NyAxLjE2N2EzIDMgMCAwIDEtMS4zMTEgMS4zMTFjLS4zNzguMTkzLS43NzIuMjY0LTEuMTY3LjI5Ni0uMzc1LjAzMS0uODMuMDMxLTEuMzU2LjAzMWgtMy42NzdjLS41MjggMC0uOTgyIDAtMS4zNTctLjAzLS4zOTUtLjAzMy0uNzg4LS4xMDQtMS4xNjctLjI5N2EzIDMgMCAwIDEtMS4zMTEtMS4zMTFjLS4xOTMtLjM3OC0uMjY0LS43NzItLjI5Ni0xLjE2N2ExNy4yMyAxNy4yMyAwIDAgMS0uMDMtMS4zNTZ2LTEyLjg3TDE4IDIzLjkwOGMwLS4zIDAtLjU2NS4wNDctLjgyOWEzIDMgMCAwIDEgLjIwNC0uNjc0Yy4xMDctLjI0NS4yNTQtLjQ2NS40Mi0uNzE1bC4wMzQtLjA1Ljg3MS0xLjMwN2E2Ljg2IDYuODYgMCAwIDAgLjIxMi0uMzI3TDE5Ljc5IDIwWiIgY2xpcC1ydWxlPSJldmVub2RkIiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6b3ZlcmxheSIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjciIGQ9Ik0xOSAxMS4yYzAtMS4xMiAwLTEuNjguMjE4LTIuMTA4YTIgMiAwIDAgMSAuODc0LS44NzRDMjAuNTIgOCAyMS4wOCA4IDIyLjIgOGgzLjZjMS4xMiAwIDEuNjggMCAyLjEwOC4yMThhMiAyIDAgMCAxIC44NzQuODc0QzI5IDkuNTIgMjkgMTAuMDggMjkgMTEuMnYxMi44MzFjMCAuMzYgMCAuNTQtLjAzMS43MTRhMi4wMDMgMi4wMDMgMCAwIDEtLjEzNi40NWMtLjA3LjE2Mi0uMTcuMzExLS4zNy42MTFsLS44NzEgMS4zMDZjLS4yMTQuMzIxLS4zMjEuNDgyLS4zNjMuNjU1YTEgMSAwIDAgMCAwIC40NjZjLjA0Mi4xNzMuMTQ5LjMzNC4zNjMuNjU0bC44NyAxLjMwN2MuMi4zLjMuNDUuMzcxLjYxMS4wNjMuMTQ0LjEwOC4yOTUuMTM2LjQ1LjAzMS4xNzQuMDMxLjM1NC4wMzEuNzE0VjM2LjhjMCAxLjEyIDAgMS42OC0uMjE4IDIuMTA4YTIgMiAwIDAgMS0uODc0Ljg3NEMyNy40OCA0MCAyNi45MiA0MCAyNS44IDQwaC0zLjZjLTEuMTIgMC0xLjY4IDAtMi4xMDgtLjIxOGEyIDIgMCAwIDEtLjg3NC0uODc0QzE5IDM4LjQ4IDE5IDM3LjkyIDE5IDM2LjhWMjMuOTY5YzAtLjM2IDAtLjU0LjAzMS0uNzE0LjAyOC0uMTU1LjA3My0uMzA2LjEzNi0uNDUuMDctLjE2Mi4xNy0uMzExLjM3LS42MTFsLjg3MS0xLjMwNmMuMjE0LS4zMjEuMzIxLS40ODIuMzYzLS42NTVhMSAxIDAgMCAwIDAtLjQ2NmMtLjA0Mi0uMTczLS4xNDktLjMzNC0uMzYzLS42NTRsLS44Ny0xLjMwN2MtLjItLjMtLjMtLjQ1LS4zNzEtLjYxMWEyLjAwMyAyLjAwMyAwIDAgMS0uMTM2LS40NUMxOSAxNi41NzEgMTkgMTYuMzkxIDE5IDE2LjAzMVYxMS4yWiIvPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9IjI0IiB4Mj0iMjQiIHkxPSIwIiB5Mj0iNDgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjMTc0Mjk5Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDAxRTU5Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgxPSIyNCIgeDI9IjI0IiB5MT0iMCIgeTI9IjQ4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iI0QyRDhFNCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0MyQzlENiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJlIiB4MT0iMjQiIHgyPSIyNCIgeTE9IjEwIiB5Mj0iMzgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLW9wYWNpdHk9Ii4xMiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1vcGFjaXR5PSIuMDQiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZiIgeDE9IjI0IiB4Mj0iMjQiIHkxPSIxMCIgeTI9IjM4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1vcGFjaXR5PSIuMTIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3Atb3BhY2l0eT0iLjA0Ii8+PC9saW5lYXJHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImMiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSgtNDAuMDc3IDY5LjgxNSA0OC42NjUpIHNjYWxlKDgyLjkwNDgpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMjc2IiBzdG9wLWNvbG9yPSIjMjBGRjREIi8+PHN0b3Agb2Zmc2V0PSIuNDY0IiBzdG9wLWNvbG9yPSIjMTQ5OUZGIi8+PHN0b3Agb2Zmc2V0PSIuNzU1IiBzdG9wLWNvbG9yPSIjRkY2RkM2Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjQkM2N0ZGIi8+PC9yYWRpYWxHcmFkaWVudD48cmFkaWFsR3JhZGllbnQgaWQ9ImQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSg0NSAyLjUyIC02LjA4Mikgc2NhbGUoNjguNjc3NykiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSJyZWQiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMEEzRkYiLz48L3JhZGlhbEdyYWRpZW50PjwvZGVmcz48L3N2Zz4=";
const $$15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: login_default
}, Symbol.toStringTag, { value: "Module" }));
var assets_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+PHBhdGggZmlsbD0idXJsKCNhKSIgZD0iTTEuMDkgNS40NkMwIDcuNiAwIDEwLjQgMCAxNnYxNmMwIDUuNiAwIDguNCAxLjA5IDEwLjU0YTEwIDEwIDAgMCAwIDQuMzcgNC4zN0M3LjYgNDggMTAuNCA0OCAxNiA0OGgxNmMxLjc1MiAwIDMuMjMgMCA0LjUtLjAzMyAwLTEuMzYyIDAtMi4wNDQuMDY2LTIuNjE2YTEwIDEwIDAgMCAxIDguNzg1LTguNzg1Yy41NzItLjA2NiAxLjI1NC0uMDY2IDIuNjE2LS4wNjZDNDggMzUuMjMgNDggMzMuNzUyIDQ4IDMyVjE2YzAtNS42IDAtOC40LTEuMDktMTAuNTRhMTAgMTAgMCAwIDAtNC4zNy00LjM3QzQwLjQgMCAzNy42IDAgMzIgMEgxNkMxMC40IDAgNy42IDAgNS40NiAxLjA5YTEwIDEwIDAgMCAwLTQuMzcgNC4zN1oiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMS4wOSA1LjQ2QzAgNy42IDAgMTAuNCAwIDE2djE2YzAgNS42IDAgOC40IDEuMDkgMTAuNTRhMTAgMTAgMCAwIDAgNC4zNyA0LjM3QzcuNiA0OCAxMC40IDQ4IDE2IDQ4aDE2YzEuNzUyIDAgMy4yMyAwIDQuNS0uMDMzIDAtMS4zNjIgMC0yLjA0NC4wNjYtMi42MTZhMTAgMTAgMCAwIDEgOC43ODUtOC43ODVjLjU3Mi0uMDY2IDEuMjU0LS4wNjYgMi42MTYtLjA2NkM0OCAzNS4yMyA0OCAzMy43NTIgNDggMzJWMTZjMC01LjYgMC04LjQtMS4wOS0xMC41NGExMCAxMCAwIDAgMC00LjM3LTQuMzdDNDAuNCAwIDM3LjYgMCAzMiAwSDE2QzEwLjQgMCA3LjYgMCA1LjQ2IDEuMDlhMTAgMTAgMCAwIDAtNC4zNyA0LjM3WiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjA0IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zNS41IDM1LjVoMTEuNDg2QzQ3IDM0LjQ3NSA0NyAzMy4zMiA0NyAzMlYxNmMwLTIuODE3IDAtNC44Ny0uMTMzLTYuNDg3LS4xMzEtMS42MDUtLjM4Ny0yLjY5NC0uODQ4LTMuNTk5YTkgOSAwIDAgMC0zLjkzMy0zLjkzM2MtLjkwNS0uNDYxLTEuOTk0LS43MTctMy42LS44NDhDMzYuODcgMSAzNC44MTYgMSAzMiAxSDE2Yy0yLjgxNyAwLTQuODcgMC02LjQ4Ny4xMzMtMS42MDUuMTMxLTIuNjk0LjM4Ny0zLjU5OS44NDhhOSA5IDAgMCAwLTMuOTMzIDMuOTMzYy0uNDYxLjkwNS0uNzE3IDEuOTk0LS44NDggMy42QzEgMTEuMTMgMSAxMy4xODMgMSAxNnYxNmMwIDIuODE3IDAgNC44Ny4xMzMgNi40ODYuMTMxIDEuNjA2LjM4NyAyLjY5NS44NDggMy42YTkgOSAwIDAgMCAzLjkzMyAzLjkzM2MuOTA1LjQ2MSAxLjk5NC43MTcgMy42Ljg0OEMxMS4xMyA0NyAxMy4xODMgNDcgMTYgNDdoMTZjMS4zMiAwIDIuNDc1IDAgMy41LS4wMTRWMzUuNVptMSAxMi40NjdDMzUuMjMgNDggMzMuNzUyIDQ4IDMyIDQ4SDE2Yy01LjYgMC04LjQgMC0xMC41NC0xLjA5YTEwIDEwIDAgMCAxLTQuMzctNC4zN0MwIDQwLjQgMCAzNy42IDAgMzJWMTZjMC01LjYgMC04LjQgMS4wOS0xMC41NGExMCAxMCAwIDAgMSA0LjM3LTQuMzdDNy42IDAgMTAuNCAwIDE2IDBoMTZjNS42IDAgOC40IDAgMTAuNTQgMS4wOWExMCAxMCAwIDAgMSA0LjM3IDQuMzdDNDggNy42IDQ4IDEwLjQgNDggMTZ2MTZjMCAxLjc1MiAwIDMuMjMtLjAzMyA0LjVIMzYuNXYxMS40NjdaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii44IiBkPSJNMyAxNC4yYzAtMy45MiAwLTUuODguNzYzLTcuMzc4YTcgNyAwIDAgMSAzLjA2LTMuMDU5QzguMzE4IDMgMTAuMjggMyAxNC4yIDNoMTkuNmMzLjkyIDAgNS44OCAwIDcuMzc4Ljc2M2E3IDcgMCAwIDEgMy4wNTkgMy4wNkM0NSA4LjMxOCA0NSAxMC4yOCA0NSAxNC4ydjE5LjZjMCAzLjkyIDAgNS44OC0uNzYzIDcuMzc4YTcgNyAwIDAgMS0zLjA2IDMuMDU5QzM5LjY4MiA0NSAzNy43MiA0NSAzMy44IDQ1SDE0LjJjLTMuOTIgMC01Ljg4IDAtNy4zNzgtLjc2M2E3IDcgMCAwIDEtMy4wNTktMy4wNkMzIDM5LjY4MiAzIDM3LjcyIDMgMzMuOFYxNC4yWiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTMzLjggMy41SDE0LjJjLTEuOTY4IDAtMy40MTUgMC00LjU1Ny4wOTQtMS4xMzYuMDkzLTEuOTI3LjI3NS0yLjU5NC42MTRBNi41IDYuNSAwIDAgMCA0LjIxIDcuMDVjLS4zNC42NjctLjUyMiAxLjQ1OC0uNjE1IDIuNTk0QzMuNSAxMC43ODUgMy41IDEyLjIzMiAzLjUgMTQuMnYxOS42YzAgMS45NjggMCAzLjQxNS4wOTQgNC41NTcuMDkzIDEuMTM2LjI3NSAxLjkyOC42MTQgMi41OTRhNi41IDYuNSAwIDAgMCAyLjg0MSAyLjg0Yy42NjcuMzQgMS40NTguNTIyIDIuNTk0LjYxNSAxLjE0Mi4wOTQgMi41ODkuMDk0IDQuNTU3LjA5NGgxOS42YzEuOTY4IDAgMy40MTUgMCA0LjU1Ny0uMDk0IDEuMTM2LS4wOTMgMS45MjgtLjI3NSAyLjU5NC0uNjE0YTYuNDk5IDYuNDk5IDAgMCAwIDIuODQtMi44NDFjLjM0LS42NjYuNTIyLTEuNDU4LjYxNS0yLjU5NC4wOTQtMS4xNDIuMDk0LTIuNTg5LjA5NC00LjU1N1YxNC4yYzAtMS45NjggMC0zLjQxNS0uMDk0LTQuNTU3LS4wOTMtMS4xMzYtLjI3NS0xLjkyNy0uNjE0LTIuNTk0YTYuNSA2LjUgMCAwIDAtMi44NDEtMi44NGMtLjY2Ni0uMzQtMS40NTgtLjUyMi0yLjU5NC0uNjE1QzM3LjIxNSAzLjUgMzUuNzY4IDMuNSAzMy44IDMuNVpNMy43NjMgNi44MjJDMyA4LjMyIDMgMTAuMjggMyAxNC4ydjE5LjZjMCAzLjkyIDAgNS44OC43NjMgNy4zNzhhNyA3IDAgMCAwIDMuMDYgMy4wNTlDOC4zMTggNDUgMTAuMjggNDUgMTQuMiA0NWgxOS42YzMuOTIgMCA1Ljg4IDAgNy4zNzgtLjc2M2E3IDcgMCAwIDAgMy4wNTktMy4wNkM0NSAzOS42ODIgNDUgMzcuNzIgNDUgMzMuOFYxNC4yYzAtMy45MiAwLTUuODgtLjc2My03LjM3OGE3IDcgMCAwIDAtMy4wNi0zLjA1OUMzOS42ODIgMyAzNy43MiAzIDMzLjggM0gxNC4yYy0zLjkyIDAtNS44OCAwLTcuMzc4Ljc2M2E3IDcgMCAwIDAtMy4wNTkgMy4wNloiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiNERkQ3RDUiIGQ9Ik0yNSAxM2MwLTIuOCAwLTQuMi41NDUtNS4yN2E1IDUgMCAwIDEgMi4xODUtMi4xODVDMjguOCA1IDMwLjIgNSAzMyA1aDJjMi44IDAgNC4yIDAgNS4yNy41NDVhNSA1IDAgMCAxIDIuMTg1IDIuMTg1QzQzIDguOCA0MyAxMC4yIDQzIDEzdjJjMCAyLjggMCA0LjItLjU0NSA1LjI3YTUgNSAwIDAgMS0yLjE4NSAyLjE4NUMzOS4yIDIzIDM3LjggMjMgMzUgMjNoLTJjLTIuOCAwLTQuMiAwLTUuMjctLjU0NWE1IDUgMCAwIDEtMi4xODUtMi4xODVDMjUgMTkuMiAyNSAxNy44IDI1IDE1di0yWiIvPjxwYXRoIGZpbGw9IiNFMUQ3RDUiIGQ9Ik0zOCA1aC04YTUgNSAwIDAgMC01IDV2OGE1IDUgMCAwIDAgNSA1aDhhNSA1IDAgMCAwIDUtNXYtOGE1IDUgMCAwIDAtNS01WiIvPjxwYXRoIGZpbGw9IiNEMjIyMDkiIGQ9Ik0zNy45MzggMTYuODEzaC03Ljg3NnYuNTYyaDcuODc1di0uNTYzWm0wIC41NjJoLTcuODc2di41NjNoNy44NzV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0QyMjIwOSIgZD0iTTM3LjkzOCAxNy45MzhoLTcuODc2di41NjJoNy44NzV2LS41NjNabTAgLjU2MmgtNy44NzZ2LjU2M2g3Ljg3NVYxOC41WiIvPjxwYXRoIGZpbGw9IiNEMjIyMDkiIGQ9Ik0zMS4xODggMTkuMDYzaC0xLjEyNXYuNTYyaDEuMTI1di0uNTYzWm02Ljc1IDBIMzEuNzV2LjU2Mmg2LjE4OHYtLjU2M1ptLTYuNzUuNTYyaC0xLjEyNXYuNTYzaDEuMTI1di0uNTYzWm02Ljc1IDBIMzEuNzV2LjU2M2g2LjE4OHYtLjU2M1oiLz48cGF0aCBmaWxsPSIjRDIyMjA5IiBkPSJNMzEuMTg4IDIwLjE4OGgtMS4xMjV2LjU2MmgxLjEyNXYtLjU2M1ptNi43NSAwSDMxLjc1di41NjJoNi4xODh2LS41NjNabS02Ljc1LjU2MmgtMS4xMjV2LjU2M2gxLjEyNXYtLjU2M1ptNi43NSAwSDMxLjc1di41NjNoNi4xODh2LS41NjNaIi8+PHBhdGggZmlsbD0iI0QyMjIwOSIgZD0iTTMxLjE4OCAyMS4zMTNoLTEuMTI1di41NjJoMS4xMjV2LS41NjNabTYuNzUgMEgzMS43NXYuNTYyaDYuMTg4di0uNTYzWm0tNi43NS41NjJoLTEuMTI1di41NjNoMS4xMjV2LS41NjNabTYuNzUgMEgzMS43NXYuNTYzaDYuMTg4di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNEMjIyMDkiIGQ9Ik0zMS4xODggMjIuNDM4aC0xLjEyNVYyM2gxLjEyNXYtLjU2M1ptNi43NSAwSDMxLjc1VjIzaDYuMTg4di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0zMi44NzUgMTcuOTM4aC0uNTYzdi41NjJoLjU2M3YtLjU2M1ptMi4yNSAwSDM0di41NjJoMS4xMjV2LS41NjNabTEuMTI1IDBoLS41NjN2LjU2MmguNTYzdi0uNTYzWm0tMy4zNzUuNTYyaC0uNTYzdi41NjNoLjU2M1YxOC41Wm0yLjI1IDBIMzR2LjU2M2gxLjEyNVYxOC41Wm0xLjEyNSAwaC0uNTYzdi41NjNoLjU2M1YxOC41WiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0zMy40MzggMTkuMDYzaC0xLjEyNnYuNTYyaDEuMTI2di0uNTYzWm0xLjY4NyAwSDM0di41NjJoMS4xMjV2LS41NjNabTEuNjg4IDBoLTEuMTI2di41NjJoMS4xMjZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMzLjQzOCA4LjM3NWgtLjU2M3YuNTYzaC41NjN2LS41NjNabTEuNjg3IDBIMzR2LjU2M2gxLjEyNXYtLjU2M1oiLz48cGF0aCBmaWxsPSIjRDRBMDE1IiBkPSJNMzEuNzUgOC45MzhoLTEuNjg4VjkuNWgxLjY4OHYtLjU2M1oiLz48cGF0aCBmaWxsPSIjQzE2NzEwIiBkPSJNMzUuNjg4IDguOTM4aC0zLjM3NlY5LjVoMy4zNzZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM3LjkzOCA4LjkzOEgzNi4yNVY5LjVoMS42ODh2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMwLjA2MyA5LjVoLTEuMTI1di41NjNoMS4xMjVWOS41WiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zMS43NSA5LjVoLTEuNjg4di41NjNoMS42ODhWOS41WiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zNS4xMjUgOS41SDMxLjc1di41NjNoMy4zNzVWOS41WiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNy45MzggOS41SDM2LjI1di41NjNoMS42ODhWOS41WiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTAuMDYzaC0xLjEyNXYuNTYyaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNCAxMC4wNjNoLTMuOTM4di41NjJIMzR2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTM0LjU2MyAxMC4wNjNIMzR2LjU2MmguNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNy45MzggMTAuMDYzaC0zLjM3NnYuNTYyaDMuMzc2di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTAuNjI1aC0xLjY4OHYuNTYzaDEuNjg4di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zMy40MzggMTAuNjI1aC0zLjM3NnYuNTYzaDMuMzc1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNGRkU5MzkiIGQ9Ik0zNS4xMjUgMTAuNjI1aC0xLjY4OHYuNTYzaDEuNjg4di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNy45MzggMTAuNjI1aC0yLjgxM3YuNTYzaDIuODEzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTEuMTg4aC0xLjEyNXYuNTYyaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNCAxMS4xODhoLTMuOTM4di41NjJIMzR2LS41NjNaIi8+PHBhdGggZmlsbD0iI0ZGRTkzOSIgZD0iTTM0LjU2MyAxMS4xODhIMzR2LjU2MmguNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNy45MzggMTEuMTg4aC0zLjM3NnYuNTYyaDMuMzc2di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTEuNzVoLTEuMTI1di41NjNoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM0IDExLjc1aC0zLjkzOHYuNTYzSDM0di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNGRkU5MzkiIGQ9Ik0zNC41NjMgMTEuNzVIMzR2LjU2M2guNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNy45MzggMTEuNzVoLTMuMzc2di41NjNoMy4zNzZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMwLjA2MyAxMi4zMTNoLTEuNjg4di41NjJoMS42ODh2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM0IDEyLjMxM2gtMy45Mzh2LjU2MkgzNHYtLjU2M1oiLz48cGF0aCBmaWxsPSIjRkZFOTM5IiBkPSJNMzQuNTYzIDEyLjMxM0gzNHYuNTYyaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM3LjkzOCAxMi4zMTNoLTMuMzc2di41NjJoMy4zNzZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMwLjA2MyAxMi44NzVoLTEuMTI1di41NjNoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM0IDEyLjg3NWgtMy45Mzh2LjU2M0gzNHYtLjU2M1oiLz48cGF0aCBmaWxsPSIjRkZFOTM5IiBkPSJNMzQuNTYzIDEyLjg3NUgzNHYuNTYzaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM3LjkzOCAxMi44NzVoLTMuMzc2di41NjNoMy4zNzZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMwLjA2MyAxMy40MzhoLTEuMTI1VjE0aDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNENEEwMTUiIGQ9Ik0zNCAxMy40MzhoLTMuOTM4VjE0SDM0di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNGRkU5MzkiIGQ9Ik0zNC41NjMgMTMuNDM4SDM0VjE0aC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI0Q0QTAxNSIgZD0iTTM3LjkzOCAxMy40MzhoLTMuMzc2VjE0aDMuMzc2di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTRoLTEuNjg4di41NjNoMS42ODhWMTRaIi8+PHBhdGggZmlsbD0iI0QwOEIxMSIgZD0iTTQwLjE4OCAxNEgzMC4wNjJ2LjU2M2gxMC4xMjVWMTRaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMwLjA2MyAxNC41NjNoLTEuMTI1di41NjJoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0QwOEIxMSIgZD0iTTM3LjkzOCAxNC41NjNoLTcuODc2di41NjJoNy44NzV2LS41NjNaIi8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTM4LjUgMTQuNTYzaC0uNTYzdi41NjJoLjU2M3YtLjU2M1oiLz48cGF0aCBmaWxsPSIjRDA4QjExIiBkPSJNMzkuMDYzIDE0LjU2M0gzOC41di41NjJoLjU2M3YtLjU2M1oiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMzkuNjI1IDE0LjU2M2gtLjU2M3YuNTYyaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI0QwOEIxMSIgZD0iTTQwLjE4OCAxNC41NjNoLS41NjN2LjU2MmguNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTUuMTI1aC0xLjY4OHYuNTYzaDEuNjg4di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNEMDhCMTEiIGQ9Ik0zMS4xODggMTUuMTI1aC0xLjEyNXYuNTYzaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNGRkU5MzkiIGQ9Ik0zMS43NSAxNS4xMjVoLS41NjN2LjU2M2guNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0zMi4zMTMgMTUuMTI1aC0uNTYzdi41NjNoLjU2M3YtLjU2M1oiLz48cGF0aCBmaWxsPSIjRkZFOTM5IiBkPSJNMzIuODc1IDE1LjEyNWgtLjU2M3YuNTYzaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTMzLjQzOCAxNS4xMjVoLS41NjN2LjU2M2guNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNGRkU5MzkiIGQ9Ik0zNCAxNS4xMjVoLS41NjN2LjU2M0gzNHYtLjU2M1oiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMzQuNTYzIDE1LjEyNUgzNHYuNTYzaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI0ZGRTkzOSIgZD0iTTM1LjEyNSAxNS4xMjVoLS41NjN2LjU2M2guNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNEMDhCMTEiIGQ9Ik00MC4xODggMTUuMTI1aC01LjA2M3YuNTYzaDUuMDYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNDMTY3MTAiIGQ9Ik0zMC4wNjMgMTUuNjg4aC0yLjI1di41NjJoMi4yNXYtLjU2M1oiLz48cGF0aCBmaWxsPSIjRDA4QjExIiBkPSJNNDAuMTg4IDE1LjY4OEgzMC4wNjJ2LjU2MmgxMC4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0MxNjcxMCIgZD0iTTMwLjA2MyAxNi4yNWgtMS42ODh2LjU2M2gxLjY4OHYtLjU2M1oiLz48cGF0aCBmaWxsPSIjRDA4QjExIiBkPSJNNDAuMTg4IDE2LjI1SDMwLjA2MnYuNTYzaDEwLjEyNXYtLjU2M1oiLz48cGF0aCBmaWxsPSIjQzE2NzEwIiBkPSJNMjguOTM4IDE2LjgxM2gtLjU2M3YuNTYyaC41NjN2LS41NjNabTEuMTI1IDBIMjkuNXYuNTYyaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI0QwOEIxMSIgZD0iTTM3LjkzOCAxNi44MTNoLTcuODc2di41NjJoNy44NzV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0I5MTg1QyIgZD0iTTM0IDExLjE4OGgtMy4zNzV2LjU2MkgzNHYtLjU2M1ptMy45MzggMGgtMy4zNzZ2LjU2MmgzLjM3NnYtLjU2M1ptLTYuNzUuNTYyaC0uNTYzdi41NjNoLjU2M3YtLjU2M1oiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMzIuMzEzIDExLjc1aC0xLjEyNnYuNTYzaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0zMy40MzggMTEuNzVoLTEuMTI2di41NjNoMS4xMjZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0I5MTg1QyIgZD0iTTM0IDExLjc1aC0uNTYzdi41NjNIMzR2LS41NjNabTEuMTI1IDBoLS41NjN2LjU2M2guNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0zNi4yNSAxMS43NWgtMS4xMjV2LjU2M2gxLjEyNXYtLjU2M1oiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMzcuMzc1IDExLjc1SDM2LjI1di41NjNoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0I5MTg1QyIgZD0iTTM3LjkzOCAxMS43NWgtLjU2M3YuNTYzaC41NjN2LS41NjNabS02Ljc1LjU2M2gtMi4yNXYuNTYyaDIuMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTMyLjMxMyAxMi4zMTNoLTEuMTI2di41NjJoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTMzLjQzOCAxMi4zMTNoLTEuMTI2di41NjJoMS4xMjZ2LS41NjNaIi8+PHBhdGggZmlsbD0iI0I5MTg1QyIgZD0iTTM1LjEyNSAxMi4zMTNoLTEuNjg4di41NjJoMS42ODh2LS41NjNaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTM2LjI1IDEyLjMxM2gtMS4xMjV2LjU2MmgxLjEyNXYtLjU2M1oiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMzcuMzc1IDEyLjMxM0gzNi4yNXYuNTYyaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNCOTE4NUMiIGQ9Ik0zNy45MzggMTIuMzEzaC0uNTYzdi41NjJoLjU2M3YtLjU2M1ptLTguNDM4LjU2MmgtLjU2M3YuNTYzaC41NjN2LS41NjNabTEuNjg4IDBoLS41NjN2LjU2M2guNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0zMi4zMTMgMTIuODc1aC0xLjEyNnYuNTYzaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0zMy40MzggMTIuODc1aC0xLjEyNnYuNTYzaDEuMTI2di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNCOTE4NUMiIGQ9Ik0zNCAxMi44NzVoLS41NjN2LjU2M0gzNHYtLjU2M1ptMS4xMjUgMGgtLjU2M3YuNTYzaC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTM2LjI1IDEyLjg3NWgtMS4xMjV2LjU2M2gxLjEyNXYtLjU2M1oiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMzcuMzc1IDEyLjg3NUgzNi4yNXYuNTYzaDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiNCOTE4NUMiIGQ9Ik0zNy45MzggMTIuODc1aC0uNTYzdi41NjNoLjU2M3YtLjU2M1ptLTguNDM4LjU2M2gtLjU2M1YxNGguNTYzdi0uNTYzWm0xLjY4OCAwaC0uNTYzVjE0aC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTMyLjMxMyAxMy40MzhoLTEuMTI2VjE0aDEuMTI1di0uNTYzWiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0zMy40MzggMTMuNDM4aC0xLjEyNlYxNGgxLjEyNnYtLjU2M1oiLz48cGF0aCBmaWxsPSIjQjkxODVDIiBkPSJNMzQgMTMuNDM4aC0uNTYzVjE0SDM0di0uNTYzWm0xLjEyNSAwaC0uNTYzVjE0aC41NjN2LS41NjNaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTM2LjI1IDEzLjQzOGgtMS4xMjVWMTRoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTM3LjM3NSAxMy40MzhIMzYuMjVWMTRoMS4xMjV2LS41NjNaIi8+PHBhdGggZmlsbD0iI0I5MTg1QyIgZD0iTTM3LjkzOCAxMy40MzhoLS41NjNWMTRoLjU2M3YtLjU2M1pNMzQgMTRoLTMuMzc1di41NjNIMzRWMTRabTMuOTM4IDBoLTMuMzc2di41NjNoMy4zNzZWMTRaIi8+PHBhdGggZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuMyIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMzUgNS41aC0yYy0xLjQwOCAwLTIuNDM1IDAtMy4yNDMuMDY2LS44MDMuMDY2LTEuMzQ3LjE5NC0xLjguNDI0YTQuNSA0LjUgMCAwIDAtMS45NjYgMS45NjdjLS4yMzEuNDUzLS4zNTkuOTk3LS40MjQgMS44LS4wNjcuODA4LS4wNjcgMS44MzUtLjA2NyAzLjI0M3YyYzAgMS40MDggMCAyLjQzNS4wNjcgMy4yNDMuMDY1LjgwMy4xOTMgMS4zNDcuNDI0IDEuOGE0LjUgNC41IDAgMCAwIDEuOTY2IDEuOTY2Yy40NTMuMjMxLjk5Ny4zNTkgMS44LjQyNC44MDguMDY3IDEuODM1LjA2NyAzLjI0My4wNjdoMmMxLjQwOCAwIDIuNDM1IDAgMy4yNDMtLjA2Ny44MDMtLjA2NSAxLjM0Ny0uMTkzIDEuOC0uNDI0YTQuNSA0LjUgMCAwIDAgMS45NjctMS45NjZjLjIzLS40NTMuMzU4LS45OTcuNDI0LTEuOC4wNjYtLjgwOC4wNjYtMS44MzUuMDY2LTMuMjQzdi0yYzAtMS40MDggMC0yLjQzNS0uMDY2LTMuMjQzLS4wNjYtLjgwMy0uMTk0LTEuMzQ3LS40MjQtMS44YTQuNSA0LjUgMCAwIDAtMS45NjctMS45NjdjLS40NTMtLjIzLS45OTctLjM1OC0xLjgtLjQyNEMzNy40MzUgNS41IDM2LjQwOCA1LjUgMzUgNS41Wm0tOS40NTUgMi4yM0MyNSA4LjggMjUgMTAuMiAyNSAxM3YyYzAgMi44IDAgNC4yLjU0NSA1LjI3YTUgNSAwIDAgMCAyLjE4NSAyLjE4NUMyOC44IDIzIDMwLjIgMjMgMzMgMjNoMmMyLjggMCA0LjIgMCA1LjI3LS41NDVhNSA1IDAgMCAwIDIuMTg1LTIuMTg1QzQzIDE5LjIgNDMgMTcuOCA0MyAxNXYtMmMwLTIuOCAwLTQuMi0uNTQ1LTUuMjdhNSA1IDAgMCAwLTIuMTg1LTIuMTg1QzM5LjIgNSAzNy44IDUgMzUgNWgtMmMtMi44IDAtNC4yIDAtNS4yNy41NDVhNSA1IDAgMCAwLTIuMTg1IDIuMTg1WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzU2NENCRiIgZD0iTTUgMzNjMC0yLjggMC00LjIuNTQ1LTUuMjdhNSA1IDAgMCAxIDIuMTg1LTIuMTg1QzguOCAyNSAxMC4yIDI1IDEzIDI1aDJjMi44IDAgNC4yIDAgNS4yNy41NDVhNSA1IDAgMCAxIDIuMTg1IDIuMTg1QzIzIDI4LjggMjMgMzAuMiAyMyAzM3YyYzAgMi44IDAgNC4yLS41NDUgNS4yN2E1IDUgMCAwIDEtMi4xODUgMi4xODVDMTkuMiA0MyAxNy44IDQzIDE1IDQzaC0yYy0yLjggMC00LjIgMC01LjI3LS41NDVhNSA1IDAgMCAxLTIuMTg1LTIuMTg1QzUgMzkuMiA1IDM3LjggNSAzNXYtMloiLz48cGF0aCBmaWxsPSIjRkY2NkIzIiBkPSJNMTEuMTg4IDI2LjEyNWguNTYydjIuODEzaC41NjN2LTIuODEzaC41NjJWMjkuNWguNTYzdi0zLjM3NUgxNFYyOS41aC41NjN2LTMuMzc1aC41NjJ2Mi44MTNoLjU2M3YtMi44MTNoLjU2MnYyLjI1aC41NjN2LTEuNjg4aC41NjJ2Mi4yNWgtLjU2M3YuNTYzaC0uNTYydi41NjNoLTEuMTI1di41NjJoLTIuODEzdi0uNTYzaC0xLjEyNFYyOS41aC0uNTYzdi0uNTYzaC0uNTYzdi0yLjI1aC41NjN2MS42ODhoLjU2M3YtMi4yNVoiLz48cGF0aCBmaWxsPSIjQjNGRkNDIiBkPSJNMTMuNDM4IDMwLjYyNUgxNHYuNTYzaDEuMTI1djIuMjVoMS4xMjV2LS41NjNoLjU2M1YzNGgtMS42ODh2MS4xMjVoLS41NjN2MS4xMjVoLjU2M3Y1LjYyNWgtLjU2M3YtNS4wNjNIMTR2LS41NjJoLTEuNjg4di0xLjEyNWguNTYzdi41NjNIMTR2LTEuMTI2aC41NjNWMzEuNzVoLTEuMTI2di0xLjEyNVoiLz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii45IiBkPSJNMTYuMjUgMjYuMTI1aC41NjN2Mi4yNWgtLjU2M3YtMi4yNVptLTUuNjI1LjU2M2guNTYzdjEuNjg3aC0uNTYzdi0xLjY4OFoiLz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii45IiBkPSJNMTcuOTM4IDI2LjY4OGgtLjU2M3YyLjI1aC0uNTYzdi41NjJoLS41NjJ2LjU2M2guNTYzVjI5LjVoLjU2MnYtLjU2M2guNTYzdi0yLjI1Wm0tNi4xODgtLjU2M2guNTYzdjIuODEzaC0uNTYzdi0yLjgxM1ptMy45MzggMGgtLjU2M3YyLjgxM2guNTYzdi0yLjgxM1ptLTIuODEzIDBoLjU2M1YyOS41aC0uNTYzdi0zLjM3NVptMS42ODggMEgxNFYyOS41aC41NjN2LTMuMzc1Wm0uNTYyIDMuOTM4aC41NjN2LjU2MmgtLjU2M3YtLjU2M1ptLS41NjIuNTYySDE0di41NjNoLjU2M3YtLjU2M1ptLjU2Mi41NjNoLjU2M3YyLjI1aC0uNTYzdi0yLjI1Wm0yLjI1IDEuNjg3aC0uNTYzVjM0aC41NjN2LTEuMTI1Wk0xNS4xMjUgMzRoLjU2M3YxLjEyNWgtLjU2M1YzNFptMCAyLjI1di0xLjEyNWgtLjU2M3YxLjEyNWguNTYzWm0wIDB2NS42MjVoLjU2M1YzNi4yNWgtLjU2M1ptLTIuMjUtMS4xMjVoLjU2M3YuNTYzaC0uNTYzdi0uNTYzWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGZpbGwtb3BhY2l0eT0iLjEyIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNSAyNS41aC0yYy0xLjQwOCAwLTIuNDM1IDAtMy4yNDMuMDY3LS44MDMuMDY1LTEuMzQ3LjE5My0xLjguNDI0YTQuNSA0LjUgMCAwIDAtMS45NjcgMS45NjZjLS4yMy40NTMtLjM1OC45OTctLjQyNCAxLjhDNS41IDMwLjU2NSA1LjUgMzEuNTkyIDUuNSAzM3YyYzAgMS40MDggMCAyLjQzNS4wNjYgMy4yNDMuMDY2LjgwMy4xOTQgMS4zNDcuNDI0IDEuOGE0LjUgNC41IDAgMCAwIDEuOTY3IDEuOTY3Yy40NTMuMjMuOTk3LjM1OCAxLjguNDI0LjgwOC4wNjYgMS44MzUuMDY2IDMuMjQzLjA2NmgyYzEuNDA4IDAgMi40MzUgMCAzLjI0My0uMDY2LjgwMy0uMDY2IDEuMzQ3LS4xOTQgMS44LS40MjRhNC41IDQuNSAwIDAgMCAxLjk2Ni0xLjk2N2MuMjMxLS40NTMuMzU5LS45OTcuNDI0LTEuOC4wNjctLjgwOC4wNjctMS44MzUuMDY3LTMuMjQzdi0yYzAtMS40MDggMC0yLjQzNS0uMDY3LTMuMjQzLS4wNjUtLjgwMy0uMTkzLTEuMzQ3LS40MjQtMS44YTQuNSA0LjUgMCAwIDAtMS45NjYtMS45NjZjLS40NTMtLjIzMS0uOTk3LS4zNTktMS44LS40MjQtLjgwOC0uMDY3LTEuODM1LS4wNjctMy4yNDMtLjA2N1ptLTkuNDU1IDIuMjNDNSAyOC44IDUgMzAuMiA1IDMzdjJjMCAyLjggMCA0LjIuNTQ1IDUuMjdhNSA1IDAgMCAwIDIuMTg1IDIuMTg1QzguOCA0MyAxMC4yIDQzIDEzIDQzaDJjMi44IDAgNC4yIDAgNS4yNy0uNTQ1YTUgNSAwIDAgMCAyLjE4NS0yLjE4NUMyMyAzOS4yIDIzIDM3LjggMjMgMzV2LTJjMC0yLjggMC00LjItLjU0NS01LjI3YTUgNSAwIDAgMC0yLjE4NS0yLjE4NUMxOS4yIDI1IDE3LjggMjUgMTUgMjVoLTJjLTIuOCAwLTQuMiAwLTUuMjcuNTQ1YTUgNSAwIDAgMC0yLjE4NSAyLjE4NVoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMxNzJEOTkiIGQ9Ik01IDEzYzAtMi44IDAtNC4yLjU0NS01LjI3QTUgNSAwIDAgMSA3LjczIDUuNTQ1QzguOCA1IDEwLjIgNSAxMyA1aDJjMi44IDAgNC4yIDAgNS4yNy41NDVhNSA1IDAgMCAxIDIuMTg1IDIuMTg1QzIzIDguOCAyMyAxMC4yIDIzIDEzdjJjMCAyLjggMCA0LjItLjU0NSA1LjI3YTUgNSAwIDAgMS0yLjE4NSAyLjE4NUMxOS4yIDIzIDE3LjggMjMgMTUgMjNoLTJjLTIuOCAwLTQuMiAwLTUuMjctLjU0NWE1IDUgMCAwIDEtMi4xODUtMi4xODVDNSAxOS4yIDUgMTcuOCA1IDE1di0yWiIvPjxwYXRoIGZpbGw9IiMwMEEyRDgiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjMgMTMuMUg4LjZ2LjloMi43di0uOVptMCAuOWgxLjh2LjloLjl2MS44aC0uOXYtLjloLS45di0uOWgtLjlWMTRabTIuNyAyLjdoLjl2Mi43SDE0di0yLjdaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBmaWxsPSIjMDBERTZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMS4zIDEyLjJIOC42di45aDIuN3YtLjlabTAgLjloMS44di45aC0xLjh2LS45Wm0yLjcgMS44aC0uOVYxNGguOXYuOVptLjkgMS44SDE0di0xLjhoLjl2MS44Wm0wIDBoLjl2Mi43aC0uOXYtMi43WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iI0ZGRUIwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTEuMyAxMS4zSDguNnYuOWgyLjd2LS45Wm0wIC45aDEuOHYuOWgtMS44di0uOVpNMTQgMTRoLS45di0uOWguOXYuOVptLjkuOUgxNFYxNGguOXYuOVptLjkgMS44aC0uOXYtMS44aC45djEuOFptMCAwaC45djIuN2gtLjl2LTIuN1oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiNGQTAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjMgMTAuNEg4LjZ2LjloMi43di0uOVptMCAuOUgxNHYuOWguOXYuOWguOXYuOWguOXYxLjhoLjl2My42aC0uOXYtMi43aC0uOXYtMS44aC0uOVYxNEgxNHYtLjloLS45di0uOWgtMS44di0uOVoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiNERDNEMUMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjIgOS41SDguNnYuOWgyLjd2LjlIMTR2LjloLjl2LjloLjl2LjloLjl2MS44aC45djMuNmguOXYtMy42aC0uOVYxNGgtLjl2LS45aC0uOXYtLjloLS45di0uOUgxNHYtLjloLTEuOHYtLjlaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBmaWxsPSIjQzAzMDc4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi4yIDguNkg4LjZ2LjloMy42di0uOVptMCAuOUgxNHYuOWgtMS44di0uOVptNS40IDQuNWgtLjl2LS45aC0uOXYtLjloLS45di0uOUgxNHYtLjloMS44di45aC45di45aC45VjE0Wm0uOSAxLjhoLS45VjE0aC45djEuOFptMCAwaC45djMuNmgtLjl2LTMuNloiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiNmZmYiIGZpbGwtb3BhY2l0eT0iLjEyIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNSA1LjVoLTJjLTEuNDA4IDAtMi40MzUgMC0zLjI0My4wNjYtLjgwMy4wNjYtMS4zNDcuMTk0LTEuOC40MjRBNC41IDQuNSAwIDAgMCA1Ljk5IDcuOTU3Yy0uMjMuNDUzLS4zNTguOTk3LS40MjQgMS44QzUuNSAxMC41NjUgNS41IDExLjU5MiA1LjUgMTN2MmMwIDEuNDA4IDAgMi40MzUuMDY2IDMuMjQzLjA2Ni44MDMuMTk0IDEuMzQ3LjQyNCAxLjhhNC41IDQuNSAwIDAgMCAxLjk2NyAxLjk2NmMuNDUzLjIzMS45OTcuMzU5IDEuOC40MjQuODA4LjA2NyAxLjgzNS4wNjcgMy4yNDMuMDY3aDJjMS40MDggMCAyLjQzNSAwIDMuMjQzLS4wNjcuODAzLS4wNjUgMS4zNDctLjE5MyAxLjgtLjQyNGE0LjUgNC41IDAgMCAwIDEuOTY2LTEuOTY2Yy4yMzEtLjQ1My4zNTktLjk5Ny40MjQtMS44LjA2Ny0uODA4LjA2Ny0xLjgzNS4wNjctMy4yNDN2LTJjMC0xLjQwOCAwLTIuNDM1LS4wNjctMy4yNDMtLjA2NS0uODAzLS4xOTMtMS4zNDctLjQyNC0xLjhhNC41IDQuNSAwIDAgMC0xLjk2Ni0xLjk2N2MtLjQ1My0uMjMtLjk5Ny0uMzU4LTEuOC0uNDI0QzE3LjQzNSA1LjUgMTYuNDA4IDUuNSAxNSA1LjVaTTUuNTQ1IDcuNzNDNSA4LjggNSAxMC4yIDUgMTN2MmMwIDIuOCAwIDQuMi41NDUgNS4yN2E1IDUgMCAwIDAgMi4xODUgMi4xODVDOC44IDIzIDEwLjIgMjMgMTMgMjNoMmMyLjggMCA0LjIgMCA1LjI3LS41NDVhNSA1IDAgMCAwIDIuMTg1LTIuMTg1QzIzIDE5LjIgMjMgMTcuOCAyMyAxNXYtMmMwLTIuOCAwLTQuMi0uNTQ1LTUuMjdhNSA1IDAgMCAwLTIuMTg1LTIuMTg1QzE5LjIgNSAxNy44IDUgMTUgNWgtMmMtMi44IDAtNC4yIDAtNS4yNy41NDVBNSA1IDAgMCAwIDUuNTQ1IDcuNzNaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBmaWxsPSIjOTlCM0ZGIiBkPSJNNDggMzYuNUM0OCA0Mi44NTEgNDIuODUxIDQ4IDM2LjUgNDhTMjUgNDIuODUxIDI1IDM2LjUgMzAuMTQ5IDI1IDM2LjUgMjUgNDggMzAuMTQ5IDQ4IDM2LjVaIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMTIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTM2LjUgNDcuNWM2LjA3NSAwIDExLTQuOTI1IDExLTExcy00LjkyNS0xMS0xMS0xMS0xMSA0LjkyNS0xMSAxMSA0LjkyNSAxMSAxMSAxMVptMCAuNUM0Mi44NTEgNDggNDggNDIuODUxIDQ4IDM2LjVTNDIuODUxIDI1IDM2LjUgMjUgMjUgMzAuMTQ5IDI1IDM2LjUgMzAuMTQ5IDQ4IDM2LjUgNDhaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBmaWxsPSIjN0Y5MUVCIiBkPSJNNDYgMzYuNWE5LjUgOS41IDAgMSAxLTE5IDAgOS41IDkuNSAwIDAgMSAxOSAwWiIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjEyIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zNi41IDQ1LjVhOSA5IDAgMSAwIDAtMTggOSA5IDAgMCAwIDAgMThabTAgLjVhOS41IDkuNSAwIDEgMCAwLTE5IDkuNSA5LjUgMCAwIDAgMCAxOVoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiNmZmYiIGZpbGwtb3BhY2l0eT0iLjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTMxLjkxMiAzNy4wMzdhLjUuNSAwIDAgMS0uMTM5LS42NjVsNC4yOTgtNy4xM2EuNS41IDAgMCAxIC44NTYgMGw0LjI5NyA3LjEzYS41LjUgMCAwIDEtLjEzNy42NjQuNS41IDAgMCAxIC4xMTkuNjk4bC00LjMgNi4wNTVhLjUuNSAwIDAgMS0uODE1IDBsLTQuMjk3LTYuMDU1YS41LjUgMCAwIDEgLjExOC0uNjk3Wm0uMjkuNDA4IDQuMjk3IDIuNTM4IDQuMy0yLjUzOC00LjMgNi4wNTUtNC4yOTctNi4wNTVabTAtLjgxNSA0LjI5Ny03LjEzIDQuMjk3IDcuMTMtNC4yOTcgMi41NC00LjI5Ny0yLjU0WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNTUiIGQ9Ik0zNi40OTkgMjkuNXY5LjY3bDQuMjk3LTIuNTQtNC4yOTctNy4xM1oiLz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4zIiBkPSJtMzYuNDk5IDI5LjUtNC4yOTcgNy4xMyA0LjI5NyAyLjU0VjI5LjVaIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNTUiIGQ9Ik0zNi40OTkgMzkuOTgzVjQzLjVsNC4zLTYuMDU1LTQuMyAyLjUzOFoiLz48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4zIiBkPSJNMzYuNDk5IDQzLjV2LTMuNTE3bC00LjI5Ny0yLjUzOCA0LjI5NyA2LjA1NVoiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJtMzYuNDk5IDM5LjE3IDQuMjk3LTIuNTQtNC4yOTctMS45NTN2NC40OTNaIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNiIgZD0ibTMyLjIwMiAzNi42MyA0LjI5NyAyLjU0di00LjQ5M2wtNC4yOTcgMS45NTNaIi8+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMjQiIHgyPSIyNCIgeTE9IjAiIHkyPSI0OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiMxNzQyOTkiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDFFNTkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjI0IiB4Mj0iMjQiIHkxPSIwIiB5Mj0iNDgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRDJEOEU0Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjQzJDOUQ2Ii8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PC9zdmc+";
const $$14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: assets_default
}, Symbol.toStringTag, { value: "Module" }));
var polygon_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjgiIGhlaWdodD0iMjgiPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iQSIgeDE9Ii0xOC4yNzUlIiB4Mj0iODQuOTU5JSIgeTE9IjguMjE5JSIgeTI9IjcxLjM5MyUiPjxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiNhMjI5YzUiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiM3YjNmZTQiLz48L2xpbmVhckdyYWRpZW50PjxjaXJjbGUgaWQ9IkIiIGN4PSIxNCIgY3k9IjE0IiByPSIxNCIvPjwvZGVmcz48ZyBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxtYXNrIGlkPSJDIiBmaWxsPSIjZmZmIj48dXNlIHhsaW5rOmhyZWY9IiNCIi8+PC9tYXNrPjxnIGZpbGwtcnVsZT0ibm9uemVybyI+PHBhdGggZmlsbD0idXJsKCNBKSIgZD0iTS0xLjMyNi0xLjMyNmgzMC42NTF2MzAuNjUxSC0xLjMyNnoiIG1hc2s9InVybCgjQykiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMTguMDQ5IDE3LjAyMWwzLjk2LTIuMjg3YS42ODEuNjgxIDAgMCAwIC4zNC0uNTg5VjkuNTcyYS42ODMuNjgzIDAgMCAwLS4zNC0uNTlsLTMuOTYtMi4yODZhLjY4Mi42ODIgMCAwIDAtLjY4IDBsLTMuOTYgMi4yODdhLjY4Mi42ODIgMCAwIDAtLjM0LjU4OXY4LjE3M0wxMC4yOSAxOS4zNWwtMi43NzctMS42MDR2LTMuMjA3bDIuNzc3LTEuNjA0IDEuODMyIDEuMDU4VjExLjg0bC0xLjQ5Mi0uODYxYS42ODEuNjgxIDAgMCAwLS42OCAwbC0zLjk2IDIuMjg3YS42ODEuNjgxIDAgMCAwLS4zNC41ODl2NC41NzNjMCAuMjQyLjEzLjQ2OC4zNC41OWwzLjk2IDIuMjg2YS42OC42OCAwIDAgMCAuNjggMGwzLjk2LTIuMjg2YS42ODIuNjgyIDAgMCAwIC4zNC0uNTg5di04LjE3NGwuMDUtLjAyOCAyLjcyOC0xLjU3NSAyLjc3NyAxLjYwM3YzLjIwOGwtMi43NzcgMS42MDMtMS44My0xLjA1NnYyLjE1MWwxLjQ5Ljg2YS42OC42OCAwIDAgMCAuNjggMHoiLz48L2c+PC9nPjwvc3ZnPg==";
const $$13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: polygon_default
}, Symbol.toStringTag, { value: "Module" }));
var optimism_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjI4IiBoZWlnaHQ9IjI4IiBmaWxsPSIjRkYzMTMxIiByeD0iMTQiLz48cmVjdCB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9InVybCgjYSkiIGZpbGwtb3BhY2l0eT0iLjMiIHJ4PSIxNCIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik05LjIyIDE4LjM1YzIuNyAwIDQuODYtMi4yIDQuODYtNS4zOCAwLTIuMTktMS40Ny0zLjgtMy45OC0zLjgtMi43MiAwLTQuODUgMi4yLTQuODUgNS4zOCAwIDIuMiAxLjUgMy44IDMuOTcgMy44Wm0uODMtNy4zNWMxLjA2IDAgMS43NC44MSAxLjc0IDIuMSAwIDEuOS0xLjExIDMuNDItMi41MSAzLjQyLTEuMDYgMC0xLjc0LS44Mi0xLjc0LTIuMSAwLTEuODkgMS4xMS0zLjQyIDIuNS0zLjQyWm02LjM4LTEuNjgtMS44OCA4Ljg4aDIuMjZsLjU1LTIuNmgxLjQ3YzIuNDMgMCA0LjAxLTEuMzggNC4wMS0zLjYgMC0xLjYxLTEuMTctMi42OC0zLjEtMi42OGgtMy4zWm0xLjkgMS43NGguOTRjLjgzIDAgMS4zLjM4IDEuMyAxLjE0IDAgMS0uNjggMS43LTEuNzQgMS43aC0xLjExbC42LTIuODRaIi8+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCIgeDI9IjE0IiB5MT0iMCIgeTI9IjI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iI2ZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZmZiIgc3RvcC1vcGFjaXR5PSIwIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PC9zdmc+Cg==";
const $$12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: optimism_default
}, Symbol.toStringTag, { value: "Module" }));
var hardhat_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjI4IiBoZWlnaHQ9IjI4IiBmaWxsPSJ1cmwoI2EpIiByeD0iMTQiLz48ZyBjbGlwLXBhdGg9InVybCgjYikiPjxwYXRoIGZpbGw9IiNGRkYxMDAiIGQ9Ik0yMi40NTggMTguNDA5di0uODc1YzAtLjE2Mi0uMjU4LS4zMTctLjcyLS40NTdsLjAxMS0xLjA4OGMwLTEuNjc2LS40OS0zLjMxMi0xLjQwMi00LjY4NWE3LjgzMyA3LjgzMyAwIDAgMC0zLjcwMi0yLjk5NGwtLjAzMy0uMjE4YS42MzkuNjM5IDAgMCAwLS4xMzgtLjMxNS41OTIuNTkyIDAgMCAwLS4yNzctLjE4OCA3LjQyOSA3LjQyOSAwIDAgMC00LjM5NSAwIC41OTIuNTkyIDAgMCAwLS4yNzguMTg4LjY0LjY0IDAgMCAwLS4xNC4zMTVsLS4wMzEuMjAzYTcuODMgNy44MyAwIDAgMC0zLjcyNyAyLjk5MSA4LjQ3NCA4LjQ3NCAwIDAgMC0xLjQxNCA0LjcwM3YxLjA5M2MtLjQ1Ni4xMzktLjcxLjI5Mi0uNzEuNDU0di44NzRhLjIyNC4yMjQgMCAwIDAgLjAzLjE0N2MuMjI3LS4xNzguNDg3LS4zMDMuNzY0LS4zNjYuNzA0LS4xODEgMS40Mi0uMzA3IDIuMTQzLS4zNzguMjAyLS4wMjQuNDA3LS4wMDMuNjAxLjA2M3MuMzcyLjE3NC41MjMuMzE4YTIuOTQ1IDIuOTQ1IDAgMCAwIDIuMDQzLjgzNmg0Ljc0OGMuNzU2IDAgMS40ODUtLjI5OSAyLjA0My0uODM2YTEuNDIgMS40MiAwIDAgMSAuNTIyLS4zMmMuMTk0LS4wNjcuNC0uMDkuNjAyLS4wNjZhMTQuMiAxNC4yIDAgMCAxIDIuMTQzLjM3NmMuMjYyLjA1My41MS4xNjcuNzI0LjMzNC4wMTIuMDEzLjAyNy4wMjQuMDM3LjAzNmEuMjI3LjIyNyAwIDAgMCAuMDMzLS4xNDVaIi8+PHBhdGggZmlsbD0idXJsKCNjKSIgZD0iTTkuNTc0IDE2LjU2OWMtLjAwNi0uMi0uMDEtLjQwMi0uMDEtLjYwNC4wMDMtMy4wNC42NzctNS43NjUgMS43OS03LjY2OGE3LjgzIDcuODMgMCAwIDAtMy43MjggMi45OSA4LjQ3NCA4LjQ3NCAwIDAgMC0xLjQxNCA0LjcwMnYxLjA5M2ExNy45OCAxNy45OCAwIDAgMSAzLjM2Mi0uNTEzWiIvPjxwYXRoIGZpbGw9InVybCgjZCkiIGQ9Ik0yMS43NDkgMTUuOTg5YTguNDA5IDguNDA5IDAgMCAwLTEuNzczLTUuMTk5Yy40OTggMS42NzQuNzQ2IDMuNDIuNzM1IDUuMTczIDAgLjI5Ni0uMDA4LjU5LS4wMi44OGE5LjIgOS4yIDAgMCAxIDEuMDQ1LjIzNGwuMDEzLTEuMDg4WiIvPjxwYXRoIGZpbGw9InVybCgjZSkiIGQ9Ik0yMS42NjQgMTguMTg3Yy0uNzA1LS4xOC0xLjQyLS4zMDYtMi4xNDMtLjM3N2ExLjM2NSAxLjM2NSAwIDAgMC0uNjAyLjA2NCAxLjQxNiAxLjQxNiAwIDAgMC0uNTIzLjMyIDIuOTQzIDIuOTQzIDAgMCAxLTIuMDQzLjgzNWgtNC43NDVhMi45NDUgMi45NDUgMCAwIDEtMi4wNDMtLjgzNSAxLjQxNyAxLjQxNyAwIDAgMC0uNTIyLS4zMjIgMS4zNjYgMS4zNjYgMCAwIDAtLjYwMi0uMDY1IDE0LjE4IDE0LjE4IDAgMCAwLTIuMTQzLjM3NyAxLjk2MiAxLjk2MiAwIDAgMC0uNzY0LjM2N2MuMzYuNTggNC4wMDYgMS4xOSA4LjQ0OCAxLjE5czguMDg2LS42MTIgOC40NDctMS4xOWMtLjAxMy0uMDEyLS4wMjctLjAyMy0uMDM3LS4wMzVhMS44IDEuOCAwIDAgMC0uNzI4LS4zMjlaIi8+PHBhdGggZmlsbD0iIzBBMEEwQSIgZD0ibTEzLjk4IDkuODIzLTEuODE4IDMuMjU4IDEuODE3IDEuMTg4VjkuODI0WiIvPjxwYXRoIGZpbGw9IiM0QjRENEQiIGQ9Ik0xMy45OCA5LjgyNHY0LjQ0NGwxLjgxNy0xLjE4Ni0xLjgxNy0zLjI1OFptMCA1LjA5djEuNTVjLjAzNC0uMDUyIDEuODE3LTIuNzM4IDEuODE3LTIuNzRsLTEuODE3IDEuMTlaIi8+PHBhdGggZmlsbD0iIzBBMEEwQSIgZD0ibTEzLjk4IDE0LjkxNC0xLjgxOC0xLjE4NyAxLjgxOCAyLjczN3YtMS41NVoiLz48L2c+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMTQiIHgyPSIxNCIgeTE9IjAiIHkyPSIyOCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNGN0YxRkQiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGQkZDREMiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYyIgeDE9IjguNzgzIiB4Mj0iOC43ODMiIHkxPSIxNy4wODIiIHkyPSI4LjI5NyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNFRENGMDAiLz48c3RvcCBvZmZzZXQ9Ii4zMyIgc3RvcC1jb2xvcj0iI0YwRDUwMCIvPjxzdG9wIG9mZnNldD0iLjc3IiBzdG9wLWNvbG9yPSIjRjlFNTAwIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkZGMTAwIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImQiIHgxPSIyMC44NjIiIHgyPSIyMC44NjIiIHkxPSIxNy4xNDYiIHkyPSIxMC43OSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNFRENGMDAiLz48c3RvcCBvZmZzZXQ9Ii41OSIgc3RvcC1jb2xvcj0iI0Y3RTEwMCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGRjEwMCIvPjwvbGluZWFyR3JhZGllbnQ+PHJhZGlhbEdyYWRpZW50IGlkPSJlIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNi4zMDM1MyAwIDAgNi42NDkzNSA2LjQ1IDIzLjA4NCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjRkZGMTAwIi8+PHN0b3Agb2Zmc2V0PSIuMjMiIHN0b3AtY29sb3I9IiNGOUU1MDAiLz48c3RvcCBvZmZzZXQ9Ii42NyIgc3RvcC1jb2xvcj0iI0YwRDUwMCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0VEQ0YwMCIvPjwvcmFkaWFsR3JhZGllbnQ+PGNsaXBQYXRoIGlkPSJiIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE3djEzSDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1LjUgNykiLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4K";
const $$11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: hardhat_default
}, Symbol.toStringTag, { value: "Module" }));
var ethereum_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzI1MjkyRSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQgMjhhMTQgMTQgMCAxIDAgMC0yOCAxNCAxNCAwIDAgMCAwIDI4WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0idXJsKCNhKSIgZmlsbC1vcGFjaXR5PSIuMyIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQgMjhhMTQgMTQgMCAxIDAgMC0yOCAxNCAxNCAwIDAgMCAwIDI4WiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0idXJsKCNiKSIgZD0iTTguMTkgMTQuNzcgMTQgMTguMjFsNS44LTMuNDQtNS44IDguMTktNS44MS04LjE5WiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Im0xNCAxNi45My01LjgxLTMuNDRMMTQgNC4zNGw1LjgxIDkuMTVMMTQgMTYuOTNaIi8+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iMCIgeDI9IjE0IiB5MT0iMCIgeTI9IjI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iI2ZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZmZiIgc3RvcC1vcGFjaXR5PSIwIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgxPSIxNCIgeDI9IjE0IiB5MT0iMTQuNzciIHkyPSIyMi45NiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiNmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmZmYiIHN0b3Atb3BhY2l0eT0iLjkiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48L3N2Zz4K";
const $$10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ethereum_default
}, Symbol.toStringTag, { value: "Module" }));
var bsc_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSIgdmlld0JveD0iMCAwIDI4IDI4Ij48ZyBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcGF0aD0idXJsKCNhKSIgY2xpcC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRjNCQTJGIiBkPSJNMCAxNEMwIDYuMjQ0IDYuMjQ0IDAgMTQgMHMxNCA2LjI0NCAxNCAxNC02LjI0NCAxNC0xNCAxNFMwIDIxLjc1NiAwIDE0WiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Im0xNy41IDE1LjQzNyAyLjAzNiAyLjAzMUwxNCAyM2wtNS41My01LjUzMiAyLjAzNi0yLjAzTDE0IDE4LjkzMWwzLjUtMy40OTVabS0zLjUtMy41IDIuMDY2IDIuMDY2TDE0IDE2LjA2OWwtMi4wNi0yLjA2di0uMDA2bC4zNjMtLjM2My4xNzUtLjE3NkwxNCAxMS45MzdabS02Ljk2NC4wMjkgMi4wMzcgMi4wMzctMi4wMzcgMi4wMzFMNSAxMy45OTdsMi4wMzYtMi4wMzFabTEzLjkyOCAwTDIzIDE0LjAwM2wtMi4wMzcgMi4wMzEtMi4wMzYtMi4wMzcgMi4wMzctMi4wMzFaTTE0IDVsNS41MyA1LjUzMi0yLjAzNyAyLjAzN0wxNCA5LjA2OWwtMy40OTQgMy40OTQtMi4wMzYtMi4wMzFMMTQgNVoiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDI4djI4SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+";
const $$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: bsc_default
}, Symbol.toStringTag, { value: "Module" }));
var base_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjMDA1MkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0xNCAyOGExNCAxNCAwIDEgMCAwLTI4IDE0IDE0IDAgMCAwIDAgMjhaIi8+PHBhdGggZmlsbD0iI0ZGRiIgZD0iTTEzLjk2NyAyMy44NmM1LjQ0NSAwIDkuODYtNC40MTUgOS44Ni05Ljg2IDAtNS40NDUtNC40MTUtOS44Ni05Ljg2LTkuODYtNS4xNjYgMC05LjQwMyAzLjk3NC05LjgyNSA5LjAzaDE0LjYzdjEuNjQySDQuMTQyYy40MTMgNS4wNjUgNC42NTQgOS4wNDcgOS44MjYgOS4wNDdaIi8+PC9nPjwvc3ZnPg==";
const $$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: base_default
}, Symbol.toStringTag, { value: "Module" }));
var avalanche_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTIzIDVINXYxOGgxOFY1WiIvPjxwYXRoIGZpbGw9IiNFODQxNDIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTE0IDI4Yy03LjUxMy4wMDgtMTQtNi40ODctMTQtMTRDMCA2LjE5NiA2LjA0My0uMDA4IDE0IDBjNy45NS4wMDggMTQgNi4xOTYgMTQgMTQgMCA3LjUwNS02LjQ5NSAxMy45OTItMTQgMTRabS0zLjk3MS03LjQzNkg3LjMxNWMtLjU3IDAtLjg1MSAwLTEuMDIzLS4xMWEuNjkuNjkgMCAwIDEtLjMxMy0uNTRjLS4wMS0uMjAyLjEzLS40NS40MTItLjk0NGw2LjctMTEuODA5Yy4yODUtLjUwMS40My0uNzUyLjYxMi0uODQ1LjE5NS0uMS40MjktLjEuNjI1IDAgLjE4Mi4wOTMuMzI2LjM0NC42MTEuODQ1bDEuMzc3IDIuNDA0LjAwNy4wMTNjLjMwOC41MzguNDY0LjgxLjUzMyAxLjA5N2EyLjA0IDIuMDQgMCAwIDEgMCAuOTU0Yy0uMDcuMjg5LS4yMjQuNTY0LS41MzYgMS4xMWwtMy41MiA2LjIyLS4wMDkuMDE3Yy0uMzEuNTQyLS40NjcuODE3LS42ODQgMS4wMjRhMi4wNDggMi4wNDggMCAwIDEtLjgzNS40ODVjLS4yODUuMDc5LS42MDQuMDc5LTEuMjQzLjA3OVptNi44NTIgMGgzLjg4OGMuNTc0IDAgLjg2MiAwIDEuMDM0LS4xMTNhLjY4Ny42ODcgMCAwIDAgLjMxMy0uNTQzYy4wMS0uMTk2LS4xMjgtLjQzNC0uMzk4LS45YTguMTk4IDguMTk4IDAgMCAxLS4wMjgtLjA0OGwtMS45NDgtMy4zMzItLjAyMi0uMDM3Yy0uMjc0LS40NjMtLjQxMi0uNjk3LS41OS0uNzg3YS42ODQuNjg0IDAgMCAwLS42MjEgMGMtLjE3OS4wOTMtLjMyMy4zMzctLjYwOC44MjhsLTEuOTQgMy4zMzEtLjAwNy4wMTJjLS4yODQuNDktLjQyNi43MzUtLjQxNi45MzYuMDE0LjIyLjEyNy40MjMuMzEzLjU0My4xNjguMTEuNDU2LjExIDEuMDMuMTFaIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4K";
const $$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: avalanche_default
}, Symbol.toStringTag, { value: "Module" }));
var arbitrum_default = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjI2LjYiIGhlaWdodD0iMjYuNiIgeD0iLjciIHk9Ii43IiBmaWxsPSIjMkQzNzRCIiBzdHJva2U9IiM5NkJFREMiIHN0cm9rZS13aWR0aD0iMS40IiByeD0iMTMuMyIvPjxtYXNrIGlkPSJhIiB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHg9IjAiIHk9IjAiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiPjxyZWN0IHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgZmlsbD0iI0M0QzRDNCIgcng9IjE0Ii8+PC9tYXNrPjxnIG1hc2s9InVybCgjYSkiPjxwYXRoIGZpbGw9IiMyOEEwRjAiIGQ9Im0xNC4wODYxIDE4LjYwNDEgNi41MDE0IDEwLjIyMzkgNC4wMDU3LTIuMzIxMy03Ljg2LTEyLjM5NDMtMi42NDcxIDQuNDkxN1ptMTMuMDc0NCAzLjQ2OTItLjAwMy0xLjg1OTktNy4zMDY0LTExLjQwNy0yLjMwODcgMy45MTczIDcuMDkxIDExLjQzMDMgMi4xNzItMS4yNTg2YS45NjI4Ljk2MjggMCAwIDAgLjM1NTUtLjcwMDlsLS4wMDA0LS4xMjEyWiIvPjxyZWN0IHdpZHRoPSIyNS45IiBoZWlnaHQ9IjI1LjkiIHg9IjEuMDUiIHk9IjEuMDUiIGZpbGw9InVybCgjYikiIGZpbGwtb3BhY2l0eT0iLjMiIHN0cm9rZT0iIzk2QkVEQyIgc3Ryb2tlLXdpZHRoPSIyLjEiIHJ4PSIxMi45NSIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Im0uMzYzNCAyOC4yMjA3LTMuMDctMS43Njc0LS4yMzQtLjgzMzNMNy43NDYxIDkuMDE5NGMuNzI5OC0xLjE5MTMgMi4zMTk3LTEuNTc1IDMuNzk1Ny0xLjU1NDFsMS43MzIzLjA0NTdMLjM2MzQgMjguMjIwN1pNMTkuMTY1NSA3LjUxMWwtNC41NjUzLjAxNjZMMi4yNCAyNy45NTMzbDMuNjEwMyAyLjA3ODguOTgxOC0xLjY2NTJMMTkuMTY1NSA3LjUxMVoiLz48L2c+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iMCIgeDI9IjE0IiB5MT0iMCIgeTI9IjI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iI2ZmZiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2ZmZiIgc3RvcC1vcGFjaXR5PSIwIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PC9zdmc+Cg==";
const $$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: arbitrum_default
}, Symbol.toStringTag, { value: "Module" }));
var accentColors = {
  blue: {
    accentColor: "#0E76FD",
    accentColorForeground: "#FFF"
  },
  green: {
    accentColor: "#1DB847",
    accentColorForeground: "#FFF"
  },
  orange: {
    accentColor: "#FF801F",
    accentColorForeground: "#FFF"
  },
  pink: {
    accentColor: "#FF5CA0",
    accentColorForeground: "#FFF"
  },
  purple: {
    accentColor: "#5F5AFA",
    accentColorForeground: "#FFF"
  },
  red: {
    accentColor: "#FA423C",
    accentColorForeground: "#FFF"
  }
};
var defaultAccentColor = accentColors.blue;
var lightTheme = ({
  accentColor = defaultAccentColor.accentColor,
  accentColorForeground = defaultAccentColor.accentColorForeground,
  ...baseThemeOptions
} = {}) => ({
  ...baseTheme(baseThemeOptions),
  colors: {
    accentColor,
    accentColorForeground,
    actionButtonBorder: "rgba(0, 0, 0, 0.04)",
    actionButtonBorderMobile: "rgba(0, 0, 0, 0.06)",
    actionButtonSecondaryBackground: "rgba(0, 0, 0, 0.06)",
    closeButton: "rgba(60, 66, 66, 0.8)",
    closeButtonBackground: "rgba(0, 0, 0, 0.06)",
    connectButtonBackground: "#FFF",
    connectButtonBackgroundError: "#FF494A",
    connectButtonInnerBackground: "linear-gradient(0deg, rgba(0, 0, 0, 0.03), rgba(0, 0, 0, 0.06))",
    connectButtonText: "#25292E",
    connectButtonTextError: "#FFF",
    connectionIndicator: "#30E000",
    downloadBottomCardBackground: "linear-gradient(126deg, rgba(255, 255, 255, 0) 9.49%, rgba(171, 171, 171, 0.04) 71.04%), #FFFFFF",
    downloadTopCardBackground: "linear-gradient(126deg, rgba(171, 171, 171, 0.2) 9.49%, rgba(255, 255, 255, 0) 71.04%), #FFFFFF",
    error: "#FF494A",
    generalBorder: "rgba(0, 0, 0, 0.06)",
    generalBorderDim: "rgba(0, 0, 0, 0.03)",
    menuItemBackground: "rgba(60, 66, 66, 0.1)",
    modalBackdrop: "rgba(0, 0, 0, 0.3)",
    modalBackground: "#FFF",
    modalBorder: "transparent",
    modalText: "#25292E",
    modalTextDim: "rgba(60, 66, 66, 0.3)",
    modalTextSecondary: "rgba(60, 66, 66, 0.6)",
    profileAction: "#FFF",
    profileActionHover: "rgba(255, 255, 255, 0.5)",
    profileForeground: "rgba(60, 66, 66, 0.06)",
    selectedOptionBorder: "rgba(60, 66, 66, 0.1)",
    standby: "#FFD641"
  },
  shadows: {
    connectButton: "0px 4px 12px rgba(0, 0, 0, 0.1)",
    dialog: "0px 8px 32px rgba(0, 0, 0, 0.32)",
    profileDetailsAction: "0px 2px 6px rgba(37, 41, 46, 0.04)",
    selectedOption: "0px 2px 6px rgba(0, 0, 0, 0.24)",
    selectedWallet: "0px 2px 6px rgba(0, 0, 0, 0.12)",
    walletLogo: "0px 2px 16px rgba(0, 0, 0, 0.16)"
  }
});
lightTheme.accentColors = accentColors;
function addFunctionSerializer(target, recipe) {
  Object.defineProperty(target, "__recipe__", {
    value: recipe,
    writable: false
  });
  return target;
}
var addRecipe = addFunctionSerializer;
function createNormalizeValueFn(properties) {
  var {
    conditions
  } = properties;
  if (!conditions) {
    throw new Error("Styles have no conditions");
  }
  function normalizeValue(value) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      if (!conditions.defaultCondition) {
        throw new Error("No default condition");
      }
      return {
        [conditions.defaultCondition]: value
      };
    }
    if (Array.isArray(value)) {
      if (!("responsiveArray" in conditions)) {
        throw new Error("Responsive arrays are not supported");
      }
      var returnValue = {};
      for (var index2 in conditions.responsiveArray) {
        if (value[index2] != null) {
          returnValue[conditions.responsiveArray[index2]] = value[index2];
        }
      }
      return returnValue;
    }
    return value;
  }
  return addRecipe(normalizeValue, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createNormalizeValueFn",
    args: [{
      conditions: properties.conditions
    }]
  });
}
function createMapValueFn(properties) {
  var {
    conditions
  } = properties;
  if (!conditions) {
    throw new Error("Styles have no conditions");
  }
  var normalizeValue = createNormalizeValueFn(properties);
  function mapValue(value, mapFn) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      if (!conditions.defaultCondition) {
        throw new Error("No default condition");
      }
      return mapFn(value, conditions.defaultCondition);
    }
    var normalizedObject = Array.isArray(value) ? normalizeValue(value) : value;
    var mappedObject = {};
    for (var _key in normalizedObject) {
      if (normalizedObject[_key] != null) {
        mappedObject[_key] = mapFn(normalizedObject[_key], _key);
      }
    }
    return mappedObject;
  }
  return addRecipe(mapValue, {
    importPath: "@vanilla-extract/sprinkles/createUtils",
    importName: "createMapValueFn",
    args: [{
      conditions: properties.conditions
    }]
  });
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
var createSprinkles$1 = (composeStyles2) => function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var sprinklesStyles = Object.assign({}, ...args.map((a2) => a2.styles));
  var sprinklesKeys = Object.keys(sprinklesStyles);
  var shorthandNames = sprinklesKeys.filter((property) => "mappings" in sprinklesStyles[property]);
  var sprinklesFn = (props) => {
    var classNames = [];
    var shorthands = {};
    var nonShorthands = _objectSpread2({}, props);
    var hasShorthands = false;
    for (var shorthand of shorthandNames) {
      var value = props[shorthand];
      if (value != null) {
        var sprinkle = sprinklesStyles[shorthand];
        hasShorthands = true;
        for (var propMapping of sprinkle.mappings) {
          shorthands[propMapping] = value;
          if (nonShorthands[propMapping] == null) {
            delete nonShorthands[propMapping];
          }
        }
      }
    }
    var finalProps = hasShorthands ? _objectSpread2(_objectSpread2({}, shorthands), nonShorthands) : props;
    for (var prop in finalProps) {
      var propValue = finalProps[prop];
      var _sprinkle = sprinklesStyles[prop];
      try {
        if (_sprinkle.mappings) {
          continue;
        }
        if (typeof propValue === "string" || typeof propValue === "number") {
          if (process.env.NODE_ENV !== "production") {
            if (!_sprinkle.values[propValue].defaultClass) {
              throw new Error();
            }
          }
          classNames.push(_sprinkle.values[propValue].defaultClass);
        } else if (Array.isArray(propValue)) {
          for (var responsiveIndex = 0; responsiveIndex < propValue.length; responsiveIndex++) {
            var responsiveValue = propValue[responsiveIndex];
            if (responsiveValue != null) {
              var conditionName = _sprinkle.responsiveArray[responsiveIndex];
              if (process.env.NODE_ENV !== "production") {
                if (!_sprinkle.values[responsiveValue].conditions[conditionName]) {
                  throw new Error();
                }
              }
              classNames.push(_sprinkle.values[responsiveValue].conditions[conditionName]);
            }
          }
        } else {
          for (var _conditionName in propValue) {
            var _value = propValue[_conditionName];
            if (_value != null) {
              if (process.env.NODE_ENV !== "production") {
                if (!_sprinkle.values[_value].conditions[_conditionName]) {
                  throw new Error();
                }
              }
              classNames.push(_sprinkle.values[_value].conditions[_conditionName]);
            }
          }
        }
      } catch (e2) {
        if (process.env.NODE_ENV !== "production") {
          (function() {
            class SprinklesError extends Error {
              constructor(message) {
                super(message);
                this.name = "SprinklesError";
              }
            }
            var format2 = (v2) => typeof v2 === "string" ? '"'.concat(v2, '"') : v2;
            var invalidPropValue = (prop2, value2, possibleValues) => {
              throw new SprinklesError('"'.concat(prop2, '" has no value ').concat(format2(value2), ". Possible values are ").concat(Object.keys(possibleValues).map(format2).join(", ")));
            };
            if (!_sprinkle) {
              throw new SprinklesError('"'.concat(prop, '" is not a valid sprinkle'));
            }
            if (typeof propValue === "string" || typeof propValue === "number") {
              if (!(propValue in _sprinkle.values)) {
                invalidPropValue(prop, propValue, _sprinkle.values);
              }
              if (!_sprinkle.values[propValue].defaultClass) {
                throw new SprinklesError('"'.concat(prop, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(_sprinkle.values[propValue].conditions).map(format2).join(", ")));
              }
            }
            if (typeof propValue === "object") {
              if (!("conditions" in _sprinkle.values[Object.keys(_sprinkle.values)[0]])) {
                throw new SprinklesError('"'.concat(prop, '" is not a conditional property'));
              }
              if (Array.isArray(propValue)) {
                if (!("responsiveArray" in _sprinkle)) {
                  throw new SprinklesError('"'.concat(prop, '" does not support responsive arrays'));
                }
                var breakpointCount = _sprinkle.responsiveArray.length;
                if (breakpointCount < propValue.length) {
                  throw new SprinklesError('"'.concat(prop, '" only supports up to ').concat(breakpointCount, " breakpoints. You passed ").concat(propValue.length));
                }
                for (var _responsiveValue of propValue) {
                  if (!_sprinkle.values[_responsiveValue]) {
                    invalidPropValue(prop, _responsiveValue, _sprinkle.values);
                  }
                }
              } else {
                for (var _conditionName2 in propValue) {
                  var _value2 = propValue[_conditionName2];
                  if (_value2 != null) {
                    if (!_sprinkle.values[_value2]) {
                      invalidPropValue(prop, _value2, _sprinkle.values);
                    }
                    if (!_sprinkle.values[_value2].conditions[_conditionName2]) {
                      throw new SprinklesError('"'.concat(prop, '" has no condition named ').concat(format2(_conditionName2), ". Possible values are ").concat(Object.keys(_sprinkle.values[_value2].conditions).map(format2).join(", ")));
                    }
                  }
                }
              }
            }
          })();
        }
        throw e2;
      }
    }
    return composeStyles2(classNames.join(" "));
  };
  return Object.assign(sprinklesFn, {
    properties: new Set(sprinklesKeys)
  });
};
var composeStyles = (classList) => classList;
var createSprinkles = function createSprinkles2() {
  return createSprinkles$1(composeStyles)(...arguments);
};
function toVal(mix) {
  var k2, y2, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k2 = 0; k2 < mix.length; k2++) {
        if (mix[k2]) {
          if (y2 = toVal(mix[k2])) {
            str && (str += " ");
            str += y2;
          }
        }
      }
    } else {
      for (k2 in mix) {
        if (mix[k2]) {
          str && (str += " ");
          str += k2;
        }
      }
    }
  }
  return str;
}
function clsx2() {
  var i = 0, tmp, x2, str = "";
  while (i < arguments.length) {
    if (tmp = arguments[i++]) {
      if (x2 = toVal(tmp)) {
        str && (str += " ");
        str += x2;
      }
    }
  }
  return str;
}
const clsx_m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: clsx2
}, Symbol.toStringTag, { value: "Module" }));
var goerli = {
  id: 5,
  network: "goerli",
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://goerli.infura.io/v3"],
      webSocket: ["wss://goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    },
    public: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xA292E2E58d4ddEb29C33c63173d0E8B7a2A4c62e",
      blockCreated: 8610406
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
};
var mainnet = {
  id: 1,
  network: "homestead",
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://mainnet.infura.io/v3"],
      webSocket: ["wss://mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://cloudflare-eth.com"]
    },
    public: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da",
      blockCreated: 16773775
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
};
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __decorate$1(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done2 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn)
      context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done2)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? {
      get: descriptor.get,
      set: descriptor.set
    } : descriptor[key2], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key2] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done2 = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f2, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", {
    configurable: true,
    value: prefix ? "".concat(prefix, " ", name2) : name2
  });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$8(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = {
    label: 0,
    sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y2, t2, g2;
  return g2 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding$1 = Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function() {
        return m2[k2];
      }
    };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
};
function __exportStar(m2, o2) {
  for (var p2 in m2)
    if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
      __createBinding$1(o2, m2, p2);
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return {
          value: o2 && o2[i++],
          done: !o2
        };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
    s2 += arguments[i].length;
  for (var r2 = Array(s2), k2 = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray$1(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? {
        value: __await(o2[n2](v2)),
        done: false
      } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({
        value: v3,
        done: d2
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault$1 = Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", {
    enumerable: true,
    value: v2
  });
} : function(o2, v2) {
  o2["default"] = v2;
};
function __importStar$1(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$1(result, mod, k2);
  }
  __setModuleDefault$1(result, mod);
  return result;
}
function __importDefault$e(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet$1(receiver, state2, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
}
function __classPrivateFieldSet$1(receiver, state2, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state2.set(receiver, value), value;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
function __addDisposableResource(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({
      value,
      dispose,
      async: async2
    });
  } else if (async2) {
    env2.stack.push({
      async: true
    });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env2) {
  function fail(e2) {
    env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
    env2.hasError = true;
  }
  function next() {
    while (env2.stack.length) {
      var rec = env2.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
      } catch (e2) {
        fail(e2);
      }
    }
    if (env2.hasError)
      throw env2.error;
  }
  return next();
}
const tslib_es6 = {
  __extends: __extends$1,
  __assign,
  __rest,
  __decorate: __decorate$1,
  __param,
  __metadata,
  __awaiter: __awaiter$8,
  __generator,
  __createBinding: __createBinding$1,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray: __spreadArray$1,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar: __importStar$1,
  __importDefault: __importDefault$e,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __extends: __extends$1,
  get __assign() {
    return __assign;
  },
  __rest,
  __decorate: __decorate$1,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter: __awaiter$8,
  __generator,
  __createBinding: __createBinding$1,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray: __spreadArray$1,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar: __importStar$1,
  __importDefault: __importDefault$e,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = React48.useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer2.push(item);
      return function() {
        buffer2 = buffer2.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
      }
      buffer2 = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({
    async: true,
    ssr: false
  }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React48__namespace.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll$1 = React48__namespace.forwardRef(function(props, parentRef) {
  var ref = React48__namespace.useRef(null);
  var _a2 = React48__namespace.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React48__namespace.createElement(React48__namespace.Fragment, null, enabled && React48__namespace.createElement(SideCar2, {
    sideCar: effectCar,
    removeScrollBar,
    shards,
    noIsolation,
    inert,
    setCallbacks,
    allowPinchZoom: !!allowPinchZoom,
    lockRef: ref
  }), forwardProps ? React48__namespace.cloneElement(React48__namespace.Children.only(children), __assign(__assign({}, containerProps), {
    ref: containerRef
  })) : React48__namespace.createElement(Container, __assign({}, containerProps, {
    className,
    ref: containerRef
  }), children));
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic2) {
    React48__namespace.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic2]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic2 = _a2.dynamic;
    useStyle(styles, dynamic2);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$a = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$a(left), parse$a(top), parse$a(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([allowRelative && "position: relative ".concat(important, ";"), gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "), gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a2 = props.gapMode, gapMode = _a2 === void 0 ? "margin" : _a2;
  var gap = React48__namespace.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React48__namespace.createElement(Style, {
    styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "")
  });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? {
  passive: false
} : false;
var elementCouldBeVScrolled = function(node) {
  var styles = window.getComputedStyle(node);
  return styles.overflowY !== "hidden" && !(styles.overflowY === styles.overflowX && styles.overflowY === "visible");
};
var elementCouldBeHScrolled = function(node) {
  var styles = window.getComputedStyle(node);
  return styles.overflowX !== "hidden" && !(styles.overflowY === styles.overflowX && styles.overflowX === "visible");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), s2 = _a2[1], d2 = _a2[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter$1 = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React48__namespace.useRef([]);
  var touchStartRef = React48__namespace.useRef([0, 0]);
  var activeAxis = React48__namespace.useRef();
  var id2 = React48__namespace.useState(idCounter$1++)[0];
  var Style2 = React48__namespace.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React48__namespace.useRef(props);
  React48__namespace.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React48__namespace.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray$1([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React48__namespace.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React48__namespace.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  var shouldCancel = React48__namespace.useCallback(function(name2, delta, target, should) {
    var event = {
      name: name2,
      delta,
      target,
      should
    };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React48__namespace.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React48__namespace.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React48__namespace.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React48__namespace.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React48__namespace.createElement(React48__namespace.Fragment, null, inert ? React48__namespace.createElement(Style2, {
    styles: generateStyle(id2)
  }) : null, removeScrollBar ? React48__namespace.createElement(RemoveScrollBar, {
    gapMode: "margin"
  }) : null);
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React48__namespace.forwardRef(function(props, ref) {
  return React48__namespace.createElement(RemoveScroll$1, __assign({}, props, {
    ref,
    sideCar: SideCar
  }));
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function get$1(obj, path) {
  var result = obj;
  for (var key2 of path) {
    if (!(key2 in result)) {
      throw new Error("Path ".concat(path.join(" -> "), " does not exist in object"));
    }
    result = result[key2];
  }
  return result;
}
function walkObject(obj, fn2) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone = obj.constructor();
  for (var key2 in obj) {
    var _value = obj[key2];
    var currentPath = [...path, key2];
    if (typeof _value === "string" || typeof _value === "number" || _value == null) {
      clone[key2] = fn2(_value, currentPath);
    } else if (typeof _value === "object" && !Array.isArray(_value)) {
      clone[key2] = walkObject(_value, fn2, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
    }
  }
  return clone;
}
function assignInlineVars(varsOrContract, tokens) {
  var styles = {};
  if (typeof tokens === "object") {
    var _contract = varsOrContract;
    walkObject(tokens, (value, path) => {
      var varName2 = get$1(_contract, path);
      styles[getVarName(varName2)] = String(value);
    });
  } else {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      styles[getVarName(varName)] = _vars[varName];
    }
  }
  Object.defineProperty(styles, "toString", {
    value: function value() {
      return Object.keys(this).map((key2) => "".concat(key2, ":").concat(this[key2])).join(";");
    },
    writable: false
  });
  return styles;
}
var browser$3 = {};
var canPromise$3 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode$1 = {};
var utils$i = {};
let toSJISFunction$1;
const CODEWORDS_COUNT$1 = [
  0,
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$i.getSymbolSize = function getSymbolSize(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$i.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT$1[version2];
};
utils$i.getBCHDigit = function(data) {
  let digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
};
utils$i.setToSJISFunction = function setToSJISFunction(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction$1 = f2;
};
utils$i.isKanjiModeEnabled = function() {
  return typeof toSJISFunction$1 !== "undefined";
};
utils$i.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction$1(kanji2);
};
var errorCorrectionLevel$1 = {};
(function(exports2) {
  exports2.L = {
    bit: 1
  };
  exports2.M = {
    bit: 0
  };
  exports2.Q = {
    bit: 3
  };
  exports2.H = {
    bit: 2
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports2.L;
      case "m":
      case "medium":
        return exports2.M;
      case "q":
      case "quartile":
        return exports2.Q;
      case "h":
      case "high":
        return exports2.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports2.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel$1);
function BitBuffer$3() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$3.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer$1 = BitBuffer$3;
function BitMatrix$3(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$3.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$3.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$3.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$3.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix$1 = BitMatrix$3;
var alignmentPattern$1 = {};
(function(exports2) {
  const getSymbolSize4 = utils$i.getSymbolSize;
  exports2.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize4(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i = 1; i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports2.getPositions = function getPositions3(version2) {
    const coords = [];
    const pos = exports2.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i = 0; i < posLength; i++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i === 0 && j2 === 0 || i === 0 && j2 === posLength - 1 || i === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern$1);
var finderPattern$1 = {};
const getSymbolSize$1 = utils$i.getSymbolSize;
const FINDER_PATTERN_SIZE$1 = 7;
finderPattern$1.getPositions = function getPositions(version2) {
  const size2 = getSymbolSize$1(version2);
  return [
    [0, 0],
    [size2 - FINDER_PATTERN_SIZE$1, 0],
    [0, size2 - FINDER_PATTERN_SIZE$1]
  ];
};
var maskPattern$1 = {};
(function(exports2) {
  exports2.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports2.isValid = function isValid3(mask2) {
    return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
  };
  exports2.from = function from2(value) {
    return exports2.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports2.getPenaltyN1 = function getPenaltyN1(data) {
    const size2 = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module2 = data.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports2.getPenaltyN2 = function getPenaltyN2(data) {
    const size2 = data.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last2 === 4 || last2 === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports2.getPenaltyN3 = function getPenaltyN3(data) {
    const size2 = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports2.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for (let i = 0; i < modulesCount; i++)
      darkCount += data.data[i];
    const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i, j2) {
    switch (maskPattern2) {
      case exports2.Patterns.PATTERN000:
        return (i + j2) % 2 === 0;
      case exports2.Patterns.PATTERN001:
        return i % 2 === 0;
      case exports2.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports2.Patterns.PATTERN011:
        return (i + j2) % 3 === 0;
      case exports2.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports2.Patterns.PATTERN101:
        return i * j2 % 2 + i * j2 % 3 === 0;
      case exports2.Patterns.PATTERN110:
        return (i * j2 % 2 + i * j2 % 3) % 2 === 0;
      case exports2.Patterns.PATTERN111:
        return (i * j2 % 3 + (i + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports2.applyMask = function applyMask(pattern2, data) {
    const size2 = data.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data.isReserved(row, col))
          continue;
        data.xor(row, col, getMaskAt(pattern2, row, col));
      }
    }
  };
  exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports2.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports2.applyMask(p2, data);
      const penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
      exports2.applyMask(p2, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern$1);
var errorCorrectionCode$1 = {};
const ECLevel$3 = errorCorrectionLevel$1;
const EC_BLOCKS_TABLE$1 = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE$1 = [
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode$1.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$3.L:
      return EC_BLOCKS_TABLE$1[(version2 - 1) * 4 + 0];
    case ECLevel$3.M:
      return EC_BLOCKS_TABLE$1[(version2 - 1) * 4 + 1];
    case ECLevel$3.Q:
      return EC_BLOCKS_TABLE$1[(version2 - 1) * 4 + 2];
    case ECLevel$3.H:
      return EC_BLOCKS_TABLE$1[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode$1.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$3.L:
      return EC_CODEWORDS_TABLE$1[(version2 - 1) * 4 + 0];
    case ECLevel$3.M:
      return EC_CODEWORDS_TABLE$1[(version2 - 1) * 4 + 1];
    case ECLevel$3.Q:
      return EC_CODEWORDS_TABLE$1[(version2 - 1) * 4 + 2];
    case ECLevel$3.H:
      return EC_CODEWORDS_TABLE$1[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial$1 = {};
var galoisField$1 = {};
const EXP_TABLE$1 = new Uint8Array(512);
const LOG_TABLE$1 = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i = 0; i < 255; i++) {
    EXP_TABLE$1[i] = x2;
    LOG_TABLE$1[x2] = i;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i = 255; i < 512; i++) {
    EXP_TABLE$1[i] = EXP_TABLE$1[i - 255];
  }
})();
galoisField$1.log = function log(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE$1[n2];
};
galoisField$1.exp = function exp(n2) {
  return EXP_TABLE$1[n2];
};
galoisField$1.mul = function mul(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE$1[LOG_TABLE$1[x2] + LOG_TABLE$1[y2]];
};
(function(exports2) {
  const GF = galoisField$1;
  exports2.mul = function mul5(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i = 0; i < p1.length; i++) {
      for (let j2 = 0; j2 < p2.length; j2++) {
        coeff[i + j2] ^= GF.mul(p1[i], p2[j2]);
      }
    }
    return coeff;
  };
  exports2.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i = 0; i < divisor.length; i++) {
        result[i] ^= GF.mul(divisor[i], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports2.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i = 0; i < degree; i++) {
      poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i)]));
    }
    return poly;
  };
})(polynomial$1);
const Polynomial$1 = polynomial$1;
function ReedSolomonEncoder$3(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$3.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial$1.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$3.prototype.encode = function encode(data) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data.length + this.degree);
  paddedData.set(data);
  const remainder = Polynomial$1.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder$1 = ReedSolomonEncoder$3;
var version$p = {};
var mode$1 = {};
var versionCheck$1 = {};
versionCheck$1.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex$1 = {};
const numeric$2 = "[0-9]+";
const alphanumeric$1 = "[A-Z $%*+\\-./:]+";
let kanji$1 = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji$1 = kanji$1.replace(/u/g, "\\u");
const byte$1 = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji$1 + ")(?:.|[\r\n]))+";
regex$1.KANJI = new RegExp(kanji$1, "g");
regex$1.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex$1.BYTE = new RegExp(byte$1, "g");
regex$1.NUMERIC = new RegExp(numeric$2, "g");
regex$1.ALPHANUMERIC = new RegExp(alphanumeric$1, "g");
const TEST_KANJI$1 = new RegExp("^" + kanji$1 + "$");
const TEST_NUMERIC$1 = new RegExp("^" + numeric$2 + "$");
const TEST_ALPHANUMERIC$1 = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex$1.testKanji = function testKanji(str) {
  return TEST_KANJI$1.test(str);
};
regex$1.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC$1.test(str);
};
regex$1.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC$1.test(str);
};
(function(exports2) {
  const VersionCheck = versionCheck$1;
  const Regex = regex$1;
  exports2.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports2.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports2.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports2.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports2.MIXED = {
    bit: -1
  };
  exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports2.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports2.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports2.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports2.KANJI;
    else
      return exports2.BYTE;
  };
  exports2.toString = function toString2(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports2.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports2.NUMERIC;
      case "alphanumeric":
        return exports2.ALPHANUMERIC;
      case "kanji":
        return exports2.KANJI;
      case "byte":
        return exports2.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode$1);
(function(exports2) {
  const Utils2 = utils$i;
  const ECCode2 = errorCorrectionCode$1;
  const ECLevel2 = errorCorrectionLevel$1;
  const Mode2 = mode$1;
  const VersionCheck = versionCheck$1;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data) {
      const reservedBits = getReservedBitsCount(data.mode, version2);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports2.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports2.getEncodedBits = function getEncodedBits3(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version$p);
var formatInfo$1 = {};
const Utils$7 = utils$i;
const G15$1 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK$1 = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH$1 = Utils$7.getBCHDigit(G15$1);
formatInfo$1.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask2) {
  const data = errorCorrectionLevel2.bit << 3 | mask2;
  let d2 = data << 10;
  while (Utils$7.getBCHDigit(d2) - G15_BCH$1 >= 0) {
    d2 ^= G15$1 << Utils$7.getBCHDigit(d2) - G15_BCH$1;
  }
  return (data << 10 | d2) ^ G15_MASK$1;
};
var segments$1 = {};
const Mode$9 = mode$1;
function NumericData$1(data) {
  this.mode = Mode$9.NUMERIC;
  this.data = data.toString();
}
NumericData$1.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData$1.prototype.getLength = function getLength() {
  return this.data.length;
};
NumericData$1.prototype.getBitsLength = function getBitsLength2() {
  return NumericData$1.getBitsLength(this.data.length);
};
NumericData$1.prototype.write = function write(bitBuffer2) {
  let i, group, value;
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData$1 = NumericData$1;
const Mode$8 = mode$1;
const ALPHA_NUM_CHARS$1 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function AlphanumericData$1(data) {
  this.mode = Mode$8.ALPHANUMERIC;
  this.data = data;
}
AlphanumericData$1.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData$1.prototype.getLength = function getLength2() {
  return this.data.length;
};
AlphanumericData$1.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData$1.getBitsLength(this.data.length);
};
AlphanumericData$1.prototype.write = function write2(bitBuffer2) {
  let i;
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    let value = ALPHA_NUM_CHARS$1.indexOf(this.data[i]) * 45;
    value += ALPHA_NUM_CHARS$1.indexOf(this.data[i + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS$1.indexOf(this.data[i]), 6);
  }
};
var alphanumericData$1 = AlphanumericData$1;
var encodeUtf8$2 = function encodeUtf8(input) {
  var result = [];
  var size2 = input.length;
  for (var index2 = 0; index2 < size2; index2++) {
    var point3 = input.charCodeAt(index2);
    if (point3 >= 55296 && point3 <= 56319 && size2 > index2 + 1) {
      var second = input.charCodeAt(index2 + 1);
      if (second >= 56320 && second <= 57343) {
        point3 = (point3 - 55296) * 1024 + second - 56320 + 65536;
        index2 += 1;
      }
    }
    if (point3 < 128) {
      result.push(point3);
      continue;
    }
    if (point3 < 2048) {
      result.push(point3 >> 6 | 192);
      result.push(point3 & 63 | 128);
      continue;
    }
    if (point3 < 55296 || point3 >= 57344 && point3 < 65536) {
      result.push(point3 >> 12 | 224);
      result.push(point3 >> 6 & 63 | 128);
      result.push(point3 & 63 | 128);
      continue;
    }
    if (point3 >= 65536 && point3 <= 1114111) {
      result.push(point3 >> 18 | 240);
      result.push(point3 >> 12 & 63 | 128);
      result.push(point3 >> 6 & 63 | 128);
      result.push(point3 & 63 | 128);
      continue;
    }
    result.push(239, 191, 189);
  }
  return new Uint8Array(result).buffer;
};
const encodeUtf8$1 = encodeUtf8$2;
const Mode$7 = mode$1;
function ByteData$1(data) {
  this.mode = Mode$7.BYTE;
  this.data = new Uint8Array(encodeUtf8$1(data));
}
ByteData$1.getBitsLength = function getBitsLength5(length) {
  return length * 8;
};
ByteData$1.prototype.getLength = function getLength3() {
  return this.data.length;
};
ByteData$1.prototype.getBitsLength = function getBitsLength6() {
  return ByteData$1.getBitsLength(this.data.length);
};
ByteData$1.prototype.write = function(bitBuffer2) {
  for (let i = 0, l2 = this.data.length; i < l2; i++) {
    bitBuffer2.put(this.data[i], 8);
  }
};
var byteData$1 = ByteData$1;
const Mode$6 = mode$1;
const Utils$6 = utils$i;
function KanjiData$1(data) {
  this.mode = Mode$6.KANJI;
  this.data = data;
}
KanjiData$1.getBitsLength = function getBitsLength7(length) {
  return length * 13;
};
KanjiData$1.prototype.getLength = function getLength4() {
  return this.data.length;
};
KanjiData$1.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData$1.getBitsLength(this.data.length);
};
KanjiData$1.prototype.write = function(bitBuffer2) {
  let i;
  for (i = 0; i < this.data.length; i++) {
    let value = Utils$6.toSJIS(this.data[i]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error("Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8");
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData$1 = KanjiData$1;
var dijkstra = { exports: {} };
(function(module2) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s2, d2) {
      var predecessors = {};
      var costs = {};
      costs[s2] = 0;
      var open2 = dijkstra2.PriorityQueue.make();
      open2.push(s2, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open2.empty()) {
        closest = open2.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open2.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
        var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
      var nodes = [];
      var u2 = d2;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s2, d2) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d2);
      return dijkstra2.extract_shortest_path_from_predecessor_list(predecessors, d2);
    },
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
        opts = opts || {};
        for (key2 in T2) {
          if (T2.hasOwnProperty(key2)) {
            t2[key2] = T2[key2];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b2) {
        return a2.cost - b2.cost;
      },
      push: function(value, cost) {
        var item = {
          value,
          cost
        };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module2.exports = dijkstra2;
  }
})(dijkstra);
(function(exports2) {
  const Mode2 = mode$1;
  const NumericData2 = numericData$1;
  const AlphanumericData2 = alphanumericData$1;
  const ByteData2 = byteData$1;
  const KanjiData2 = kanjiData$1;
  const Regex = regex$1;
  const Utils2 = utils$i;
  const dijkstra$1 = dijkstra.exports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i = 0; i < segs.length; i++) {
      const seg = segs[i];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([seg, {
            data: seg.data,
            mode: Mode2.ALPHANUMERIC,
            length: seg.length
          }, {
            data: seg.data,
            mode: Mode2.BYTE,
            length: seg.length
          }]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([seg, {
            data: seg.data,
            mode: Mode2.BYTE,
            length: seg.length
          }]);
          break;
        case Mode2.KANJI:
          nodes.push([seg, {
            data: seg.data,
            mode: Mode2.BYTE,
            length: getStringByteLength(seg.data)
          }]);
          break;
        case Mode2.BYTE:
          nodes.push([{
            data: seg.data,
            mode: Mode2.BYTE,
            length: getStringByteLength(seg.data)
          }]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = {
      start: {}
    };
    let prevNodeIds = ["start"];
    for (let i = 0; i < nodes.length; i++) {
      const nodeGroup = nodes[i];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node = nodeGroup[j2];
        const key2 = "" + i + j2;
        currentNodeIds.push(key2);
        table[key2] = {
          node,
          lastCount: 0
        };
        graph[key2] = {};
        for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
          const prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]].end = 0;
    }
    return {
      map: graph,
      table
    };
  }
  function buildSingleSegment(data, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data);
      case Mode2.KANJI:
        return new KanjiData2(data);
      case Mode2.BYTE:
        return new ByteData2(data);
    }
  }
  exports2.fromArray = function fromArray2(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports2.fromString = function fromString(data, version2) {
    const segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra$1.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i = 1; i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node);
    }
    return exports2.fromArray(mergeSegments(optimizedSegs));
  };
  exports2.rawSplit = function rawSplit(data) {
    return exports2.fromArray(getSegmentsFromString(data, Utils2.isKanjiModeEnabled()));
  };
})(segments$1);
const Utils$5 = utils$i;
const ECLevel$2 = errorCorrectionLevel$1;
const BitBuffer$2 = bitBuffer$1;
const BitMatrix$2 = bitMatrix$1;
const AlignmentPattern$1 = alignmentPattern$1;
const FinderPattern$1 = finderPattern$1;
const MaskPattern$1 = maskPattern$1;
const ECCode$1 = errorCorrectionCode$1;
const ReedSolomonEncoder$2 = reedSolomonEncoder$1;
const Version$1 = version$p;
const FormatInfo$1 = formatInfo$1;
const Mode$5 = mode$1;
const Segments$1 = segments$1;
function setupFinderPattern$1(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern$1.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern$1(matrix) {
  const size2 = matrix.size;
  for (let r2 = 8; r2 < size2 - 8; r2++) {
    const value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern$1(matrix, version2) {
  const pos = AlignmentPattern$1.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo$1(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version$1.getEncodedBits(version2);
  let row, col, mod;
  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size2 - 8 - 3;
    mod = (bits >> i & 1) === 1;
    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}
function setupFormatInfo$1(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo$1.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i, mod;
  for (i = 0; i < 15; i++) {
    mod = (bits >> i & 1) === 1;
    if (i < 6) {
      matrix.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true);
    } else {
      matrix.set(size2 - 15 + i, 8, mod, true);
    }
    if (i < 8) {
      matrix.set(8, size2 - i - 1, mod, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i - 1, mod, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData$1(matrix, data) {
  const size2 = matrix.size;
  let inc2 = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc2;
      if (row < 0 || size2 <= row) {
        row -= inc2;
        inc2 = -inc2;
        break;
      }
    }
  }
}
function createData$1(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer$2();
  segments2.forEach(function(data) {
    buffer2.put(data.mode.bit, 4);
    buffer2.put(data.getLength(), Mode$5.getCharCountIndicator(data.mode, version2));
    data.write(buffer2);
  });
  const totalCodewords = Utils$5.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode$1.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i = 0; i < remainingByte; i++) {
    buffer2.put(i % 2 ? 17 : 236, 8);
  }
  return createCodewords$1(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords$1(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$5.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode$1.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode$1.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder$2(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
    const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset, offset + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i, r2;
  for (i = 0; i < maxDataSize; i++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i < dcData[r2].length) {
        data[index2++] = dcData[r2][i];
      }
    }
  }
  for (i = 0; i < ecCount; i++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data[index2++] = ecData[r2][i];
    }
  }
  return data;
}
function createSymbol$1(data, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data)) {
    segments2 = Segments$1.fromArray(data);
  } else if (typeof data === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments$1.rawSplit(data);
      estimatedVersion = Version$1.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments$1.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version$1.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
  }
  const dataBits = createData$1(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$5.getSymbolSize(version2);
  const modules = new BitMatrix$2(moduleCount);
  setupFinderPattern$1(modules, version2);
  setupTimingPattern$1(modules);
  setupAlignmentPattern$1(modules, version2);
  setupFormatInfo$1(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo$1(modules, version2);
  }
  setupData$1(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern$1.getBestMask(modules, setupFormatInfo$1.bind(null, modules, errorCorrectionLevel2));
  }
  MaskPattern$1.applyMask(maskPattern2, modules);
  setupFormatInfo$1(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode$1.create = function create(data, options) {
  if (typeof data === "undefined" || data === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel$2.M;
  let version2;
  let mask2;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel$2.from(options.errorCorrectionLevel, ECLevel$2.M);
    version2 = Version$1.from(options.version);
    mask2 = MaskPattern$1.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$5.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol$1(data, version2, errorCorrectionLevel2, mask2);
};
var canvas$1 = {};
var utils$h = {};
(function(exports2) {
  function hex2rgba(hex2) {
    if (typeof hex2 === "number") {
      hex2 = hex2.toString();
    }
    if (typeof hex2 !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex2.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex2);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue2 = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue2 >> 24 & 255,
      g: hexValue2 >> 16 & 255,
      b: hexValue2 >> 8 & 255,
      a: hexValue2 & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports2.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports2.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports2.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports2.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports2.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i = 0; i < symbolSize; i++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j2 >= scaledMargin && i < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i - scaledMargin) / scale);
          const jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$h);
(function(exports2) {
  const Utils2 = utils$h;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports2.render = function render3(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports2.render(qrData, canvas2, opts);
    const type2 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type2, rendererOpts.quality);
  };
})(canvas$1);
var svgTag$1 = {};
const Utils$4 = utils$h;
function getColorAttrib$1(color, attrib) {
  const alpha = color.a / 255;
  const str = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd$1(cmd, x2, y2) {
  let str = cmd + x2;
  if (typeof y2 !== "undefined")
    str += " " + y2;
  return str;
}
function qrToPath$1(data, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size2);
    const row = Math.floor(i / size2);
    if (!col && !newRow)
      newRow = true;
    if (data[i]) {
      lineLength++;
      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow ? svgCmd$1("M", col + margin, 0.5 + row + margin) : svgCmd$1("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data[i + 1])) {
        path += svgCmd$1("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag$1.render = function render(qrData, options, cb) {
  const opts = Utils$4.getOptions(options);
  const size2 = qrData.modules.size;
  const data = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib$1(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib$1(opts.color.dark, "stroke") + ' d="' + qrToPath$1(data, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
  if (typeof cb === "function") {
    cb(null, svgTag2);
  }
  return svgTag2;
};
const canPromise$2 = canPromise$3;
const QRCode$6 = qrcode$1;
const CanvasRenderer$1 = canvas$1;
const SvgRenderer$1 = svgTag$1;
function renderCanvas$1(renderFunc, canvas2, text, opts, cb) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise$2()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === "undefined") {
        cb = opts;
        opts = void 0;
      } else {
        cb = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data = QRCode$6.create(text, opts);
        resolve(renderFunc(data, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data = QRCode$6.create(text, opts);
    cb(null, renderFunc(data, canvas2, opts));
  } catch (e2) {
    cb(e2);
  }
}
browser$3.create = QRCode$6.create;
browser$3.toCanvas = renderCanvas$1.bind(null, CanvasRenderer$1.render);
browser$3.toDataURL = renderCanvas$1.bind(null, CanvasRenderer$1.renderToDataURL);
browser$3.toString = renderCanvas$1.bind(null, function(data, _2, opts) {
  return SvgRenderer$1.render(data, opts);
});
var largeScreenMinWidth = 768;
var mapResponsiveValue = createMapValueFn({
  conditions: {
    defaultCondition: "smallScreen",
    conditionNames: ["smallScreen", "largeScreen"],
    responsiveArray: void 0
  }
});
var normalizeResponsiveValue = createNormalizeValueFn({
  conditions: {
    defaultCondition: "smallScreen",
    conditionNames: ["smallScreen", "largeScreen"],
    responsiveArray: void 0
  }
});
var sprinkles = createSprinkles({
  conditions: {
    defaultCondition: "base",
    conditionNames: ["base", "hover", "active"],
    responsiveArray: void 0
  },
  styles: {
    background: {
      values: {
        accentColor: {
          conditions: {
            base: "ju367v9c",
            hover: "ju367v9d",
            active: "ju367v9e"
          },
          defaultClass: "ju367v9c"
        },
        accentColorForeground: {
          conditions: {
            base: "ju367v9f",
            hover: "ju367v9g",
            active: "ju367v9h"
          },
          defaultClass: "ju367v9f"
        },
        actionButtonBorder: {
          conditions: {
            base: "ju367v9i",
            hover: "ju367v9j",
            active: "ju367v9k"
          },
          defaultClass: "ju367v9i"
        },
        actionButtonBorderMobile: {
          conditions: {
            base: "ju367v9l",
            hover: "ju367v9m",
            active: "ju367v9n"
          },
          defaultClass: "ju367v9l"
        },
        actionButtonSecondaryBackground: {
          conditions: {
            base: "ju367v9o",
            hover: "ju367v9p",
            active: "ju367v9q"
          },
          defaultClass: "ju367v9o"
        },
        closeButton: {
          conditions: {
            base: "ju367v9r",
            hover: "ju367v9s",
            active: "ju367v9t"
          },
          defaultClass: "ju367v9r"
        },
        closeButtonBackground: {
          conditions: {
            base: "ju367v9u",
            hover: "ju367v9v",
            active: "ju367v9w"
          },
          defaultClass: "ju367v9u"
        },
        connectButtonBackground: {
          conditions: {
            base: "ju367v9x",
            hover: "ju367v9y",
            active: "ju367v9z"
          },
          defaultClass: "ju367v9x"
        },
        connectButtonBackgroundError: {
          conditions: {
            base: "ju367va0",
            hover: "ju367va1",
            active: "ju367va2"
          },
          defaultClass: "ju367va0"
        },
        connectButtonInnerBackground: {
          conditions: {
            base: "ju367va3",
            hover: "ju367va4",
            active: "ju367va5"
          },
          defaultClass: "ju367va3"
        },
        connectButtonText: {
          conditions: {
            base: "ju367va6",
            hover: "ju367va7",
            active: "ju367va8"
          },
          defaultClass: "ju367va6"
        },
        connectButtonTextError: {
          conditions: {
            base: "ju367va9",
            hover: "ju367vaa",
            active: "ju367vab"
          },
          defaultClass: "ju367va9"
        },
        connectionIndicator: {
          conditions: {
            base: "ju367vac",
            hover: "ju367vad",
            active: "ju367vae"
          },
          defaultClass: "ju367vac"
        },
        downloadBottomCardBackground: {
          conditions: {
            base: "ju367vaf",
            hover: "ju367vag",
            active: "ju367vah"
          },
          defaultClass: "ju367vaf"
        },
        downloadTopCardBackground: {
          conditions: {
            base: "ju367vai",
            hover: "ju367vaj",
            active: "ju367vak"
          },
          defaultClass: "ju367vai"
        },
        error: {
          conditions: {
            base: "ju367val",
            hover: "ju367vam",
            active: "ju367van"
          },
          defaultClass: "ju367val"
        },
        generalBorder: {
          conditions: {
            base: "ju367vao",
            hover: "ju367vap",
            active: "ju367vaq"
          },
          defaultClass: "ju367vao"
        },
        generalBorderDim: {
          conditions: {
            base: "ju367var",
            hover: "ju367vas",
            active: "ju367vat"
          },
          defaultClass: "ju367var"
        },
        menuItemBackground: {
          conditions: {
            base: "ju367vau",
            hover: "ju367vav",
            active: "ju367vaw"
          },
          defaultClass: "ju367vau"
        },
        modalBackdrop: {
          conditions: {
            base: "ju367vax",
            hover: "ju367vay",
            active: "ju367vaz"
          },
          defaultClass: "ju367vax"
        },
        modalBackground: {
          conditions: {
            base: "ju367vb0",
            hover: "ju367vb1",
            active: "ju367vb2"
          },
          defaultClass: "ju367vb0"
        },
        modalBorder: {
          conditions: {
            base: "ju367vb3",
            hover: "ju367vb4",
            active: "ju367vb5"
          },
          defaultClass: "ju367vb3"
        },
        modalText: {
          conditions: {
            base: "ju367vb6",
            hover: "ju367vb7",
            active: "ju367vb8"
          },
          defaultClass: "ju367vb6"
        },
        modalTextDim: {
          conditions: {
            base: "ju367vb9",
            hover: "ju367vba",
            active: "ju367vbb"
          },
          defaultClass: "ju367vb9"
        },
        modalTextSecondary: {
          conditions: {
            base: "ju367vbc",
            hover: "ju367vbd",
            active: "ju367vbe"
          },
          defaultClass: "ju367vbc"
        },
        profileAction: {
          conditions: {
            base: "ju367vbf",
            hover: "ju367vbg",
            active: "ju367vbh"
          },
          defaultClass: "ju367vbf"
        },
        profileActionHover: {
          conditions: {
            base: "ju367vbi",
            hover: "ju367vbj",
            active: "ju367vbk"
          },
          defaultClass: "ju367vbi"
        },
        profileForeground: {
          conditions: {
            base: "ju367vbl",
            hover: "ju367vbm",
            active: "ju367vbn"
          },
          defaultClass: "ju367vbl"
        },
        selectedOptionBorder: {
          conditions: {
            base: "ju367vbo",
            hover: "ju367vbp",
            active: "ju367vbq"
          },
          defaultClass: "ju367vbo"
        },
        standby: {
          conditions: {
            base: "ju367vbr",
            hover: "ju367vbs",
            active: "ju367vbt"
          },
          defaultClass: "ju367vbr"
        }
      }
    },
    borderColor: {
      values: {
        accentColor: {
          conditions: {
            base: "ju367vbu",
            hover: "ju367vbv",
            active: "ju367vbw"
          },
          defaultClass: "ju367vbu"
        },
        accentColorForeground: {
          conditions: {
            base: "ju367vbx",
            hover: "ju367vby",
            active: "ju367vbz"
          },
          defaultClass: "ju367vbx"
        },
        actionButtonBorder: {
          conditions: {
            base: "ju367vc0",
            hover: "ju367vc1",
            active: "ju367vc2"
          },
          defaultClass: "ju367vc0"
        },
        actionButtonBorderMobile: {
          conditions: {
            base: "ju367vc3",
            hover: "ju367vc4",
            active: "ju367vc5"
          },
          defaultClass: "ju367vc3"
        },
        actionButtonSecondaryBackground: {
          conditions: {
            base: "ju367vc6",
            hover: "ju367vc7",
            active: "ju367vc8"
          },
          defaultClass: "ju367vc6"
        },
        closeButton: {
          conditions: {
            base: "ju367vc9",
            hover: "ju367vca",
            active: "ju367vcb"
          },
          defaultClass: "ju367vc9"
        },
        closeButtonBackground: {
          conditions: {
            base: "ju367vcc",
            hover: "ju367vcd",
            active: "ju367vce"
          },
          defaultClass: "ju367vcc"
        },
        connectButtonBackground: {
          conditions: {
            base: "ju367vcf",
            hover: "ju367vcg",
            active: "ju367vch"
          },
          defaultClass: "ju367vcf"
        },
        connectButtonBackgroundError: {
          conditions: {
            base: "ju367vci",
            hover: "ju367vcj",
            active: "ju367vck"
          },
          defaultClass: "ju367vci"
        },
        connectButtonInnerBackground: {
          conditions: {
            base: "ju367vcl",
            hover: "ju367vcm",
            active: "ju367vcn"
          },
          defaultClass: "ju367vcl"
        },
        connectButtonText: {
          conditions: {
            base: "ju367vco",
            hover: "ju367vcp",
            active: "ju367vcq"
          },
          defaultClass: "ju367vco"
        },
        connectButtonTextError: {
          conditions: {
            base: "ju367vcr",
            hover: "ju367vcs",
            active: "ju367vct"
          },
          defaultClass: "ju367vcr"
        },
        connectionIndicator: {
          conditions: {
            base: "ju367vcu",
            hover: "ju367vcv",
            active: "ju367vcw"
          },
          defaultClass: "ju367vcu"
        },
        downloadBottomCardBackground: {
          conditions: {
            base: "ju367vcx",
            hover: "ju367vcy",
            active: "ju367vcz"
          },
          defaultClass: "ju367vcx"
        },
        downloadTopCardBackground: {
          conditions: {
            base: "ju367vd0",
            hover: "ju367vd1",
            active: "ju367vd2"
          },
          defaultClass: "ju367vd0"
        },
        error: {
          conditions: {
            base: "ju367vd3",
            hover: "ju367vd4",
            active: "ju367vd5"
          },
          defaultClass: "ju367vd3"
        },
        generalBorder: {
          conditions: {
            base: "ju367vd6",
            hover: "ju367vd7",
            active: "ju367vd8"
          },
          defaultClass: "ju367vd6"
        },
        generalBorderDim: {
          conditions: {
            base: "ju367vd9",
            hover: "ju367vda",
            active: "ju367vdb"
          },
          defaultClass: "ju367vd9"
        },
        menuItemBackground: {
          conditions: {
            base: "ju367vdc",
            hover: "ju367vdd",
            active: "ju367vde"
          },
          defaultClass: "ju367vdc"
        },
        modalBackdrop: {
          conditions: {
            base: "ju367vdf",
            hover: "ju367vdg",
            active: "ju367vdh"
          },
          defaultClass: "ju367vdf"
        },
        modalBackground: {
          conditions: {
            base: "ju367vdi",
            hover: "ju367vdj",
            active: "ju367vdk"
          },
          defaultClass: "ju367vdi"
        },
        modalBorder: {
          conditions: {
            base: "ju367vdl",
            hover: "ju367vdm",
            active: "ju367vdn"
          },
          defaultClass: "ju367vdl"
        },
        modalText: {
          conditions: {
            base: "ju367vdo",
            hover: "ju367vdp",
            active: "ju367vdq"
          },
          defaultClass: "ju367vdo"
        },
        modalTextDim: {
          conditions: {
            base: "ju367vdr",
            hover: "ju367vds",
            active: "ju367vdt"
          },
          defaultClass: "ju367vdr"
        },
        modalTextSecondary: {
          conditions: {
            base: "ju367vdu",
            hover: "ju367vdv",
            active: "ju367vdw"
          },
          defaultClass: "ju367vdu"
        },
        profileAction: {
          conditions: {
            base: "ju367vdx",
            hover: "ju367vdy",
            active: "ju367vdz"
          },
          defaultClass: "ju367vdx"
        },
        profileActionHover: {
          conditions: {
            base: "ju367ve0",
            hover: "ju367ve1",
            active: "ju367ve2"
          },
          defaultClass: "ju367ve0"
        },
        profileForeground: {
          conditions: {
            base: "ju367ve3",
            hover: "ju367ve4",
            active: "ju367ve5"
          },
          defaultClass: "ju367ve3"
        },
        selectedOptionBorder: {
          conditions: {
            base: "ju367ve6",
            hover: "ju367ve7",
            active: "ju367ve8"
          },
          defaultClass: "ju367ve6"
        },
        standby: {
          conditions: {
            base: "ju367ve9",
            hover: "ju367vea",
            active: "ju367veb"
          },
          defaultClass: "ju367ve9"
        }
      }
    },
    boxShadow: {
      values: {
        connectButton: {
          conditions: {
            base: "ju367vec",
            hover: "ju367ved",
            active: "ju367vee"
          },
          defaultClass: "ju367vec"
        },
        dialog: {
          conditions: {
            base: "ju367vef",
            hover: "ju367veg",
            active: "ju367veh"
          },
          defaultClass: "ju367vef"
        },
        profileDetailsAction: {
          conditions: {
            base: "ju367vei",
            hover: "ju367vej",
            active: "ju367vek"
          },
          defaultClass: "ju367vei"
        },
        selectedOption: {
          conditions: {
            base: "ju367vel",
            hover: "ju367vem",
            active: "ju367ven"
          },
          defaultClass: "ju367vel"
        },
        selectedWallet: {
          conditions: {
            base: "ju367veo",
            hover: "ju367vep",
            active: "ju367veq"
          },
          defaultClass: "ju367veo"
        },
        walletLogo: {
          conditions: {
            base: "ju367ver",
            hover: "ju367ves",
            active: "ju367vet"
          },
          defaultClass: "ju367ver"
        }
      }
    },
    color: {
      values: {
        accentColor: {
          conditions: {
            base: "ju367veu",
            hover: "ju367vev",
            active: "ju367vew"
          },
          defaultClass: "ju367veu"
        },
        accentColorForeground: {
          conditions: {
            base: "ju367vex",
            hover: "ju367vey",
            active: "ju367vez"
          },
          defaultClass: "ju367vex"
        },
        actionButtonBorder: {
          conditions: {
            base: "ju367vf0",
            hover: "ju367vf1",
            active: "ju367vf2"
          },
          defaultClass: "ju367vf0"
        },
        actionButtonBorderMobile: {
          conditions: {
            base: "ju367vf3",
            hover: "ju367vf4",
            active: "ju367vf5"
          },
          defaultClass: "ju367vf3"
        },
        actionButtonSecondaryBackground: {
          conditions: {
            base: "ju367vf6",
            hover: "ju367vf7",
            active: "ju367vf8"
          },
          defaultClass: "ju367vf6"
        },
        closeButton: {
          conditions: {
            base: "ju367vf9",
            hover: "ju367vfa",
            active: "ju367vfb"
          },
          defaultClass: "ju367vf9"
        },
        closeButtonBackground: {
          conditions: {
            base: "ju367vfc",
            hover: "ju367vfd",
            active: "ju367vfe"
          },
          defaultClass: "ju367vfc"
        },
        connectButtonBackground: {
          conditions: {
            base: "ju367vff",
            hover: "ju367vfg",
            active: "ju367vfh"
          },
          defaultClass: "ju367vff"
        },
        connectButtonBackgroundError: {
          conditions: {
            base: "ju367vfi",
            hover: "ju367vfj",
            active: "ju367vfk"
          },
          defaultClass: "ju367vfi"
        },
        connectButtonInnerBackground: {
          conditions: {
            base: "ju367vfl",
            hover: "ju367vfm",
            active: "ju367vfn"
          },
          defaultClass: "ju367vfl"
        },
        connectButtonText: {
          conditions: {
            base: "ju367vfo",
            hover: "ju367vfp",
            active: "ju367vfq"
          },
          defaultClass: "ju367vfo"
        },
        connectButtonTextError: {
          conditions: {
            base: "ju367vfr",
            hover: "ju367vfs",
            active: "ju367vft"
          },
          defaultClass: "ju367vfr"
        },
        connectionIndicator: {
          conditions: {
            base: "ju367vfu",
            hover: "ju367vfv",
            active: "ju367vfw"
          },
          defaultClass: "ju367vfu"
        },
        downloadBottomCardBackground: {
          conditions: {
            base: "ju367vfx",
            hover: "ju367vfy",
            active: "ju367vfz"
          },
          defaultClass: "ju367vfx"
        },
        downloadTopCardBackground: {
          conditions: {
            base: "ju367vg0",
            hover: "ju367vg1",
            active: "ju367vg2"
          },
          defaultClass: "ju367vg0"
        },
        error: {
          conditions: {
            base: "ju367vg3",
            hover: "ju367vg4",
            active: "ju367vg5"
          },
          defaultClass: "ju367vg3"
        },
        generalBorder: {
          conditions: {
            base: "ju367vg6",
            hover: "ju367vg7",
            active: "ju367vg8"
          },
          defaultClass: "ju367vg6"
        },
        generalBorderDim: {
          conditions: {
            base: "ju367vg9",
            hover: "ju367vga",
            active: "ju367vgb"
          },
          defaultClass: "ju367vg9"
        },
        menuItemBackground: {
          conditions: {
            base: "ju367vgc",
            hover: "ju367vgd",
            active: "ju367vge"
          },
          defaultClass: "ju367vgc"
        },
        modalBackdrop: {
          conditions: {
            base: "ju367vgf",
            hover: "ju367vgg",
            active: "ju367vgh"
          },
          defaultClass: "ju367vgf"
        },
        modalBackground: {
          conditions: {
            base: "ju367vgi",
            hover: "ju367vgj",
            active: "ju367vgk"
          },
          defaultClass: "ju367vgi"
        },
        modalBorder: {
          conditions: {
            base: "ju367vgl",
            hover: "ju367vgm",
            active: "ju367vgn"
          },
          defaultClass: "ju367vgl"
        },
        modalText: {
          conditions: {
            base: "ju367vgo",
            hover: "ju367vgp",
            active: "ju367vgq"
          },
          defaultClass: "ju367vgo"
        },
        modalTextDim: {
          conditions: {
            base: "ju367vgr",
            hover: "ju367vgs",
            active: "ju367vgt"
          },
          defaultClass: "ju367vgr"
        },
        modalTextSecondary: {
          conditions: {
            base: "ju367vgu",
            hover: "ju367vgv",
            active: "ju367vgw"
          },
          defaultClass: "ju367vgu"
        },
        profileAction: {
          conditions: {
            base: "ju367vgx",
            hover: "ju367vgy",
            active: "ju367vgz"
          },
          defaultClass: "ju367vgx"
        },
        profileActionHover: {
          conditions: {
            base: "ju367vh0",
            hover: "ju367vh1",
            active: "ju367vh2"
          },
          defaultClass: "ju367vh0"
        },
        profileForeground: {
          conditions: {
            base: "ju367vh3",
            hover: "ju367vh4",
            active: "ju367vh5"
          },
          defaultClass: "ju367vh3"
        },
        selectedOptionBorder: {
          conditions: {
            base: "ju367vh6",
            hover: "ju367vh7",
            active: "ju367vh8"
          },
          defaultClass: "ju367vh6"
        },
        standby: {
          conditions: {
            base: "ju367vh9",
            hover: "ju367vha",
            active: "ju367vhb"
          },
          defaultClass: "ju367vh9"
        }
      }
    }
  }
}, {
  conditions: {
    defaultCondition: "smallScreen",
    conditionNames: ["smallScreen", "largeScreen"],
    responsiveArray: void 0
  },
  styles: {
    alignItems: {
      values: {
        "flex-start": {
          conditions: {
            smallScreen: "ju367v0",
            largeScreen: "ju367v1"
          },
          defaultClass: "ju367v0"
        },
        "flex-end": {
          conditions: {
            smallScreen: "ju367v2",
            largeScreen: "ju367v3"
          },
          defaultClass: "ju367v2"
        },
        center: {
          conditions: {
            smallScreen: "ju367v4",
            largeScreen: "ju367v5"
          },
          defaultClass: "ju367v4"
        }
      }
    },
    display: {
      values: {
        none: {
          conditions: {
            smallScreen: "ju367v6",
            largeScreen: "ju367v7"
          },
          defaultClass: "ju367v6"
        },
        block: {
          conditions: {
            smallScreen: "ju367v8",
            largeScreen: "ju367v9"
          },
          defaultClass: "ju367v8"
        },
        flex: {
          conditions: {
            smallScreen: "ju367va",
            largeScreen: "ju367vb"
          },
          defaultClass: "ju367va"
        },
        inline: {
          conditions: {
            smallScreen: "ju367vc",
            largeScreen: "ju367vd"
          },
          defaultClass: "ju367vc"
        }
      }
    }
  }
}, {
  conditions: void 0,
  styles: {
    margin: {
      mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"]
    },
    marginX: {
      mappings: ["marginLeft", "marginRight"]
    },
    marginY: {
      mappings: ["marginTop", "marginBottom"]
    },
    padding: {
      mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"]
    },
    paddingX: {
      mappings: ["paddingLeft", "paddingRight"]
    },
    paddingY: {
      mappings: ["paddingTop", "paddingBottom"]
    },
    alignSelf: {
      values: {
        "flex-start": {
          defaultClass: "ju367ve"
        },
        "flex-end": {
          defaultClass: "ju367vf"
        },
        center: {
          defaultClass: "ju367vg"
        }
      }
    },
    backgroundSize: {
      values: {
        cover: {
          defaultClass: "ju367vh"
        }
      }
    },
    borderRadius: {
      values: {
        "1": {
          defaultClass: "ju367vi"
        },
        "6": {
          defaultClass: "ju367vj"
        },
        "10": {
          defaultClass: "ju367vk"
        },
        "13": {
          defaultClass: "ju367vl"
        },
        actionButton: {
          defaultClass: "ju367vm"
        },
        connectButton: {
          defaultClass: "ju367vn"
        },
        menuButton: {
          defaultClass: "ju367vo"
        },
        modal: {
          defaultClass: "ju367vp"
        },
        modalMobile: {
          defaultClass: "ju367vq"
        },
        "25%": {
          defaultClass: "ju367vr"
        },
        full: {
          defaultClass: "ju367vs"
        }
      }
    },
    borderStyle: {
      values: {
        solid: {
          defaultClass: "ju367vt"
        }
      }
    },
    borderWidth: {
      values: {
        "0": {
          defaultClass: "ju367vu"
        },
        "1": {
          defaultClass: "ju367vv"
        },
        "2": {
          defaultClass: "ju367vw"
        },
        "4": {
          defaultClass: "ju367vx"
        }
      }
    },
    cursor: {
      values: {
        pointer: {
          defaultClass: "ju367vy"
        }
      }
    },
    flexDirection: {
      values: {
        row: {
          defaultClass: "ju367vz"
        },
        column: {
          defaultClass: "ju367v10"
        }
      }
    },
    fontFamily: {
      values: {
        body: {
          defaultClass: "ju367v11"
        }
      }
    },
    fontSize: {
      values: {
        "12": {
          defaultClass: "ju367v12"
        },
        "13": {
          defaultClass: "ju367v13"
        },
        "14": {
          defaultClass: "ju367v14"
        },
        "16": {
          defaultClass: "ju367v15"
        },
        "18": {
          defaultClass: "ju367v16"
        },
        "20": {
          defaultClass: "ju367v17"
        },
        "23": {
          defaultClass: "ju367v18"
        }
      }
    },
    fontWeight: {
      values: {
        regular: {
          defaultClass: "ju367v19"
        },
        medium: {
          defaultClass: "ju367v1a"
        },
        semibold: {
          defaultClass: "ju367v1b"
        },
        bold: {
          defaultClass: "ju367v1c"
        },
        heavy: {
          defaultClass: "ju367v1d"
        }
      }
    },
    gap: {
      values: {
        "0": {
          defaultClass: "ju367v1e"
        },
        "1": {
          defaultClass: "ju367v1f"
        },
        "2": {
          defaultClass: "ju367v1g"
        },
        "3": {
          defaultClass: "ju367v1h"
        },
        "4": {
          defaultClass: "ju367v1i"
        },
        "5": {
          defaultClass: "ju367v1j"
        },
        "6": {
          defaultClass: "ju367v1k"
        },
        "8": {
          defaultClass: "ju367v1l"
        },
        "10": {
          defaultClass: "ju367v1m"
        },
        "12": {
          defaultClass: "ju367v1n"
        },
        "14": {
          defaultClass: "ju367v1o"
        },
        "16": {
          defaultClass: "ju367v1p"
        },
        "18": {
          defaultClass: "ju367v1q"
        },
        "20": {
          defaultClass: "ju367v1r"
        },
        "24": {
          defaultClass: "ju367v1s"
        },
        "28": {
          defaultClass: "ju367v1t"
        },
        "32": {
          defaultClass: "ju367v1u"
        },
        "36": {
          defaultClass: "ju367v1v"
        },
        "44": {
          defaultClass: "ju367v1w"
        },
        "64": {
          defaultClass: "ju367v1x"
        },
        "-1": {
          defaultClass: "ju367v1y"
        }
      }
    },
    height: {
      values: {
        "1": {
          defaultClass: "ju367v1z"
        },
        "2": {
          defaultClass: "ju367v20"
        },
        "4": {
          defaultClass: "ju367v21"
        },
        "8": {
          defaultClass: "ju367v22"
        },
        "12": {
          defaultClass: "ju367v23"
        },
        "20": {
          defaultClass: "ju367v24"
        },
        "24": {
          defaultClass: "ju367v25"
        },
        "28": {
          defaultClass: "ju367v26"
        },
        "30": {
          defaultClass: "ju367v27"
        },
        "32": {
          defaultClass: "ju367v28"
        },
        "34": {
          defaultClass: "ju367v29"
        },
        "36": {
          defaultClass: "ju367v2a"
        },
        "40": {
          defaultClass: "ju367v2b"
        },
        "44": {
          defaultClass: "ju367v2c"
        },
        "48": {
          defaultClass: "ju367v2d"
        },
        "54": {
          defaultClass: "ju367v2e"
        },
        "60": {
          defaultClass: "ju367v2f"
        },
        "200": {
          defaultClass: "ju367v2g"
        },
        full: {
          defaultClass: "ju367v2h"
        },
        max: {
          defaultClass: "ju367v2i"
        }
      }
    },
    justifyContent: {
      values: {
        "flex-start": {
          defaultClass: "ju367v2j"
        },
        "flex-end": {
          defaultClass: "ju367v2k"
        },
        center: {
          defaultClass: "ju367v2l"
        },
        "space-between": {
          defaultClass: "ju367v2m"
        },
        "space-around": {
          defaultClass: "ju367v2n"
        }
      }
    },
    textAlign: {
      values: {
        left: {
          defaultClass: "ju367v2o"
        },
        center: {
          defaultClass: "ju367v2p"
        },
        inherit: {
          defaultClass: "ju367v2q"
        }
      }
    },
    marginBottom: {
      values: {
        "0": {
          defaultClass: "ju367v2r"
        },
        "1": {
          defaultClass: "ju367v2s"
        },
        "2": {
          defaultClass: "ju367v2t"
        },
        "3": {
          defaultClass: "ju367v2u"
        },
        "4": {
          defaultClass: "ju367v2v"
        },
        "5": {
          defaultClass: "ju367v2w"
        },
        "6": {
          defaultClass: "ju367v2x"
        },
        "8": {
          defaultClass: "ju367v2y"
        },
        "10": {
          defaultClass: "ju367v2z"
        },
        "12": {
          defaultClass: "ju367v30"
        },
        "14": {
          defaultClass: "ju367v31"
        },
        "16": {
          defaultClass: "ju367v32"
        },
        "18": {
          defaultClass: "ju367v33"
        },
        "20": {
          defaultClass: "ju367v34"
        },
        "24": {
          defaultClass: "ju367v35"
        },
        "28": {
          defaultClass: "ju367v36"
        },
        "32": {
          defaultClass: "ju367v37"
        },
        "36": {
          defaultClass: "ju367v38"
        },
        "44": {
          defaultClass: "ju367v39"
        },
        "64": {
          defaultClass: "ju367v3a"
        },
        "-1": {
          defaultClass: "ju367v3b"
        }
      }
    },
    marginLeft: {
      values: {
        "0": {
          defaultClass: "ju367v3c"
        },
        "1": {
          defaultClass: "ju367v3d"
        },
        "2": {
          defaultClass: "ju367v3e"
        },
        "3": {
          defaultClass: "ju367v3f"
        },
        "4": {
          defaultClass: "ju367v3g"
        },
        "5": {
          defaultClass: "ju367v3h"
        },
        "6": {
          defaultClass: "ju367v3i"
        },
        "8": {
          defaultClass: "ju367v3j"
        },
        "10": {
          defaultClass: "ju367v3k"
        },
        "12": {
          defaultClass: "ju367v3l"
        },
        "14": {
          defaultClass: "ju367v3m"
        },
        "16": {
          defaultClass: "ju367v3n"
        },
        "18": {
          defaultClass: "ju367v3o"
        },
        "20": {
          defaultClass: "ju367v3p"
        },
        "24": {
          defaultClass: "ju367v3q"
        },
        "28": {
          defaultClass: "ju367v3r"
        },
        "32": {
          defaultClass: "ju367v3s"
        },
        "36": {
          defaultClass: "ju367v3t"
        },
        "44": {
          defaultClass: "ju367v3u"
        },
        "64": {
          defaultClass: "ju367v3v"
        },
        "-1": {
          defaultClass: "ju367v3w"
        }
      }
    },
    marginRight: {
      values: {
        "0": {
          defaultClass: "ju367v3x"
        },
        "1": {
          defaultClass: "ju367v3y"
        },
        "2": {
          defaultClass: "ju367v3z"
        },
        "3": {
          defaultClass: "ju367v40"
        },
        "4": {
          defaultClass: "ju367v41"
        },
        "5": {
          defaultClass: "ju367v42"
        },
        "6": {
          defaultClass: "ju367v43"
        },
        "8": {
          defaultClass: "ju367v44"
        },
        "10": {
          defaultClass: "ju367v45"
        },
        "12": {
          defaultClass: "ju367v46"
        },
        "14": {
          defaultClass: "ju367v47"
        },
        "16": {
          defaultClass: "ju367v48"
        },
        "18": {
          defaultClass: "ju367v49"
        },
        "20": {
          defaultClass: "ju367v4a"
        },
        "24": {
          defaultClass: "ju367v4b"
        },
        "28": {
          defaultClass: "ju367v4c"
        },
        "32": {
          defaultClass: "ju367v4d"
        },
        "36": {
          defaultClass: "ju367v4e"
        },
        "44": {
          defaultClass: "ju367v4f"
        },
        "64": {
          defaultClass: "ju367v4g"
        },
        "-1": {
          defaultClass: "ju367v4h"
        }
      }
    },
    marginTop: {
      values: {
        "0": {
          defaultClass: "ju367v4i"
        },
        "1": {
          defaultClass: "ju367v4j"
        },
        "2": {
          defaultClass: "ju367v4k"
        },
        "3": {
          defaultClass: "ju367v4l"
        },
        "4": {
          defaultClass: "ju367v4m"
        },
        "5": {
          defaultClass: "ju367v4n"
        },
        "6": {
          defaultClass: "ju367v4o"
        },
        "8": {
          defaultClass: "ju367v4p"
        },
        "10": {
          defaultClass: "ju367v4q"
        },
        "12": {
          defaultClass: "ju367v4r"
        },
        "14": {
          defaultClass: "ju367v4s"
        },
        "16": {
          defaultClass: "ju367v4t"
        },
        "18": {
          defaultClass: "ju367v4u"
        },
        "20": {
          defaultClass: "ju367v4v"
        },
        "24": {
          defaultClass: "ju367v4w"
        },
        "28": {
          defaultClass: "ju367v4x"
        },
        "32": {
          defaultClass: "ju367v4y"
        },
        "36": {
          defaultClass: "ju367v4z"
        },
        "44": {
          defaultClass: "ju367v50"
        },
        "64": {
          defaultClass: "ju367v51"
        },
        "-1": {
          defaultClass: "ju367v52"
        }
      }
    },
    maxWidth: {
      values: {
        "1": {
          defaultClass: "ju367v53"
        },
        "2": {
          defaultClass: "ju367v54"
        },
        "4": {
          defaultClass: "ju367v55"
        },
        "8": {
          defaultClass: "ju367v56"
        },
        "12": {
          defaultClass: "ju367v57"
        },
        "20": {
          defaultClass: "ju367v58"
        },
        "24": {
          defaultClass: "ju367v59"
        },
        "28": {
          defaultClass: "ju367v5a"
        },
        "30": {
          defaultClass: "ju367v5b"
        },
        "32": {
          defaultClass: "ju367v5c"
        },
        "34": {
          defaultClass: "ju367v5d"
        },
        "36": {
          defaultClass: "ju367v5e"
        },
        "40": {
          defaultClass: "ju367v5f"
        },
        "44": {
          defaultClass: "ju367v5g"
        },
        "48": {
          defaultClass: "ju367v5h"
        },
        "54": {
          defaultClass: "ju367v5i"
        },
        "60": {
          defaultClass: "ju367v5j"
        },
        "200": {
          defaultClass: "ju367v5k"
        },
        full: {
          defaultClass: "ju367v5l"
        },
        max: {
          defaultClass: "ju367v5m"
        }
      }
    },
    minWidth: {
      values: {
        "1": {
          defaultClass: "ju367v5n"
        },
        "2": {
          defaultClass: "ju367v5o"
        },
        "4": {
          defaultClass: "ju367v5p"
        },
        "8": {
          defaultClass: "ju367v5q"
        },
        "12": {
          defaultClass: "ju367v5r"
        },
        "20": {
          defaultClass: "ju367v5s"
        },
        "24": {
          defaultClass: "ju367v5t"
        },
        "28": {
          defaultClass: "ju367v5u"
        },
        "30": {
          defaultClass: "ju367v5v"
        },
        "32": {
          defaultClass: "ju367v5w"
        },
        "34": {
          defaultClass: "ju367v5x"
        },
        "36": {
          defaultClass: "ju367v5y"
        },
        "40": {
          defaultClass: "ju367v5z"
        },
        "44": {
          defaultClass: "ju367v60"
        },
        "48": {
          defaultClass: "ju367v61"
        },
        "54": {
          defaultClass: "ju367v62"
        },
        "60": {
          defaultClass: "ju367v63"
        },
        "200": {
          defaultClass: "ju367v64"
        },
        full: {
          defaultClass: "ju367v65"
        },
        max: {
          defaultClass: "ju367v66"
        }
      }
    },
    overflow: {
      values: {
        hidden: {
          defaultClass: "ju367v67"
        }
      }
    },
    paddingBottom: {
      values: {
        "0": {
          defaultClass: "ju367v68"
        },
        "1": {
          defaultClass: "ju367v69"
        },
        "2": {
          defaultClass: "ju367v6a"
        },
        "3": {
          defaultClass: "ju367v6b"
        },
        "4": {
          defaultClass: "ju367v6c"
        },
        "5": {
          defaultClass: "ju367v6d"
        },
        "6": {
          defaultClass: "ju367v6e"
        },
        "8": {
          defaultClass: "ju367v6f"
        },
        "10": {
          defaultClass: "ju367v6g"
        },
        "12": {
          defaultClass: "ju367v6h"
        },
        "14": {
          defaultClass: "ju367v6i"
        },
        "16": {
          defaultClass: "ju367v6j"
        },
        "18": {
          defaultClass: "ju367v6k"
        },
        "20": {
          defaultClass: "ju367v6l"
        },
        "24": {
          defaultClass: "ju367v6m"
        },
        "28": {
          defaultClass: "ju367v6n"
        },
        "32": {
          defaultClass: "ju367v6o"
        },
        "36": {
          defaultClass: "ju367v6p"
        },
        "44": {
          defaultClass: "ju367v6q"
        },
        "64": {
          defaultClass: "ju367v6r"
        },
        "-1": {
          defaultClass: "ju367v6s"
        }
      }
    },
    paddingLeft: {
      values: {
        "0": {
          defaultClass: "ju367v6t"
        },
        "1": {
          defaultClass: "ju367v6u"
        },
        "2": {
          defaultClass: "ju367v6v"
        },
        "3": {
          defaultClass: "ju367v6w"
        },
        "4": {
          defaultClass: "ju367v6x"
        },
        "5": {
          defaultClass: "ju367v6y"
        },
        "6": {
          defaultClass: "ju367v6z"
        },
        "8": {
          defaultClass: "ju367v70"
        },
        "10": {
          defaultClass: "ju367v71"
        },
        "12": {
          defaultClass: "ju367v72"
        },
        "14": {
          defaultClass: "ju367v73"
        },
        "16": {
          defaultClass: "ju367v74"
        },
        "18": {
          defaultClass: "ju367v75"
        },
        "20": {
          defaultClass: "ju367v76"
        },
        "24": {
          defaultClass: "ju367v77"
        },
        "28": {
          defaultClass: "ju367v78"
        },
        "32": {
          defaultClass: "ju367v79"
        },
        "36": {
          defaultClass: "ju367v7a"
        },
        "44": {
          defaultClass: "ju367v7b"
        },
        "64": {
          defaultClass: "ju367v7c"
        },
        "-1": {
          defaultClass: "ju367v7d"
        }
      }
    },
    paddingRight: {
      values: {
        "0": {
          defaultClass: "ju367v7e"
        },
        "1": {
          defaultClass: "ju367v7f"
        },
        "2": {
          defaultClass: "ju367v7g"
        },
        "3": {
          defaultClass: "ju367v7h"
        },
        "4": {
          defaultClass: "ju367v7i"
        },
        "5": {
          defaultClass: "ju367v7j"
        },
        "6": {
          defaultClass: "ju367v7k"
        },
        "8": {
          defaultClass: "ju367v7l"
        },
        "10": {
          defaultClass: "ju367v7m"
        },
        "12": {
          defaultClass: "ju367v7n"
        },
        "14": {
          defaultClass: "ju367v7o"
        },
        "16": {
          defaultClass: "ju367v7p"
        },
        "18": {
          defaultClass: "ju367v7q"
        },
        "20": {
          defaultClass: "ju367v7r"
        },
        "24": {
          defaultClass: "ju367v7s"
        },
        "28": {
          defaultClass: "ju367v7t"
        },
        "32": {
          defaultClass: "ju367v7u"
        },
        "36": {
          defaultClass: "ju367v7v"
        },
        "44": {
          defaultClass: "ju367v7w"
        },
        "64": {
          defaultClass: "ju367v7x"
        },
        "-1": {
          defaultClass: "ju367v7y"
        }
      }
    },
    paddingTop: {
      values: {
        "0": {
          defaultClass: "ju367v7z"
        },
        "1": {
          defaultClass: "ju367v80"
        },
        "2": {
          defaultClass: "ju367v81"
        },
        "3": {
          defaultClass: "ju367v82"
        },
        "4": {
          defaultClass: "ju367v83"
        },
        "5": {
          defaultClass: "ju367v84"
        },
        "6": {
          defaultClass: "ju367v85"
        },
        "8": {
          defaultClass: "ju367v86"
        },
        "10": {
          defaultClass: "ju367v87"
        },
        "12": {
          defaultClass: "ju367v88"
        },
        "14": {
          defaultClass: "ju367v89"
        },
        "16": {
          defaultClass: "ju367v8a"
        },
        "18": {
          defaultClass: "ju367v8b"
        },
        "20": {
          defaultClass: "ju367v8c"
        },
        "24": {
          defaultClass: "ju367v8d"
        },
        "28": {
          defaultClass: "ju367v8e"
        },
        "32": {
          defaultClass: "ju367v8f"
        },
        "36": {
          defaultClass: "ju367v8g"
        },
        "44": {
          defaultClass: "ju367v8h"
        },
        "64": {
          defaultClass: "ju367v8i"
        },
        "-1": {
          defaultClass: "ju367v8j"
        }
      }
    },
    position: {
      values: {
        absolute: {
          defaultClass: "ju367v8k"
        },
        fixed: {
          defaultClass: "ju367v8l"
        },
        relative: {
          defaultClass: "ju367v8m"
        }
      }
    },
    right: {
      values: {
        "0": {
          defaultClass: "ju367v8n"
        }
      }
    },
    transition: {
      values: {
        "default": {
          defaultClass: "ju367v8o"
        },
        transform: {
          defaultClass: "ju367v8p"
        }
      }
    },
    userSelect: {
      values: {
        none: {
          defaultClass: "ju367v8q"
        }
      }
    },
    width: {
      values: {
        "1": {
          defaultClass: "ju367v8r"
        },
        "2": {
          defaultClass: "ju367v8s"
        },
        "4": {
          defaultClass: "ju367v8t"
        },
        "8": {
          defaultClass: "ju367v8u"
        },
        "12": {
          defaultClass: "ju367v8v"
        },
        "20": {
          defaultClass: "ju367v8w"
        },
        "24": {
          defaultClass: "ju367v8x"
        },
        "28": {
          defaultClass: "ju367v8y"
        },
        "30": {
          defaultClass: "ju367v8z"
        },
        "32": {
          defaultClass: "ju367v90"
        },
        "34": {
          defaultClass: "ju367v91"
        },
        "36": {
          defaultClass: "ju367v92"
        },
        "40": {
          defaultClass: "ju367v93"
        },
        "44": {
          defaultClass: "ju367v94"
        },
        "48": {
          defaultClass: "ju367v95"
        },
        "54": {
          defaultClass: "ju367v96"
        },
        "60": {
          defaultClass: "ju367v97"
        },
        "200": {
          defaultClass: "ju367v98"
        },
        full: {
          defaultClass: "ju367v99"
        },
        max: {
          defaultClass: "ju367v9a"
        }
      }
    },
    backdropFilter: {
      values: {
        modalOverlay: {
          defaultClass: "ju367v9b"
        }
      }
    }
  }
});
var themeVars = {
  colors: {
    accentColor: "var(--rk-colors-accentColor)",
    accentColorForeground: "var(--rk-colors-accentColorForeground)",
    actionButtonBorder: "var(--rk-colors-actionButtonBorder)",
    actionButtonBorderMobile: "var(--rk-colors-actionButtonBorderMobile)",
    actionButtonSecondaryBackground: "var(--rk-colors-actionButtonSecondaryBackground)",
    closeButton: "var(--rk-colors-closeButton)",
    closeButtonBackground: "var(--rk-colors-closeButtonBackground)",
    connectButtonBackground: "var(--rk-colors-connectButtonBackground)",
    connectButtonBackgroundError: "var(--rk-colors-connectButtonBackgroundError)",
    connectButtonInnerBackground: "var(--rk-colors-connectButtonInnerBackground)",
    connectButtonText: "var(--rk-colors-connectButtonText)",
    connectButtonTextError: "var(--rk-colors-connectButtonTextError)",
    connectionIndicator: "var(--rk-colors-connectionIndicator)",
    downloadBottomCardBackground: "var(--rk-colors-downloadBottomCardBackground)",
    downloadTopCardBackground: "var(--rk-colors-downloadTopCardBackground)",
    error: "var(--rk-colors-error)",
    generalBorder: "var(--rk-colors-generalBorder)",
    generalBorderDim: "var(--rk-colors-generalBorderDim)",
    menuItemBackground: "var(--rk-colors-menuItemBackground)",
    modalBackdrop: "var(--rk-colors-modalBackdrop)",
    modalBackground: "var(--rk-colors-modalBackground)",
    modalBorder: "var(--rk-colors-modalBorder)",
    modalText: "var(--rk-colors-modalText)",
    modalTextDim: "var(--rk-colors-modalTextDim)",
    modalTextSecondary: "var(--rk-colors-modalTextSecondary)",
    profileAction: "var(--rk-colors-profileAction)",
    profileActionHover: "var(--rk-colors-profileActionHover)",
    profileForeground: "var(--rk-colors-profileForeground)",
    selectedOptionBorder: "var(--rk-colors-selectedOptionBorder)",
    standby: "var(--rk-colors-standby)"
  },
  fonts: {
    body: "var(--rk-fonts-body)"
  },
  radii: {
    actionButton: "var(--rk-radii-actionButton)",
    connectButton: "var(--rk-radii-connectButton)",
    menuButton: "var(--rk-radii-menuButton)",
    modal: "var(--rk-radii-modal)",
    modalMobile: "var(--rk-radii-modalMobile)"
  },
  shadows: {
    connectButton: "var(--rk-shadows-connectButton)",
    dialog: "var(--rk-shadows-dialog)",
    profileDetailsAction: "var(--rk-shadows-profileDetailsAction)",
    selectedOption: "var(--rk-shadows-selectedOption)",
    selectedWallet: "var(--rk-shadows-selectedWallet)",
    walletLogo: "var(--rk-shadows-walletLogo)"
  },
  blurs: {
    modalOverlay: "var(--rk-blurs-modalOverlay)"
  }
};
var active = {
  shrink: "_12cbo8i6",
  shrinkSm: "_12cbo8i7"
};
var base$1 = "_12cbo8i3 ju367v8m";
var hover = {
  grow: "_12cbo8i4",
  growLg: "_12cbo8i5"
};
function touchableStyles({
  active: active2,
  hover: hover2
}) {
  return [base$1, hover2 && hover[hover2], active[active2]];
}
function createAuthenticationAdapter(adapter) {
  return adapter;
}
var AuthenticationContext = React48.createContext(null);
function RainbowKitAuthenticationProvider({
  adapter,
  children,
  enabled = true,
  status
}) {
  wagmi.useAccount({
    onDisconnect: () => {
      adapter.signOut();
    }
  });
  const {
    isDisconnected
  } = wagmi.useAccount();
  const onceRef = React48.useRef(false);
  React48.useEffect(() => {
    if (onceRef.current)
      return;
    onceRef.current = true;
    if (isDisconnected && status === "authenticated") {
      adapter.signOut();
    }
  }, [status, adapter, isDisconnected]);
  return /* @__PURE__ */ React48__default.default.createElement(AuthenticationContext.Provider, {
    value: React48.useMemo(() => enabled ? {
      adapter,
      status
    } : null, [enabled, adapter, status])
  }, children);
}
function useAuthenticationAdapter() {
  var _a2;
  const {
    adapter
  } = (_a2 = React48.useContext(AuthenticationContext)) != null ? _a2 : {};
  if (!adapter) {
    throw new Error("No authentication adapter found");
  }
  return adapter;
}
function useAuthenticationStatus() {
  var _a2;
  const contextValue = React48.useContext(AuthenticationContext);
  return (_a2 = contextValue == null ? void 0 : contextValue.status) != null ? _a2 : null;
}
function useConnectionStatus() {
  const authenticationStatus = useAuthenticationStatus();
  const {
    isConnected
  } = wagmi.useAccount();
  if (!isConnected) {
    return "disconnected";
  }
  if (!authenticationStatus) {
    return "connected";
  }
  if (authenticationStatus === "loading" || authenticationStatus === "unauthenticated") {
    return authenticationStatus;
  }
  return "connected";
}
function isAndroid$1() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS$1() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile$1() {
  return isAndroid$1() || isSmallIOS();
}
var base2 = "iekbcc0";
var element = {
  a: "iekbcca",
  blockquote: "iekbcc2",
  button: "iekbcc9",
  input: "iekbcc8 iekbcc5 iekbcc4",
  mark: "iekbcc6",
  ol: "iekbcc1",
  q: "iekbcc2",
  select: "iekbcc7 iekbcc5 iekbcc4",
  table: "iekbcc3",
  textarea: "iekbcc5 iekbcc4",
  ul: "iekbcc1"
};
var atoms = ({
  reset,
  ...rest
}) => {
  if (!reset)
    return sprinkles(rest);
  const elementReset = element[reset];
  const sprinklesClasses = sprinkles(rest);
  return clsx2(base2, elementReset, sprinklesClasses);
};
var Box = React48__namespace.forwardRef(({
  as = "div",
  className,
  testId,
  ...props
}, ref) => {
  const atomProps = {};
  const nativeProps = {};
  for (const key2 in props) {
    if (sprinkles.properties.has(key2)) {
      atomProps[key2] = props[key2];
    } else {
      nativeProps[key2] = props[key2];
    }
  }
  const atomicClasses = atoms({
    reset: typeof as === "string" ? as : "div",
    ...atomProps
  });
  return React48__namespace.createElement(as, {
    "className": clsx2(atomicClasses, className),
    ...nativeProps,
    "data-testid": testId ? `rk-${testId.replace(/^rk-/, "")}` : void 0,
    ref
  });
});
Box.displayName = "Box";
var cachedUrls = /* @__PURE__ */ new Map();
var cachedRequestPromises = /* @__PURE__ */ new Map();
async function loadAsyncImage(asyncImage) {
  const cachedRequestPromise = cachedRequestPromises.get(asyncImage);
  if (cachedRequestPromise) {
    return cachedRequestPromise;
  }
  const load = async () => asyncImage().then(async (url) => {
    cachedUrls.set(asyncImage, url);
    return url;
  });
  const requestPromise = load().catch((_err) => {
    return load().catch((_err2) => {
      cachedRequestPromises.delete(asyncImage);
    });
  });
  cachedRequestPromises.set(asyncImage, requestPromise);
  return requestPromise;
}
async function loadImages(...urls) {
  return await Promise.all(urls.map((url) => typeof url === "function" ? loadAsyncImage(url) : url));
}
function useForceUpdate() {
  const [, forceUpdate] = React48.useReducer((x2) => x2 + 1, 0);
  return forceUpdate;
}
function useAsyncImage(url) {
  const cachedUrl = typeof url === "function" ? cachedUrls.get(url) : void 0;
  const forceUpdate = useForceUpdate();
  React48.useEffect(() => {
    if (typeof url === "function" && !cachedUrl) {
      loadAsyncImage(url).then(forceUpdate);
    }
  }, [url, cachedUrl, forceUpdate]);
  return typeof url === "function" ? cachedUrl : url;
}
function AsyncImage({
  alt,
  background,
  borderColor,
  borderRadius,
  boxShadow,
  height,
  src: srcProp,
  width
}) {
  const src6 = useAsyncImage(srcProp);
  const isRemoteImage = src6 && /^http/.test(src6);
  const [isRemoteImageLoaded, setRemoteImageLoaded] = React48.useReducer(() => true, false);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    "aria-label": alt,
    borderRadius,
    boxShadow,
    height: typeof height === "string" ? height : void 0,
    overflow: "hidden",
    position: "relative",
    role: "img",
    style: {
      background,
      height: typeof height === "number" ? height : void 0,
      width: typeof width === "number" ? width : void 0
    },
    width: typeof width === "string" ? width : void 0
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...isRemoteImage ? {
      "aria-hidden": true,
      "as": "img",
      "onLoad": setRemoteImageLoaded,
      "src": src6
    } : {
      backgroundSize: "cover"
    },
    height: "full",
    position: "absolute",
    style: {
      touchCallout: "none",
      transition: "opacity .15s linear",
      userSelect: "none",
      ...isRemoteImage ? {
        opacity: isRemoteImageLoaded ? 1 : 0
      } : {
        backgroundImage: src6 ? `url(${src6})` : void 0,
        backgroundRepeat: "no-repeat",
        opacity: src6 ? 1 : 0
      }
    },
    width: "full"
  }), borderColor ? /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...typeof borderColor === "object" && "custom" in borderColor ? {
      style: {
        borderColor: borderColor.custom
      }
    } : {
      borderColor
    },
    borderRadius,
    borderStyle: "solid",
    borderWidth: "1",
    height: "full",
    position: "relative",
    width: "full"
  }) : null);
}
var SpinnerIconClassName = "_1luule42";
var SpinnerIconPathClassName = "_1luule43";
var useRandomId = (prefix) => React48.useMemo(() => `${prefix}_${Math.round(Math.random() * 1e9)}`, [prefix]);
var SpinnerIcon = ({
  height = 21,
  width = 21
}) => {
  const id2 = useRandomId("spinner");
  return /* @__PURE__ */ React48__default.default.createElement("svg", {
    className: SpinnerIconClassName,
    fill: "none",
    height,
    viewBox: "0 0 21 21",
    width,
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React48__default.default.createElement("clipPath", {
    id: id2
  }, /* @__PURE__ */ React48__default.default.createElement("path", {
    d: "M10.5 3C6.35786 3 3 6.35786 3 10.5C3 14.6421 6.35786 18 10.5 18C11.3284 18 12 18.6716 12 19.5C12 20.3284 11.3284 21 10.5 21C4.70101 21 0 16.299 0 10.5C0 4.70101 4.70101 0 10.5 0C16.299 0 21 4.70101 21 10.5C21 11.3284 20.3284 12 19.5 12C18.6716 12 18 11.3284 18 10.5C18 6.35786 14.6421 3 10.5 3Z"
  })), /* @__PURE__ */ React48__default.default.createElement("foreignObject", {
    clipPath: `url(#${id2})`,
    height: "21",
    width: "21",
    x: "0",
    y: "0"
  }, /* @__PURE__ */ React48__default.default.createElement("div", {
    className: SpinnerIconPathClassName
  })));
};
var colors = ["#FC5C54", "#FFD95A", "#E95D72", "#6A87C8", "#5FD0F3", "#75C06B", "#FFDD86", "#5FC6D4", "#FF949A", "#FF8024", "#9BA1A4", "#EC66FF", "#FF8CBC", "#FF9A23", "#C5DADB", "#A8CE63", "#71ABFF", "#FFE279", "#B6B1B6", "#FF6780", "#A575FF", "#4D82FF", "#FFB35A"];
var avatars = [{
  color: colors[0],
  emoji: "\u{1F336}"
}, {
  color: colors[1],
  emoji: "\u{1F911}"
}, {
  color: colors[2],
  emoji: "\u{1F419}"
}, {
  color: colors[3],
  emoji: "\u{1FAD0}"
}, {
  color: colors[4],
  emoji: "\u{1F433}"
}, {
  color: colors[0],
  emoji: "\u{1F936}"
}, {
  color: colors[5],
  emoji: "\u{1F332}"
}, {
  color: colors[6],
  emoji: "\u{1F31E}"
}, {
  color: colors[7],
  emoji: "\u{1F412}"
}, {
  color: colors[8],
  emoji: "\u{1F435}"
}, {
  color: colors[9],
  emoji: "\u{1F98A}"
}, {
  color: colors[10],
  emoji: "\u{1F43C}"
}, {
  color: colors[11],
  emoji: "\u{1F984}"
}, {
  color: colors[12],
  emoji: "\u{1F437}"
}, {
  color: colors[13],
  emoji: "\u{1F427}"
}, {
  color: colors[8],
  emoji: "\u{1F9A9}"
}, {
  color: colors[14],
  emoji: "\u{1F47D}"
}, {
  color: colors[0],
  emoji: "\u{1F388}"
}, {
  color: colors[8],
  emoji: "\u{1F349}"
}, {
  color: colors[1],
  emoji: "\u{1F389}"
}, {
  color: colors[15],
  emoji: "\u{1F432}"
}, {
  color: colors[16],
  emoji: "\u{1F30E}"
}, {
  color: colors[17],
  emoji: "\u{1F34A}"
}, {
  color: colors[18],
  emoji: "\u{1F42D}"
}, {
  color: colors[19],
  emoji: "\u{1F363}"
}, {
  color: colors[1],
  emoji: "\u{1F425}"
}, {
  color: colors[20],
  emoji: "\u{1F47E}"
}, {
  color: colors[15],
  emoji: "\u{1F966}"
}, {
  color: colors[0],
  emoji: "\u{1F479}"
}, {
  color: colors[17],
  emoji: "\u{1F640}"
}, {
  color: colors[4],
  emoji: "\u26F1"
}, {
  color: colors[21],
  emoji: "\u26F5\uFE0F"
}, {
  color: colors[17],
  emoji: "\u{1F973}"
}, {
  color: colors[8],
  emoji: "\u{1F92F}"
}, {
  color: colors[22],
  emoji: "\u{1F920}"
}];
function hashCode(text) {
  let hash2 = 0;
  if (text.length === 0)
    return hash2;
  for (let i = 0; i < text.length; i++) {
    const chr = text.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  return hash2;
}
function emojiAvatarForAddress(address) {
  const resolvedAddress = typeof address === "string" ? address : "";
  const avatarIndex = Math.abs(hashCode(resolvedAddress.toLowerCase()) % avatars.length);
  return avatars[avatarIndex != null ? avatarIndex : 0];
}
var EmojiAvatar = ({
  address,
  ensImage,
  size: size2
}) => {
  const [loaded, setLoaded] = React48.useState(false);
  React48.useEffect(() => {
    if (ensImage) {
      const img = new Image();
      img.src = ensImage;
      img.onload = () => setLoaded(true);
    }
  }, [ensImage]);
  const {
    color: backgroundColor,
    emoji
  } = React48.useMemo(() => emojiAvatarForAddress(address), [address]);
  return ensImage ? loaded ? /* @__PURE__ */ React48__default.default.createElement(Box, {
    backgroundSize: "cover",
    borderRadius: "full",
    position: "absolute",
    style: {
      backgroundImage: `url(${ensImage})`,
      backgroundPosition: "center",
      height: size2,
      width: size2
    }
  }) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    backgroundSize: "cover",
    borderRadius: "full",
    color: "modalText",
    display: "flex",
    justifyContent: "center",
    position: "absolute",
    style: {
      height: size2,
      width: size2
    }
  }, /* @__PURE__ */ React48__default.default.createElement(SpinnerIcon, null)) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    justifyContent: "center",
    overflow: "hidden",
    style: {
      ...!ensImage && {
        backgroundColor
      },
      height: size2,
      width: size2
    }
  }, emoji);
};
var defaultAvatar = EmojiAvatar;
var AvatarContext = React48.createContext(defaultAvatar);
function Avatar({
  address,
  imageUrl,
  loading,
  size: size2
}) {
  const AvatarComponent2 = React48.useContext(AvatarContext);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    "aria-hidden": true,
    borderRadius: "full",
    overflow: "hidden",
    position: "relative",
    style: {
      height: `${size2}px`,
      width: `${size2}px`
    },
    userSelect: "none"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    borderRadius: "full",
    display: "flex",
    justifyContent: "center",
    overflow: "hidden",
    position: "absolute",
    style: {
      fontSize: `${Math.round(size2 * 0.55)}px`,
      height: `${size2}px`,
      transform: loading ? "scale(0.72)" : void 0,
      transition: ".25s ease",
      transitionDelay: loading ? void 0 : ".1s",
      width: `${size2}px`,
      willChange: "transform"
    },
    userSelect: "none"
  }, /* @__PURE__ */ React48__default.default.createElement(AvatarComponent2, {
    address,
    ensImage: imageUrl,
    size: size2
  })), typeof loading === "boolean" && /* @__PURE__ */ React48__default.default.createElement(Box, {
    color: "accentColor",
    display: "flex",
    height: "full",
    position: "absolute",
    style: {
      opacity: loading ? 1 : 0,
      transition: loading ? "0.6s ease" : "0.2s ease",
      transitionDelay: loading ? ".05s" : void 0
    },
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(SpinnerIcon, {
    height: "100%",
    width: "100%"
  })));
}
var DropdownIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "7",
  width: "14",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M12.75 1.54001L8.51647 5.0038C7.77974 5.60658 6.72026 5.60658 5.98352 5.0038L1.75 1.54001",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "2.5",
  xmlns: "http://www.w3.org/2000/svg"
}));
function isNotNullish(value) {
  return value != null;
}
var arbitrumIcon = {
  iconBackground: "#96bedc",
  iconUrl: async () => (await Promise.resolve($$6)).default
};
var avalancheIcon = {
  iconBackground: "#e84141",
  iconUrl: async () => (await Promise.resolve($$7)).default
};
var baseIcon = {
  iconBackground: "#0052ff",
  iconUrl: async () => (await Promise.resolve($$8)).default
};
var bscIcon = {
  iconBackground: "#ebac0e",
  iconUrl: async () => (await Promise.resolve($$9)).default
};
var ethereumIcon = {
  iconBackground: "#484c50",
  iconUrl: async () => (await Promise.resolve($$10)).default
};
var hardhatIcon = {
  iconBackground: "#f9f7ec",
  iconUrl: async () => (await Promise.resolve($$11)).default
};
var optimismIcon = {
  iconBackground: "#ff5a57",
  iconUrl: async () => (await Promise.resolve($$12)).default
};
var polygonIcon = {
  iconBackground: "#9f71ec",
  iconUrl: async () => (await Promise.resolve($$13)).default
};
var chainMetadataByName = {
  arbitrum: {
    chainId: 42161,
    ...arbitrumIcon
  },
  arbitrumRinkeby: {
    chainId: 421611,
    ...arbitrumIcon
  },
  avalanche: {
    chainId: 43114,
    ...avalancheIcon
  },
  avalancheFuji: {
    chainId: 43113,
    ...avalancheIcon
  },
  baseGoerli: {
    chainId: 84531,
    ...baseIcon
  },
  bsc: {
    chainId: 56,
    ...bscIcon
  },
  bscTestnet: {
    chainId: 97,
    ...bscIcon
  },
  goerli: {
    chainId: 5,
    ...ethereumIcon
  },
  hardhat: {
    chainId: 31337,
    ...hardhatIcon
  },
  kovan: {
    chainId: 42,
    ...ethereumIcon
  },
  localhost: {
    chainId: 1337,
    ...ethereumIcon
  },
  mainnet: {
    chainId: 1,
    ...ethereumIcon
  },
  optimism: {
    chainId: 10,
    ...optimismIcon
  },
  optimismGoerli: {
    chainId: 420,
    ...optimismIcon
  },
  optimismKovan: {
    chainId: 69,
    ...optimismIcon
  },
  polygon: {
    chainId: 137,
    ...polygonIcon
  },
  polygonMumbai: {
    chainId: 80001,
    ...polygonIcon
  },
  rinkeby: {
    chainId: 4,
    ...ethereumIcon
  },
  ropsten: {
    chainId: 3,
    ...ethereumIcon
  },
  sepolia: {
    chainId: 11155111,
    ...ethereumIcon
  }
};
var chainMetadataById = Object.fromEntries(Object.values(chainMetadataByName).filter(isNotNullish).map(({
  chainId,
  ...metadata
}) => [chainId, metadata]));
var provideRainbowKitChains = (chains) => chains.map((chain) => {
  var _a2;
  return {
    ...(_a2 = chainMetadataById[chain.id]) != null ? _a2 : {},
    ...chain
  };
});
var RainbowKitChainContext = React48.createContext({
  chains: []
});
function RainbowKitChainProvider({
  chains,
  children,
  initialChain
}) {
  return /* @__PURE__ */ React48__default.default.createElement(RainbowKitChainContext.Provider, {
    value: React48.useMemo(() => ({
      chains: provideRainbowKitChains(chains),
      initialChainId: typeof initialChain === "number" ? initialChain : initialChain == null ? void 0 : initialChain.id
    }), [chains, initialChain])
  }, children);
}
var useRainbowKitChains = () => React48.useContext(RainbowKitChainContext).chains;
var useInitialChainId = () => React48.useContext(RainbowKitChainContext).initialChainId;
var useRainbowKitChainsById = () => {
  const rainbowkitChains = useRainbowKitChains();
  return React48.useMemo(() => {
    const rainbowkitChainsById = {};
    rainbowkitChains.forEach((rkChain) => {
      rainbowkitChainsById[rkChain.id] = rkChain;
    });
    return rainbowkitChainsById;
  }, [rainbowkitChains]);
};
var useIsMounted = () => {
  const [mounted, setMounted] = React48.useReducer(() => true, false);
  React48.useEffect(setMounted, [setMounted]);
  return mounted;
};
function useMainnet() {
  const chainId = mainnet.id;
  const provider = wagmi.useProvider();
  const chains = Array.isArray(provider.chains) ? provider.chains : [];
  const enabled = chains == null ? void 0 : chains.some((chain) => (chain == null ? void 0 : chain.id) === chainId);
  return {
    chainId,
    enabled
  };
}
function useMainnetEnsAvatar(address) {
  const {
    chainId,
    enabled
  } = useMainnet();
  const {
    data: ensAvatar
  } = wagmi.useEnsAvatar({
    address,
    chainId,
    enabled
  });
  return ensAvatar;
}
function useMainnetEnsName(address) {
  const {
    chainId,
    enabled
  } = useMainnet();
  const {
    data: ensName
  } = wagmi.useEnsName({
    address,
    chainId,
    enabled
  });
  return ensName;
}
function useChainId() {
  var _a2;
  const {
    chain: activeChain
  } = wagmi.useNetwork();
  return (_a2 = activeChain == null ? void 0 : activeChain.id) != null ? _a2 : null;
}
var storageKey = "rk-transactions";
function safeParseJsonData(string2) {
  try {
    const value = string2 ? JSON.parse(string2) : {};
    return typeof value === "object" ? value : {};
  } catch (err) {
    return {};
  }
}
function loadData() {
  return safeParseJsonData(typeof localStorage !== "undefined" ? localStorage.getItem(storageKey) : null);
}
var transactionHashRegex = /^0x([A-Fa-f0-9]{64})$/;
function validateTransaction(transaction) {
  const errors2 = [];
  if (!transactionHashRegex.test(transaction.hash)) {
    errors2.push("Invalid transaction hash");
  }
  if (typeof transaction.description !== "string") {
    errors2.push("Transaction must have a description");
  }
  if (typeof transaction.confirmations !== "undefined" && (!Number.isInteger(transaction.confirmations) || transaction.confirmations < 1)) {
    errors2.push("Transaction confirmations must be a positiver integer");
  }
  return errors2;
}
function createTransactionStore({
  provider: initialProvider
}) {
  let data = loadData();
  let provider = initialProvider;
  const listeners2 = /* @__PURE__ */ new Set();
  const transactionRequestCache = /* @__PURE__ */ new Map();
  function setProvider(newProvider) {
    provider = newProvider;
  }
  function getTransactions(account, chainId) {
    var _a2, _b2;
    return (_b2 = (_a2 = data[account]) == null ? void 0 : _a2[chainId]) != null ? _b2 : [];
  }
  function addTransaction(account, chainId, transaction) {
    const errors2 = validateTransaction(transaction);
    if (errors2.length > 0) {
      throw new Error(["Unable to add transaction", ...errors2].join("\n"));
    }
    updateTransactions(account, chainId, (transactions) => {
      return [{
        ...transaction,
        status: "pending"
      }, ...transactions.filter(({
        hash: hash2
      }) => {
        return hash2 !== transaction.hash;
      })];
    });
  }
  function clearTransactions(account, chainId) {
    updateTransactions(account, chainId, () => {
      return [];
    });
  }
  function setTransactionStatus(account, chainId, hash2, status) {
    updateTransactions(account, chainId, (transactions) => {
      return transactions.map((transaction) => transaction.hash === hash2 ? {
        ...transaction,
        status
      } : transaction);
    });
  }
  async function waitForPendingTransactions(account, chainId) {
    await Promise.all(getTransactions(account, chainId).filter((transaction) => transaction.status === "pending").map(async (transaction) => {
      const {
        confirmations,
        hash: hash2
      } = transaction;
      const existingRequest = transactionRequestCache.get(hash2);
      if (existingRequest) {
        return await existingRequest;
      }
      const requestPromise = provider.waitForTransaction(hash2, confirmations).then(({
        status
      }) => {
        transactionRequestCache.delete(hash2);
        if (status === void 0) {
          return;
        }
        setTransactionStatus(account, chainId, hash2, status === 0 ? "failed" : "confirmed");
      });
      transactionRequestCache.set(hash2, requestPromise);
      return await requestPromise;
    }));
  }
  function updateTransactions(account, chainId, updateFn) {
    var _a2, _b2;
    data = loadData();
    data[account] = (_a2 = data[account]) != null ? _a2 : {};
    let completedTransactionCount = 0;
    const MAX_COMPLETED_TRANSACTIONS = 10;
    const transactions = updateFn((_b2 = data[account][chainId]) != null ? _b2 : []).filter(({
      status
    }) => {
      return status === "pending" ? true : completedTransactionCount++ <= MAX_COMPLETED_TRANSACTIONS;
    });
    data[account][chainId] = transactions.length > 0 ? transactions : void 0;
    persistData();
    notifyListeners();
    waitForPendingTransactions(account, chainId);
  }
  function persistData() {
    localStorage.setItem(storageKey, JSON.stringify(data));
  }
  function notifyListeners() {
    listeners2.forEach((listener) => listener());
  }
  function onChange(fn2) {
    listeners2.add(fn2);
    return () => {
      listeners2.delete(fn2);
    };
  }
  return {
    addTransaction,
    clearTransactions,
    getTransactions,
    onChange,
    setProvider,
    waitForPendingTransactions
  };
}
var storeSingleton;
var TransactionStoreContext = React48.createContext(null);
function TransactionStoreProvider({
  children
}) {
  const provider = wagmi.useProvider();
  const {
    address
  } = wagmi.useAccount();
  const chainId = useChainId();
  const [store] = React48.useState(() => storeSingleton != null ? storeSingleton : storeSingleton = createTransactionStore({
    provider
  }));
  React48.useEffect(() => {
    store.setProvider(provider);
  }, [store, provider]);
  React48.useEffect(() => {
    if (address && chainId) {
      store.waitForPendingTransactions(address, chainId);
    }
  }, [store, address, chainId]);
  return /* @__PURE__ */ React48__default.default.createElement(TransactionStoreContext.Provider, {
    value: store
  }, children);
}
function useTransactionStore() {
  const store = React48.useContext(TransactionStoreContext);
  if (!store) {
    throw new Error("Transaction hooks must be used within RainbowKitProvider");
  }
  return store;
}
function useRecentTransactions() {
  const store = useTransactionStore();
  const {
    address
  } = wagmi.useAccount();
  const chainId = useChainId();
  const [transactions, setTransactions] = React48.useState(() => store && address && chainId ? store.getTransactions(address, chainId) : []);
  React48.useEffect(() => {
    if (store && address && chainId) {
      setTransactions(store.getTransactions(address, chainId));
      return store.onChange(() => {
        setTransactions(store.getTransactions(address, chainId));
      });
    }
  }, [store, address, chainId]);
  return transactions;
}
var resolveThemeVars = (theme) => typeof theme === "function" ? theme() : theme;
function cssObjectFromTheme(theme, {
  extends: baseTheme2
} = {}) {
  const resolvedThemeVars = {
    ...assignInlineVars(themeVars, resolveThemeVars(theme))
  };
  if (!baseTheme2) {
    return resolvedThemeVars;
  }
  const resolvedBaseThemeVars = assignInlineVars(themeVars, resolveThemeVars(baseTheme2));
  const filteredVars = Object.fromEntries(Object.entries(resolvedThemeVars).filter(([varName, value]) => value !== resolvedBaseThemeVars[varName]));
  return filteredVars;
}
function cssStringFromTheme(theme, options = {}) {
  return Object.entries(cssObjectFromTheme(theme, options)).map(([key2, value]) => `${key2}:${value.replace(/[:;{}</>]/g, "")};`).join("");
}
var useWindowSize = () => {
  const [windowSize, setWindowSize] = React48.useState({
    height: void 0,
    width: void 0
  });
  React48.useEffect(() => {
    function handleResize() {
      setWindowSize({
        height: window.innerHeight,
        width: window.innerWidth
      });
    }
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
};
var defaultAppInfo = {
  appName: void 0,
  disclaimer: void 0,
  learnMoreUrl: "https://learn.rainbow.me/what-is-a-cryptoweb3-wallet-actually"
};
var AppContext = React48.createContext(defaultAppInfo);
var CoolModeContext = React48.createContext(false);
var ModalSizeOptions = {
  COMPACT: "compact",
  WIDE: "wide"
};
var ModalSizeContext = React48.createContext(ModalSizeOptions.WIDE);
var ShowRecentTransactionsContext = React48.createContext(false);
function flatten$1(array2) {
  const flattenedItems = [];
  for (const items of array2) {
    flattenedItems.push(...items);
  }
  return flattenedItems;
}
function indexBy(items, getKey) {
  const indexedItems = {};
  items.forEach((item) => {
    const key2 = getKey(item);
    if (!key2) {
      return;
    }
    indexedItems[key2] = item;
  });
  return indexedItems;
}
var storageKey2 = "rk-recent";
function safeParseJsonArray(string2) {
  try {
    const value = string2 ? JSON.parse(string2) : [];
    return Array.isArray(value) ? value : [];
  } catch (err) {
    return [];
  }
}
function getRecentWalletIds() {
  return typeof localStorage !== "undefined" ? safeParseJsonArray(localStorage.getItem(storageKey2)) : [];
}
function dedupe(array2) {
  return [...new Set(array2)];
}
function addRecentWalletId(walletId) {
  const newValue = dedupe([walletId, ...getRecentWalletIds()]);
  localStorage.setItem(storageKey2, JSON.stringify(newValue));
}
function useWalletConnectors() {
  const rainbowKitChains = useRainbowKitChains();
  const intialChainId = useInitialChainId();
  const {
    connectAsync,
    connectors: defaultConnectors_untyped
  } = wagmi.useConnect();
  const defaultConnectors = defaultConnectors_untyped;
  async function connectWallet(walletId, connector) {
    var _a2, _b2, _c2;
    const walletChainId = await connector.getChainId();
    const result = await connectAsync({
      chainId: (_c2 = intialChainId != null ? intialChainId : (_a2 = rainbowKitChains.find(({
        id: id2
      }) => id2 === walletChainId)) == null ? void 0 : _a2.id) != null ? _c2 : (_b2 = rainbowKitChains[0]) == null ? void 0 : _b2.id,
      connector
    });
    if (result) {
      addRecentWalletId(walletId);
    }
    return result;
  }
  const walletInstances = flatten$1(defaultConnectors.map((connector) => {
    var _a2;
    return (_a2 = connector._wallets) != null ? _a2 : [];
  })).sort((a2, b2) => a2.index - b2.index);
  const walletInstanceById = indexBy(walletInstances, (walletInstance) => walletInstance.id);
  const MAX_RECENT_WALLETS = 3;
  const recentWallets = getRecentWalletIds().map((walletId) => walletInstanceById[walletId]).filter(isNotNullish).slice(0, MAX_RECENT_WALLETS);
  const groupedWallets = [...recentWallets, ...walletInstances.filter((walletInstance) => !recentWallets.includes(walletInstance))];
  const walletConnectors = [];
  groupedWallets.forEach((wallet) => {
    var _a2;
    if (!wallet) {
      return;
    }
    const recent = recentWallets.includes(wallet);
    walletConnectors.push({
      ...wallet,
      connect: () => connectWallet(wallet.id, wallet.connector),
      groupName: wallet.groupName,
      onConnecting: (fn2) => wallet.connector.on("message", ({
        type: type2
      }) => type2 === "connecting" ? fn2() : void 0),
      ready: ((_a2 = wallet.installed) != null ? _a2 : true) && wallet.connector.ready,
      recent,
      showWalletConnectModal: wallet.walletConnectModalConnector ? async () => {
        try {
          await connectWallet(wallet.id, wallet.walletConnectModalConnector);
        } catch (err) {
          const isUserRejection = err.name === "UserRejectedRequestError";
          if (!isUserRejection) {
            throw err;
          }
        }
      } : void 0
    });
  });
  return walletConnectors;
}
var src$1 = async () => (await Promise.resolve($$14)).default;
var preloadAssetsIcon = () => loadImages(src$1);
var AssetsIcon = () => /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
  background: "#d0d5de",
  borderRadius: "10",
  height: "48",
  src: src$1,
  width: "48"
});
var src2 = async () => (await Promise.resolve($$15)).default;
var preloadLoginIcon = () => loadImages(src2);
var LoginIcon = () => /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
  background: "#d0d5de",
  borderRadius: "10",
  height: "48",
  src: src2,
  width: "48"
});
var Text = React48__default.default.forwardRef(({
  as = "div",
  children,
  className,
  color,
  display,
  font = "body",
  id: id2,
  size: size2 = "16",
  style,
  tabIndex,
  textAlign = "inherit",
  weight = "regular"
}, ref) => {
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    as,
    className,
    color,
    display,
    fontFamily: font,
    fontSize: size2,
    fontWeight: weight,
    id: id2,
    ref,
    style,
    tabIndex,
    textAlign
  }, children);
});
Text.displayName = "Text";
var sizeVariants = {
  large: {
    fontSize: "16",
    paddingX: "24",
    paddingY: "10"
  },
  medium: {
    fontSize: "14",
    height: "28",
    paddingX: "12",
    paddingY: "4"
  },
  small: {
    fontSize: "14",
    paddingX: "10",
    paddingY: "5"
  }
};
function ActionButton({
  disabled = false,
  href,
  label,
  onClick,
  rel = "noreferrer noopener",
  size: size2 = "medium",
  target = "_blank",
  testId,
  type: type2 = "primary"
}) {
  const isPrimary = type2 === "primary";
  const isNotLarge = size2 !== "large";
  const mobile = isMobile$1();
  const background = !disabled ? isPrimary ? "accentColor" : isNotLarge ? "actionButtonSecondaryBackground" : null : "actionButtonSecondaryBackground";
  const {
    fontSize,
    height,
    paddingX,
    paddingY
  } = sizeVariants[size2];
  const hasBorder = !mobile || !isNotLarge;
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...href ? !disabled ? {
      as: "a",
      href,
      rel,
      target
    } : {} : {
      as: "button",
      type: "button"
    },
    onClick: !disabled ? onClick : void 0,
    ...hasBorder ? {
      borderColor: mobile && !isNotLarge && !isPrimary ? "actionButtonBorderMobile" : "actionButtonBorder",
      borderStyle: "solid",
      borderWidth: "1"
    } : {},
    borderRadius: "actionButton",
    className: !disabled && touchableStyles({
      active: "shrinkSm",
      hover: "grow"
    }),
    display: "block",
    paddingX,
    paddingY,
    style: {
      willChange: "transform"
    },
    testId,
    textAlign: "center",
    transition: "transform",
    ...background ? {
      background
    } : {},
    ...height ? {
      height
    } : {}
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: !disabled ? isPrimary ? "accentColorForeground" : "accentColor" : "modalTextSecondary",
    size: fontSize,
    weight: "bold"
  }, label));
}
var CloseIcon$2 = () => {
  return isMobile$1() ? /* @__PURE__ */ React48__default.default.createElement("svg", {
    "aria-hidden": true,
    fill: "none",
    height: "11.5",
    viewBox: "0 0 11.5 11.5",
    width: "11.5",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React48__default.default.createElement("path", {
    d: "M2.13388 0.366117C1.64573 -0.122039 0.854272 -0.122039 0.366117 0.366117C-0.122039 0.854272 -0.122039 1.64573 0.366117 2.13388L3.98223 5.75L0.366117 9.36612C-0.122039 9.85427 -0.122039 10.6457 0.366117 11.1339C0.854272 11.622 1.64573 11.622 2.13388 11.1339L5.75 7.51777L9.36612 11.1339C9.85427 11.622 10.6457 11.622 11.1339 11.1339C11.622 10.6457 11.622 9.85427 11.1339 9.36612L7.51777 5.75L11.1339 2.13388C11.622 1.64573 11.622 0.854272 11.1339 0.366117C10.6457 -0.122039 9.85427 -0.122039 9.36612 0.366117L5.75 3.98223L2.13388 0.366117Z",
    fill: "currentColor"
  })) : /* @__PURE__ */ React48__default.default.createElement("svg", {
    "aria-hidden": true,
    fill: "none",
    height: "10",
    viewBox: "0 0 10 10",
    width: "10",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React48__default.default.createElement("path", {
    d: "M1.70711 0.292893C1.31658 -0.0976311 0.683417 -0.0976311 0.292893 0.292893C-0.0976311 0.683417 -0.0976311 1.31658 0.292893 1.70711L3.58579 5L0.292893 8.29289C-0.0976311 8.68342 -0.0976311 9.31658 0.292893 9.70711C0.683417 10.0976 1.31658 10.0976 1.70711 9.70711L5 6.41421L8.29289 9.70711C8.68342 10.0976 9.31658 10.0976 9.70711 9.70711C10.0976 9.31658 10.0976 8.68342 9.70711 8.29289L6.41421 5L9.70711 1.70711C10.0976 1.31658 10.0976 0.683417 9.70711 0.292893C9.31658 -0.0976311 8.68342 -0.0976311 8.29289 0.292893L5 3.58579L1.70711 0.292893Z",
    fill: "currentColor"
  }));
};
var CloseButton = ({
  "aria-label": ariaLabel = "Close",
  onClose
}) => {
  const mobile = isMobile$1();
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    "aria-label": ariaLabel,
    as: "button",
    background: "closeButtonBackground",
    borderColor: "actionButtonBorder",
    borderRadius: "full",
    borderStyle: "solid",
    borderWidth: mobile ? "0" : "1",
    className: touchableStyles({
      active: "shrinkSm",
      hover: "growLg"
    }),
    color: "closeButton",
    display: "flex",
    height: mobile ? "30" : "28",
    justifyContent: "center",
    onClick: onClose,
    style: {
      willChange: "transform"
    },
    transition: "default",
    type: "button",
    width: mobile ? "30" : "28"
  }, /* @__PURE__ */ React48__default.default.createElement(CloseIcon$2, null));
};
var signInIcon = async () => (await Promise.resolve($$16)).default;
function SignIn({
  onClose
}) {
  const [{
    status,
    ...state2
  }, setState] = React48__default.default.useState({
    status: "idle"
  });
  const authAdapter = useAuthenticationAdapter();
  const getNonce2 = React48.useCallback(async () => {
    try {
      const nonce = await authAdapter.getNonce();
      setState((x2) => ({
        ...x2,
        nonce
      }));
    } catch (error) {
      setState((x2) => ({
        ...x2,
        errorMessage: "Error preparing message, please retry!",
        status: "idle"
      }));
    }
  }, [authAdapter]);
  const onceRef = React48.useRef(false);
  React48__default.default.useEffect(() => {
    if (onceRef.current)
      return;
    onceRef.current = true;
    getNonce2();
  }, [getNonce2]);
  const mobile = isMobile$1();
  const {
    address
  } = wagmi.useAccount();
  const {
    chain: activeChain
  } = wagmi.useNetwork();
  const {
    signMessageAsync
  } = wagmi.useSignMessage();
  const {
    disconnect
  } = wagmi.useDisconnect();
  const cancel = () => disconnect();
  const signIn = async () => {
    try {
      const chainId = activeChain == null ? void 0 : activeChain.id;
      const {
        nonce
      } = state2;
      if (!address || !chainId || !nonce) {
        return;
      }
      setState((x2) => ({
        ...x2,
        errorMessage: void 0,
        status: "signing"
      }));
      const message = authAdapter.createMessage({
        address,
        chainId,
        nonce
      });
      let signature2;
      try {
        signature2 = await signMessageAsync({
          message: authAdapter.getMessageBody({
            message
          })
        });
      } catch (error) {
        if (error instanceof wagmi.UserRejectedRequestError) {
          return setState((x2) => ({
            ...x2,
            status: "idle"
          }));
        }
        return setState((x2) => ({
          ...x2,
          errorMessage: "Error signing message, please retry!",
          status: "idle"
        }));
      }
      setState((x2) => ({
        ...x2,
        status: "verifying"
      }));
      try {
        const verified = await authAdapter.verify({
          message,
          signature: signature2
        });
        if (verified) {
          return;
        } else {
          throw new Error();
        }
      } catch (error) {
        return setState((x2) => ({
          ...x2,
          errorMessage: "Error verifying signature, please retry!",
          status: "idle"
        }));
      }
    } catch (error) {
      setState({
        errorMessage: "Oops, something went wrong!",
        status: "idle"
      });
    }
  };
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    position: "relative"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    paddingRight: "16",
    paddingTop: "16",
    position: "absolute",
    right: "0"
  }, /* @__PURE__ */ React48__default.default.createElement(CloseButton, {
    onClose
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "32" : "24",
    padding: "24",
    paddingX: "18",
    style: {
      paddingTop: mobile ? "60px" : "36px"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "6" : "4",
    style: {
      maxWidth: mobile ? 320 : 280
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "32" : "16"
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    height: 40,
    src: signInIcon,
    width: 40
  }), /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: mobile ? "20" : "18",
    textAlign: "center",
    weight: "heavy"
  }, "Verify your account")), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "16" : "12"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: mobile ? "16" : "14",
    textAlign: "center"
  }, "To finish connecting, you must sign a message in your wallet to verify that you are the owner of this account."), status === "idle" && state2.errorMessage ? /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "error",
    size: mobile ? "16" : "14",
    textAlign: "center",
    weight: "bold"
  }, state2.errorMessage) : null)), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: !mobile ? "center" : void 0,
    display: "flex",
    flexDirection: "column",
    gap: "8",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    disabled: !state2.nonce || status === "signing" || status === "verifying",
    label: !state2.nonce ? "Preparing message..." : status === "signing" ? "Waiting for signature..." : status === "verifying" ? "Verifying signature..." : "Send message",
    onClick: signIn,
    size: mobile ? "large" : "medium",
    testId: "auth-message-button"
  }), mobile ? /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: "Cancel",
    onClick: cancel,
    size: "large",
    type: "secondary"
  }) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "button",
    borderRadius: "full",
    className: touchableStyles({
      active: "shrink",
      hover: "grow"
    }),
    display: "block",
    onClick: cancel,
    paddingX: "10",
    paddingY: "5",
    rel: "noreferrer",
    style: {
      willChange: "transform"
    },
    target: "_blank",
    transition: "default"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "closeButton",
    size: mobile ? "16" : "14",
    weight: "bold"
  }, "Cancel")))));
}
function usePreloadImages() {
  const rainbowKitChains = useRainbowKitChains();
  const walletConnectors = useWalletConnectors();
  const isUnauthenticated = useAuthenticationStatus() === "unauthenticated";
  const preloadImages = React48.useCallback(() => {
    loadImages(...walletConnectors.map((wallet) => wallet.iconUrl), ...rainbowKitChains.map((chain) => chain.iconUrl).filter(isNotNullish));
    if (!isMobile$1()) {
      preloadAssetsIcon();
      preloadLoginIcon();
    }
    if (isUnauthenticated) {
      loadImages(signInIcon);
    }
  }, [walletConnectors, rainbowKitChains, isUnauthenticated]);
  React48.useEffect(() => {
    preloadImages();
  }, [preloadImages]);
}
var storageKey3 = "WALLETCONNECT_DEEPLINK_CHOICE";
function setWalletConnectDeepLink({
  mobileUri,
  name: name2
}) {
  localStorage.setItem(storageKey3, JSON.stringify({
    href: mobileUri.split("?")[0],
    name: name2
  }));
}
function clearWalletConnectDeepLink() {
  localStorage.removeItem(storageKey3);
}
var ThemeIdContext = React48.createContext(void 0);
var attr = "data-rk";
var createThemeRootProps = (id2) => ({
  [attr]: id2 || ""
});
var createThemeRootSelector = (id2) => {
  if (id2 && !/^[a-zA-Z0-9_]+$/.test(id2)) {
    throw new Error(`Invalid ID: ${id2}`);
  }
  return id2 ? `[${attr}="${id2}"]` : `[${attr}]`;
};
var useThemeRootProps = () => {
  const id2 = React48.useContext(ThemeIdContext);
  return createThemeRootProps(id2);
};
var defaultTheme = lightTheme();
function RainbowKitProvider({
  chains,
  initialChain,
  id: id2,
  theme = defaultTheme,
  children,
  appInfo,
  showRecentTransactions = false,
  coolMode = false,
  avatar,
  modalSize = ModalSizeOptions.WIDE
}) {
  usePreloadImages();
  wagmi.useAccount({
    onDisconnect: clearWalletConnectDeepLink
  });
  if (typeof theme === "function") {
    throw new Error('A theme function was provided to the "theme" prop instead of a theme object. You must execute this function to get the resulting theme object.');
  }
  const selector = createThemeRootSelector(id2);
  const appContext = {
    ...defaultAppInfo,
    ...appInfo
  };
  const avatarContext = avatar != null ? avatar : defaultAvatar;
  const {
    width
  } = useWindowSize();
  const isSmallScreen = width && width < largeScreenMinWidth;
  return /* @__PURE__ */ React48__default.default.createElement(RainbowKitChainProvider, {
    chains,
    initialChain
  }, /* @__PURE__ */ React48__default.default.createElement(CoolModeContext.Provider, {
    value: coolMode
  }, /* @__PURE__ */ React48__default.default.createElement(ModalSizeContext.Provider, {
    value: isSmallScreen ? ModalSizeOptions.COMPACT : modalSize
  }, /* @__PURE__ */ React48__default.default.createElement(ShowRecentTransactionsContext.Provider, {
    value: showRecentTransactions
  }, /* @__PURE__ */ React48__default.default.createElement(TransactionStoreProvider, null, /* @__PURE__ */ React48__default.default.createElement(AvatarContext.Provider, {
    value: avatarContext
  }, /* @__PURE__ */ React48__default.default.createElement(AppContext.Provider, {
    value: appContext
  }, /* @__PURE__ */ React48__default.default.createElement(ThemeIdContext.Provider, {
    value: id2
  }, /* @__PURE__ */ React48__default.default.createElement(ModalProvider, null, theme ? /* @__PURE__ */ React48__default.default.createElement("div", {
    ...createThemeRootProps(id2)
  }, /* @__PURE__ */ React48__default.default.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: [`${selector}{${cssStringFromTheme("lightMode" in theme ? theme.lightMode : theme)}}`, "darkMode" in theme ? `@media(prefers-color-scheme:dark){${selector}{${cssStringFromTheme(theme.darkMode, {
        extends: theme.lightMode
      })}}}` : null].join("")
    }
  }), children) : children)))))))));
}
var content = "_9pm4ki5 ju367va ju367v10 ju367v8m";
var overlay = "_9pm4ki3 ju367v9b ju367vax ju367va ju367v2l ju367v8l";
var moveFocusWithin = (element2, position) => {
  const focusableElements = element2.querySelectorAll("button:not(:disabled), a[href]");
  if (focusableElements.length === 0)
    return;
  focusableElements[position === "end" ? focusableElements.length - 1 : 0].focus();
};
function FocusTrap(props) {
  const contentRef = React48.useRef(null);
  React48.useEffect(() => {
    const previouslyActiveElement = document.activeElement;
    return () => {
      var _a2;
      (_a2 = previouslyActiveElement.focus) == null ? void 0 : _a2.call(previouslyActiveElement);
    };
  }, []);
  React48.useEffect(() => {
    if (contentRef.current) {
      const elementToFocus = contentRef.current.querySelector("[data-auto-focus]");
      if (elementToFocus) {
        elementToFocus.focus();
      } else {
        contentRef.current.focus();
      }
    }
  }, [contentRef]);
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement("div", {
    onFocus: React48.useCallback(() => contentRef.current && moveFocusWithin(contentRef.current, "end"), []),
    tabIndex: 0
  }), /* @__PURE__ */ React48__default.default.createElement("div", {
    ref: contentRef,
    style: {
      outline: "none"
    },
    tabIndex: -1,
    ...props
  }), /* @__PURE__ */ React48__default.default.createElement("div", {
    onFocus: React48.useCallback(() => contentRef.current && moveFocusWithin(contentRef.current, "start"), []),
    tabIndex: 0
  }));
}
var stopPropagation = (event) => event.stopPropagation();
function Dialog({
  children,
  onClose,
  open: open2,
  titleId
}) {
  React48.useEffect(() => {
    const handleEscape = (event) => open2 && event.key === "Escape" && onClose();
    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [open2, onClose]);
  const [bodyScrollable, setBodyScrollable] = React48.useState(true);
  React48.useEffect(() => {
    setBodyScrollable(getComputedStyle(window.document.body).overflow !== "hidden");
  }, []);
  const handleBackdropClick = React48.useCallback(() => onClose(), [onClose]);
  const themeRootProps = useThemeRootProps();
  const mobile = isMobile$1();
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, open2 ? reactDom.createPortal(/* @__PURE__ */ React48__default.default.createElement(RemoveScroll, {
    enabled: bodyScrollable
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...themeRootProps
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...themeRootProps,
    alignItems: mobile ? "flex-end" : "center",
    "aria-labelledby": titleId,
    "aria-modal": true,
    className: overlay,
    onClick: handleBackdropClick,
    position: "fixed",
    role: "dialog"
  }, /* @__PURE__ */ React48__default.default.createElement(FocusTrap, {
    className: content,
    onClick: stopPropagation,
    role: "document"
  }, children)))), document.body) : null);
}
var bottomSheetOverrides = "_1ckjpok7";
var dialogContent = "_1ckjpok1 ju367vb0 ju367vdl ju367vp ju367vt ju367vv ju367vef ju367va ju367v10 ju367v67 ju367v8m";
var dialogContentCompactMode = "_1ckjpok4 _1ckjpok1 ju367vb0 ju367vdl ju367vp ju367vt ju367vv ju367vef ju367va ju367v10 ju367v67 ju367v8m";
var dialogContentMobile = "_1ckjpok6 ju367vq";
var dialogContentWideDesktop = "_1ckjpok3 _1ckjpok1 ju367vb0 ju367vdl ju367vp ju367vt ju367vv ju367vef ju367va ju367v10 ju367v67 ju367v8m";
var dialogContentWideMobile = "_1ckjpok2 _1ckjpok1 ju367vb0 ju367vdl ju367vp ju367vt ju367vv ju367vef ju367va ju367v10 ju367v67 ju367v8m";
function DialogContent({
  bottomSheetOnMobile = false,
  children,
  marginTop,
  padding: padding2 = "16",
  wide = false
}) {
  const mobile = isMobile$1();
  const modalSize = React48.useContext(ModalSizeContext);
  const compactModeEnabled = modalSize === ModalSizeOptions.COMPACT;
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginTop
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    className: [wide ? mobile ? dialogContentWideMobile : compactModeEnabled ? dialogContentCompactMode : dialogContentWideDesktop : dialogContent, mobile ? dialogContentMobile : null, mobile && bottomSheetOnMobile ? bottomSheetOverrides : null].join(" ")
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    padding: padding2
  }, children)));
}
var units = ["k", "m", "b", "t"];
function toPrecision(number2, precision = 1) {
  return number2.toString().replace(new RegExp(`(.+\\.\\d{${precision}})\\d+`), "$1").replace(/(\.[1-9]*)0+$/, "$1").replace(/\.$/, "");
}
function abbreviateETHBalance(number2) {
  if (number2 < 1)
    return toPrecision(number2, 3);
  if (number2 < 10 ** 2)
    return toPrecision(number2, 2);
  if (number2 < 10 ** 4)
    return new Intl.NumberFormat().format(parseFloat(toPrecision(number2, 1)));
  const decimalsDivisor = 10 ** 1;
  let result = String(number2);
  for (let i = units.length - 1; i >= 0; i--) {
    const size2 = 10 ** ((i + 1) * 3);
    if (size2 <= number2) {
      number2 = number2 * decimalsDivisor / size2 / decimalsDivisor;
      result = toPrecision(number2, 1) + units[i];
      break;
    }
  }
  return result;
}
function formatAddress(address) {
  const leadingChars = 4;
  const trailingChars = 4;
  return address.length < leadingChars + trailingChars ? address : `${address.substring(0, leadingChars)}\u2026${address.substring(address.length - trailingChars)}`;
}
function formatENS(name2) {
  const parts = name2.split(".");
  const last2 = parts.pop();
  if (parts.join(".").length > 24) {
    return `${parts.join(".").substring(0, 24)}...`;
  }
  return `${parts.join(".")}.${last2}`;
}
var CopiedIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "13",
  viewBox: "0 0 13 13",
  width: "13",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M4.94568 12.2646C5.41052 12.2646 5.77283 12.0869 6.01892 11.7109L12.39 1.96973C12.5677 1.69629 12.6429 1.44336 12.6429 1.2041C12.6429 0.561523 12.1644 0.0966797 11.5082 0.0966797C11.057 0.0966797 10.7767 0.260742 10.5033 0.691406L4.9115 9.50977L2.07458 5.98926C1.82166 5.68848 1.54822 5.55176 1.16541 5.55176C0.502319 5.55176 0.0238037 6.02344 0.0238037 6.66602C0.0238037 6.95312 0.112671 7.20605 0.358765 7.48633L3.88611 11.7588C4.18005 12.1074 4.50818 12.2646 4.94568 12.2646Z",
  fill: "currentColor"
}));
var CopyIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "16",
  viewBox: "0 0 17 16",
  width: "17",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M3.04236 12.3027H4.18396V13.3008C4.18396 14.8525 5.03845 15.7002 6.59705 15.7002H13.6244C15.183 15.7002 16.0375 14.8525 16.0375 13.3008V6.24609C16.0375 4.69434 15.183 3.84668 13.6244 3.84668H12.4828V2.8418C12.4828 1.29688 11.6283 0.442383 10.0697 0.442383H3.04236C1.48376 0.442383 0.629272 1.29004 0.629272 2.8418V9.90332C0.629272 11.4551 1.48376 12.3027 3.04236 12.3027ZM3.23376 10.5391C2.68689 10.5391 2.39294 10.2656 2.39294 9.68457V3.06055C2.39294 2.47949 2.68689 2.21289 3.23376 2.21289H9.8783C10.4252 2.21289 10.7191 2.47949 10.7191 3.06055V3.84668H6.59705C5.03845 3.84668 4.18396 4.69434 4.18396 6.24609V10.5391H3.23376ZM6.78845 13.9365C6.24158 13.9365 5.94763 13.6699 5.94763 13.0889V6.45801C5.94763 5.87695 6.24158 5.61035 6.78845 5.61035H13.433C13.9799 5.61035 14.2738 5.87695 14.2738 6.45801V13.0889C14.2738 13.6699 13.9799 13.9365 13.433 13.9365H6.78845Z",
  fill: "currentColor"
}));
var DisconnectIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "16",
  viewBox: "0 0 18 16",
  width: "18",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M2.67834 15.5908H9.99963C11.5514 15.5908 12.399 14.7432 12.399 13.1777V10.2656H10.6354V12.9863C10.6354 13.5332 10.3688 13.8271 9.78772 13.8271H2.89026C2.3092 13.8271 2.0426 13.5332 2.0426 12.9863V3.15625C2.0426 2.60254 2.3092 2.30859 2.89026 2.30859H9.78772C10.3688 2.30859 10.6354 2.60254 10.6354 3.15625V5.89746H12.399V2.95801C12.399 1.39941 11.5514 0.544922 9.99963 0.544922H2.67834C1.12659 0.544922 0.278931 1.39941 0.278931 2.95801V13.1777C0.278931 14.7432 1.12659 15.5908 2.67834 15.5908ZM7.43616 8.85059H14.0875L15.0924 8.78906L14.566 9.14453L13.6842 9.96484C13.5406 10.1016 13.4586 10.2861 13.4586 10.4844C13.4586 10.8398 13.7321 11.168 14.1217 11.168C14.3199 11.168 14.4635 11.0928 14.6002 10.9561L16.7809 8.68652C16.986 8.48145 17.0543 8.27637 17.0543 8.06445C17.0543 7.85254 16.986 7.64746 16.7809 7.43555L14.6002 5.17285C14.4635 5.03613 14.3199 4.9541 14.1217 4.9541C13.7321 4.9541 13.4586 5.27539 13.4586 5.6377C13.4586 5.83594 13.5406 6.02734 13.6842 6.15723L14.566 6.98438L15.0924 7.33984L14.0875 7.27148H7.43616C7.01917 7.27148 6.65686 7.62012 6.65686 8.06445C6.65686 8.50195 7.01917 8.85059 7.43616 8.85059Z",
  fill: "currentColor"
}));
function useClearRecentTransactions() {
  const store = useTransactionStore();
  const {
    address
  } = wagmi.useAccount();
  const chainId = useChainId();
  return React48.useCallback(() => {
    if (!address || !chainId) {
      throw new Error("No address or chain ID found");
    }
    store.clearTransactions(address, chainId);
  }, [store, address, chainId]);
}
var chainToExplorerUrl = (chain) => {
  var _a2, _b2;
  return (_b2 = (_a2 = chain == null ? void 0 : chain.blockExplorers) == null ? void 0 : _a2.default) == null ? void 0 : _b2.url;
};
var ExternalLinkIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "19",
  viewBox: "0 0 20 19",
  width: "20",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM12.7158 12.1416C13.2432 12.1416 13.5684 11.7549 13.5684 11.1836V7.19336C13.5684 6.44629 13.1377 6.05957 12.417 6.05957H8.40918C7.8291 6.05957 7.45117 6.38477 7.45117 6.91211C7.45117 7.43945 7.8291 7.77344 8.40918 7.77344H9.69238L10.7207 7.63281L9.53418 8.67871L6.73047 11.4912C6.53711 11.6758 6.41406 11.9395 6.41406 12.2031C6.41406 12.7832 6.85352 13.1699 7.39844 13.1699C7.68848 13.1699 7.92578 13.0732 8.1543 12.8623L10.9316 10.0762L11.9775 8.89844L11.8545 9.98828V11.1836C11.8545 11.7725 12.1885 12.1416 12.7158 12.1416Z",
  fill: "currentColor"
}));
var CancelIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "19",
  viewBox: "0 0 20 19",
  width: "20",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M10 18.9443C15.0977 18.9443 19.2812 14.752 19.2812 9.6543C19.2812 4.56543 15.0889 0.373047 10 0.373047C4.90234 0.373047 0.71875 4.56543 0.71875 9.6543C0.71875 14.752 4.91113 18.9443 10 18.9443ZM10 16.6328C6.1416 16.6328 3.03906 13.5215 3.03906 9.6543C3.03906 5.7959 6.13281 2.68457 10 2.68457C13.8584 2.68457 16.9697 5.7959 16.9697 9.6543C16.9785 13.5215 13.8672 16.6328 10 16.6328ZM7.29297 13.3018C7.58301 13.3018 7.81152 13.2139 7.99609 13.0205L10 11.0166L12.0127 13.0205C12.1973 13.2051 12.4258 13.3018 12.707 13.3018C13.2432 13.3018 13.6562 12.8887 13.6562 12.3525C13.6562 12.0977 13.5508 11.8691 13.3662 11.6934L11.3535 9.67188L13.375 7.6416C13.5596 7.44824 13.6562 7.22852 13.6562 6.98242C13.6562 6.44629 13.2432 6.0332 12.7158 6.0332C12.4346 6.0332 12.2148 6.12109 12.0215 6.31445L10 8.32715L7.9873 6.32324C7.80273 6.12988 7.58301 6.04199 7.29297 6.04199C6.76562 6.04199 6.35254 6.45508 6.35254 6.99121C6.35254 7.2373 6.44922 7.46582 6.63379 7.6416L8.65527 9.67188L6.63379 11.6934C6.44922 11.8691 6.35254 12.1064 6.35254 12.3525C6.35254 12.8887 6.76562 13.3018 7.29297 13.3018Z",
  fill: "currentColor"
}));
var SuccessIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "20",
  viewBox: "0 0 20 20",
  width: "20",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M10 19.4443C15.0977 19.4443 19.2812 15.252 19.2812 10.1543C19.2812 5.06543 15.0889 0.873047 10 0.873047C4.90234 0.873047 0.71875 5.06543 0.71875 10.1543C0.71875 15.252 4.91113 19.4443 10 19.4443ZM10 17.1328C6.1416 17.1328 3.03906 14.0215 3.03906 10.1543C3.03906 6.2959 6.13281 3.18457 10 3.18457C13.8584 3.18457 16.9697 6.2959 16.9697 10.1543C16.9785 14.0215 13.8672 17.1328 10 17.1328ZM9.07715 14.3379C9.4375 14.3379 9.7627 14.1533 9.97363 13.8369L13.7441 8.00977C13.8848 7.79883 13.9814 7.5791 13.9814 7.36816C13.9814 6.84961 13.5244 6.48926 13.0322 6.48926C12.707 6.48926 12.4258 6.66504 12.2148 7.0166L9.05957 12.0967L7.5918 10.2949C7.37207 10.0225 7.13477 9.9082 6.84473 9.9082C6.33496 9.9082 5.92188 10.3125 5.92188 10.8223C5.92188 11.0684 6.00098 11.2793 6.18555 11.5078L8.1543 13.8545C8.40918 14.1709 8.70801 14.3379 9.07715 14.3379Z",
  fill: "currentColor"
}));
var getTxStatusIcon = (status) => {
  switch (status) {
    case "pending":
      return SpinnerIcon;
    case "confirmed":
      return SuccessIcon;
    case "failed":
      return CancelIcon;
    default:
      return SpinnerIcon;
  }
};
function TxItem({
  tx
}) {
  const mobile = isMobile$1();
  const Icon = getTxStatusIcon(tx.status);
  const color = tx.status === "failed" ? "error" : "accentColor";
  const {
    chain: activeChain
  } = wagmi.useNetwork();
  const confirmationStatus = tx.status === "confirmed" ? "Confirmed" : tx.status === "failed" ? "Failed" : "Pending";
  const explorerLink = chainToExplorerUrl(activeChain);
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...explorerLink ? {
      as: "a",
      background: {
        hover: "profileForeground"
      },
      borderRadius: "menuButton",
      className: touchableStyles({
        active: "shrink"
      }),
      href: `${explorerLink}/tx/${tx.hash}`,
      rel: "noreferrer noopener",
      target: "_blank",
      transition: "default"
    } : {},
    color: "modalText",
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    padding: "8",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    gap: mobile ? "16" : "14"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    color
  }, /* @__PURE__ */ React48__default.default.createElement(Icon, null)), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "3" : "1"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    font: "body",
    size: mobile ? "16" : "14",
    weight: "bold"
  }, tx == null ? void 0 : tx.description)), /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: tx.status === "pending" ? "modalTextSecondary" : color,
    font: "body",
    size: "14",
    weight: mobile ? "medium" : "regular"
  }, confirmationStatus)))), explorerLink && /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    color: "modalTextDim",
    display: "flex"
  }, /* @__PURE__ */ React48__default.default.createElement(ExternalLinkIcon, null))));
}
var NUMBER_OF_VISIBLE_TXS = 3;
function TxList({
  address
}) {
  const recentTransactions = useRecentTransactions();
  const clearRecentTransactions = useClearRecentTransactions();
  const {
    chain: activeChain
  } = wagmi.useNetwork();
  const explorerLink = chainToExplorerUrl(activeChain);
  const visibleTxs = recentTransactions.slice(0, NUMBER_OF_VISIBLE_TXS);
  const hasTransactions = visibleTxs.length > 0;
  const mobile = isMobile$1();
  const {
    appName
  } = React48.useContext(AppContext);
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "10",
    paddingBottom: "2",
    paddingTop: "16",
    paddingX: mobile ? "8" : "18"
  }, hasTransactions && /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingBottom: mobile ? "4" : "0",
    paddingTop: "8",
    paddingX: mobile ? "12" : "6"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    justifyContent: "space-between"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: mobile ? "16" : "14",
    weight: "semibold"
  }, "Recent Transactions"), /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      marginBottom: -6,
      marginLeft: -10,
      marginRight: -10,
      marginTop: -6
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "button",
    background: {
      hover: "profileForeground"
    },
    borderRadius: "actionButton",
    className: touchableStyles({
      active: "shrink"
    }),
    onClick: clearRecentTransactions,
    paddingX: mobile ? "8" : "12",
    paddingY: mobile ? "4" : "5",
    transition: "default",
    type: "button"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: mobile ? "16" : "14",
    weight: "semibold"
  }, "Clear All"))))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "4"
  }, hasTransactions ? visibleTxs.map((tx) => /* @__PURE__ */ React48__default.default.createElement(TxItem, {
    key: tx.hash,
    tx
  })) : /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    padding: mobile ? "12" : "8"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextDim",
    size: mobile ? "16" : "14",
    weight: mobile ? "medium" : "bold"
  }, appName != null ? appName : "Your", " transactions will appear here...")), mobile && /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "generalBorderDim",
    height: "1",
    marginX: "12",
    marginY: "8"
  })))), explorerLink && /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingBottom: "18",
    paddingX: mobile ? "8" : "18"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    as: "a",
    background: {
      hover: "profileForeground"
    },
    borderRadius: "menuButton",
    className: touchableStyles({
      active: "shrink"
    }),
    color: "modalTextDim",
    display: "flex",
    flexDirection: "row",
    href: `${explorerLink}/address/${address}`,
    justifyContent: "space-between",
    paddingX: "8",
    paddingY: "12",
    rel: "noreferrer noopener",
    style: {
      willChange: "transform"
    },
    target: "_blank",
    transition: "default",
    width: "full",
    ...mobile ? {
      paddingLeft: "12"
    } : {}
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    font: "body",
    size: mobile ? "16" : "14",
    weight: mobile ? "semibold" : "bold"
  }, "View more on Explorer"), /* @__PURE__ */ React48__default.default.createElement(ExternalLinkIcon, null))));
}
function ProfileDetailsAction({
  action,
  icon,
  label,
  testId,
  url
}) {
  const mobile = isMobile$1();
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    ...url ? {
      as: "a",
      href: url,
      rel: "noreferrer noopener",
      target: "_blank"
    } : {
      as: "button",
      type: "button"
    },
    background: {
      base: "profileAction",
      ...!mobile ? {
        hover: "profileActionHover"
      } : {}
    },
    borderRadius: "menuButton",
    boxShadow: "profileDetailsAction",
    className: touchableStyles({
      active: "shrinkSm",
      hover: !mobile ? "grow" : void 0
    }),
    display: "flex",
    onClick: action,
    padding: mobile ? "6" : "8",
    style: {
      willChange: "transform"
    },
    testId,
    transition: "default",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "1",
    justifyContent: "center",
    paddingTop: "2",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    color: "modalText",
    height: "max"
  }, icon), /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: mobile ? "12" : "13",
    weight: "semibold"
  }, label))));
}
function ProfileDetails({
  address,
  balanceData,
  ensAvatar,
  ensName,
  onClose,
  onDisconnect
}) {
  const showRecentTransactions = React48.useContext(ShowRecentTransactionsContext);
  const [copiedAddress, setCopiedAddress] = React48.useState(false);
  const copyAddressAction = React48.useCallback(() => {
    if (address) {
      navigator.clipboard.writeText(address);
      setCopiedAddress(true);
    }
  }, [address]);
  React48.useEffect(() => {
    if (copiedAddress) {
      const timer2 = setTimeout(() => {
        setCopiedAddress(false);
      }, 1500);
      return () => clearTimeout(timer2);
    }
  }, [copiedAddress]);
  if (!address) {
    return null;
  }
  const accountName = ensName ? formatENS(ensName) : formatAddress(address);
  const ethBalance = balanceData == null ? void 0 : balanceData.formatted;
  const displayBalance = ethBalance ? abbreviateETHBalance(parseFloat(ethBalance)) : void 0;
  const titleId = "rk_profile_title";
  const mobile = isMobile$1();
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "profileForeground",
    padding: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "16" : "12",
    justifyContent: "center",
    margin: "8",
    style: {
      textAlign: "center"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      position: "absolute",
      right: 16,
      top: 16,
      willChange: "transform"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(CloseButton, {
    onClose
  })), " ", /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginTop: mobile ? "24" : "0"
  }, /* @__PURE__ */ React48__default.default.createElement(Avatar, {
    address,
    imageUrl: ensAvatar,
    size: mobile ? 82 : 74
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: mobile ? "4" : "0",
    textAlign: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    textAlign: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    as: "h1",
    color: "modalText",
    id: titleId,
    size: mobile ? "20" : "18",
    weight: "heavy"
  }, accountName)), balanceData && /* @__PURE__ */ React48__default.default.createElement(Box, {
    textAlign: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    as: "h1",
    color: "modalTextSecondary",
    id: titleId,
    size: mobile ? "16" : "14",
    weight: "semibold"
  }, displayBalance, " ", balanceData.symbol)))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "row",
    gap: "8",
    margin: "2",
    marginTop: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(ProfileDetailsAction, {
    action: copyAddressAction,
    icon: copiedAddress ? /* @__PURE__ */ React48__default.default.createElement(CopiedIcon, null) : /* @__PURE__ */ React48__default.default.createElement(CopyIcon, null),
    label: copiedAddress ? "Copied!" : "Copy Address"
  }), /* @__PURE__ */ React48__default.default.createElement(ProfileDetailsAction, {
    action: onDisconnect,
    icon: /* @__PURE__ */ React48__default.default.createElement(DisconnectIcon, null),
    label: "Disconnect",
    testId: "disconnect-button"
  }))), showRecentTransactions && /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "generalBorder",
    height: "1",
    marginTop: "-1"
  }), /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(TxList, {
    address
  })))));
}
function AccountModal({
  onClose,
  open: open2
}) {
  const {
    address
  } = wagmi.useAccount();
  const {
    data: balanceData
  } = wagmi.useBalance({
    address
  });
  const ensAvatar = useMainnetEnsAvatar(address);
  const ensName = useMainnetEnsName(address);
  const {
    disconnect
  } = wagmi.useDisconnect();
  if (!address) {
    return null;
  }
  const titleId = "rk_account_modal_title";
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, address && /* @__PURE__ */ React48__default.default.createElement(Dialog, {
    onClose,
    open: open2,
    titleId
  }, /* @__PURE__ */ React48__default.default.createElement(DialogContent, {
    bottomSheetOnMobile: true,
    padding: "0"
  }, /* @__PURE__ */ React48__default.default.createElement(ProfileDetails, {
    address,
    balanceData,
    ensAvatar,
    ensName,
    onClose,
    onDisconnect: disconnect
  }))));
}
var DisconnectSqIcon = ({
  size: size2
}) => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: size2,
  viewBox: "0 0 28 28",
  width: size2,
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M6.742 22.195h8.367c1.774 0 2.743-.968 2.743-2.758V16.11h-2.016v3.11c0 .625-.305.96-.969.96H6.984c-.664 0-.968-.335-.968-.96V7.984c0-.632.304-.968.968-.968h7.883c.664 0 .969.336.969.968v3.133h2.016v-3.36c0-1.78-.97-2.757-2.743-2.757H6.742C4.97 5 4 5.977 4 7.758v11.68c0 1.789.969 2.757 2.742 2.757Zm5.438-7.703h7.601l1.149-.07-.602.406-1.008.938a.816.816 0 0 0-.258.593c0 .407.313.782.758.782.227 0 .39-.086.547-.243l2.492-2.593c.235-.235.313-.47.313-.711 0-.242-.078-.477-.313-.719l-2.492-2.586c-.156-.156-.32-.25-.547-.25-.445 0-.758.367-.758.781 0 .227.094.446.258.594l1.008.945.602.407-1.149-.079H12.18a.904.904 0 0 0 0 1.805Z",
  fill: "currentColor"
}));
var unsetBackgroundOnHover = "v9horb0";
var MenuButton = React48__default.default.forwardRef(({
  children,
  currentlySelected = false,
  onClick,
  testId,
  ...urlProps
}, ref) => {
  const mobile = isMobile$1();
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "button",
    borderRadius: "menuButton",
    disabled: currentlySelected,
    display: "flex",
    onClick,
    ref,
    testId,
    type: "button"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    borderRadius: "menuButton",
    className: [mobile ? unsetBackgroundOnHover : void 0, !currentlySelected && touchableStyles({
      active: "shrink"
    })],
    padding: mobile ? "8" : "6",
    transition: "default",
    width: "full",
    ...currentlySelected ? {
      background: "accentColor",
      borderColor: "selectedOptionBorder",
      borderStyle: "solid",
      borderWidth: "1",
      boxShadow: "selectedOption",
      color: "accentColorForeground"
    } : {
      background: {
        hover: "menuItemBackground"
      },
      color: "modalText",
      transition: "default"
    },
    ...urlProps
  }, children));
});
MenuButton.displayName = "MenuButton";
function ChainModal({
  onClose,
  open: open2
}) {
  var _a2;
  const {
    chain: activeChain
  } = wagmi.useNetwork();
  const {
    chains,
    error: networkError,
    switchNetwork
  } = wagmi.useSwitchNetwork();
  const {
    disconnect
  } = wagmi.useDisconnect();
  const {
    connector: activeConnector
  } = wagmi.useAccount();
  const [switchingToChain, setSwitchingToChain] = React48.useState();
  const titleId = "rk_chain_modal_title";
  const mobile = isMobile$1();
  const rainbowkitChainsById = useRainbowKitChainsById();
  const unsupportedChain = (_a2 = activeChain == null ? void 0 : activeChain.unsupported) != null ? _a2 : false;
  const chainIconSize = mobile ? "36" : "28";
  const stopSwitching = React48.useCallback(() => {
    setSwitchingToChain(null);
    onClose();
  }, [onClose]);
  React48.useEffect(() => {
    var _a22;
    if (!activeConnector) {
      return;
    }
    const stopSwitching2 = () => {
      setSwitchingToChain(null);
      onClose();
    };
    let provider;
    (_a22 = activeConnector == null ? void 0 : activeConnector.getProvider) == null ? void 0 : _a22.call(activeConnector).then((provider_) => {
      provider = provider_;
      provider.on("chainChanged", stopSwitching2);
    });
    return () => {
      provider == null ? void 0 : provider.removeListener("chainChanged", stopSwitching2);
    };
  }, [activeConnector, onClose, stopSwitching]);
  React48.useEffect(() => {
    if (networkError && networkError.name === "UserRejectedRequestError") {
      stopSwitching();
    }
  }, [networkError, stopSwitching]);
  const {
    appName
  } = React48.useContext(AppContext);
  if (!activeChain || !(activeChain == null ? void 0 : activeChain.id)) {
    return null;
  }
  return /* @__PURE__ */ React48__default.default.createElement(Dialog, {
    onClose,
    open: open2,
    titleId
  }, /* @__PURE__ */ React48__default.default.createElement(DialogContent, {
    bottomSheetOnMobile: true
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "14"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between"
  }, mobile && /* @__PURE__ */ React48__default.default.createElement(Box, {
    width: "30"
  }), /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingBottom: "0",
    paddingLeft: "8",
    paddingTop: "4"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    as: "h1",
    color: "modalText",
    id: titleId,
    size: mobile ? "20" : "18",
    weight: "heavy"
  }, "Switch Networks")), /* @__PURE__ */ React48__default.default.createElement(CloseButton, {
    onClose
  })), unsupportedChain && /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginX: "8",
    textAlign: mobile ? "center" : "left"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, "Wrong network detected, switch or disconnect to continue.")), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "4",
    padding: "2"
  }, switchNetwork ? chains.map((chain, idx) => {
    const isCurrentChain = chain.id === (activeChain == null ? void 0 : activeChain.id);
    const switching = chain.id === switchingToChain;
    const rainbowKitChain = rainbowkitChainsById[chain.id];
    const chainIconSize2 = mobile ? "36" : "28";
    const chainIconUrl = rainbowKitChain == null ? void 0 : rainbowKitChain.iconUrl;
    const chainIconBackground = rainbowKitChain == null ? void 0 : rainbowKitChain.iconBackground;
    return /* @__PURE__ */ React48__default.default.createElement(React48.Fragment, {
      key: chain.id
    }, /* @__PURE__ */ React48__default.default.createElement(MenuButton, {
      currentlySelected: isCurrentChain,
      onClick: isCurrentChain ? void 0 : () => {
        setSwitchingToChain(chain.id);
        switchNetwork(chain.id);
      },
      testId: `chain-option-${chain.id}`
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      fontFamily: "body",
      fontSize: "16",
      fontWeight: "bold"
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between"
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      gap: "4",
      height: chainIconSize2
    }, chainIconUrl ? /* @__PURE__ */ React48__default.default.createElement(Box, {
      height: "full",
      marginRight: "8"
    }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
      alt: chain.name,
      background: chainIconBackground,
      borderRadius: "full",
      height: chainIconSize2,
      src: chainIconUrl,
      width: chainIconSize2
    })) : null, /* @__PURE__ */ React48__default.default.createElement("div", null, chain.name)), isCurrentChain && /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      marginRight: "6"
    }, /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "accentColorForeground",
      size: "14",
      weight: "medium"
    }, "Connected"), /* @__PURE__ */ React48__default.default.createElement(Box, {
      background: "connectionIndicator",
      borderColor: "selectedOptionBorder",
      borderRadius: "full",
      borderStyle: "solid",
      borderWidth: "1",
      height: "8",
      marginLeft: "8",
      width: "8"
    })), switching && /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      marginRight: "6"
    }, /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalText",
      size: "14",
      weight: "medium"
    }, "Confirm in Wallet"), /* @__PURE__ */ React48__default.default.createElement(Box, {
      background: "standby",
      borderRadius: "full",
      height: "8",
      marginLeft: "8",
      width: "8"
    }))))), mobile && idx < (chains == null ? void 0 : chains.length) - 1 && /* @__PURE__ */ React48__default.default.createElement(Box, {
      background: "generalBorderDim",
      height: "1",
      marginX: "8"
    }));
  }) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "generalBorder",
    borderRadius: "menuButton",
    paddingX: "18",
    paddingY: "12"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "14",
    weight: "medium"
  }, "Your wallet does not support switching networks from", " ", appName != null ? appName : "this app", ". Try switching networks from within your wallet instead.")), unsupportedChain && /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "generalBorderDim",
    height: "1",
    marginX: "8"
  }), /* @__PURE__ */ React48__default.default.createElement(MenuButton, {
    onClick: () => disconnect(),
    testId: "chain-option-disconnect"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    color: "error",
    fontFamily: "body",
    fontSize: "16",
    fontWeight: "bold"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    gap: "4",
    height: chainIconSize
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    color: "error",
    height: chainIconSize,
    justifyContent: "center",
    marginRight: "8"
  }, /* @__PURE__ */ React48__default.default.createElement(DisconnectSqIcon, {
    size: Number(chainIconSize)
  })), /* @__PURE__ */ React48__default.default.createElement("div", null, "Disconnect"))))))))));
}
function isSafari() {
  return typeof navigator !== "undefined" && /Version\/([0-9._]+).*Safari/.test(navigator.userAgent);
}
function getBrowser() {
  var _a2;
  let ua = navigator.userAgent.toLowerCase();
  if ((_a2 = navigator == null ? void 0 : navigator.brave) == null ? void 0 : _a2.isBrave) {
    return "Brave";
  }
  if (ua.indexOf("edge") > -1 || ua.indexOf("edg/") > -1) {
    return "Edge";
  }
  if (ua.indexOf("chrome") > -1) {
    return "Chrome";
  }
  if (ua.indexOf("firefox") > -1) {
    return "Firefox";
  }
  return "Browser";
}
function groupBy$1(items, getKey) {
  const groupedItems = {};
  items.forEach((item) => {
    const key2 = getKey(item);
    if (!key2) {
      return;
    }
    if (!groupedItems[key2]) {
      groupedItems[key2] = [];
    }
    groupedItems[key2].push(item);
  });
  return groupedItems;
}
var DisclaimerLink = ({
  children,
  href
}) => {
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "a",
    color: "accentColor",
    href,
    rel: "noreferrer",
    target: "_blank"
  }, children);
};
var DisclaimerText = ({
  children
}) => {
  return /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "12",
    weight: "medium"
  }, children);
};
function ConnectModalIntro({
  compactModeEnabled = false,
  getWallet
}) {
  const {
    disclaimer: Disclaimer,
    learnMoreUrl
  } = React48.useContext(AppContext);
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    color: "accentColor",
    display: "flex",
    flexDirection: "column",
    height: "full",
    justifyContent: "space-around"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginBottom: "10"
  }, !compactModeEnabled && /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "18",
    weight: "heavy"
  }, "What is a Wallet?")), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "32",
    justifyContent: "center",
    marginY: "20",
    style: {
      maxWidth: 312
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    gap: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    borderRadius: "6",
    height: "48",
    minWidth: "48",
    width: "48"
  }, /* @__PURE__ */ React48__default.default.createElement(AssetsIcon, null)), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "4"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "14",
    weight: "bold"
  }, "A Home for your Digital Assets"), /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, "Wallets are used to send, receive, store, and display digital assets like Ethereum and NFTs."))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    gap: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    borderRadius: "6",
    height: "48",
    minWidth: "48",
    width: "48"
  }, /* @__PURE__ */ React48__default.default.createElement(LoginIcon, null)), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "4"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "14",
    weight: "bold"
  }, "A New Way to Log In"), /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, "Instead of creating new accounts and passwords on every website, just connect your wallet.")))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "12",
    justifyContent: "center",
    margin: "10"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: "Get a Wallet",
    onClick: getWallet
  }), /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "a",
    className: touchableStyles({
      active: "shrink",
      hover: "grow"
    }),
    display: "block",
    href: learnMoreUrl,
    paddingX: "12",
    paddingY: "4",
    rel: "noreferrer",
    style: {
      willChange: "transform"
    },
    target: "_blank",
    transition: "default"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "accentColor",
    size: "14",
    weight: "bold"
  }, "Learn More"))), Disclaimer && !compactModeEnabled && /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginBottom: "8",
    marginTop: "12",
    textAlign: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Disclaimer, {
    Link: DisclaimerLink,
    Text: DisclaimerText
  }))));
}
var BackIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "17",
  viewBox: "0 0 11 17",
  width: "11",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M0.99707 8.6543C0.99707 9.08496 1.15527 9.44531 1.51562 9.79688L8.16016 16.3096C8.43262 16.5732 8.74902 16.7051 9.13574 16.7051C9.90918 16.7051 10.5508 16.0811 10.5508 15.3076C10.5508 14.9121 10.3838 14.5605 10.0938 14.2705L4.30176 8.64551L10.0938 3.0293C10.3838 2.74805 10.5508 2.3877 10.5508 2.00098C10.5508 1.23633 9.90918 0.603516 9.13574 0.603516C8.74902 0.603516 8.43262 0.735352 8.16016 0.999023L1.51562 7.51172C1.15527 7.85449 1.00586 8.21484 0.99707 8.6543Z",
  fill: "currentColor"
}));
var InfoIcon = () => /* @__PURE__ */ React48__default.default.createElement("svg", {
  fill: "none",
  height: "12",
  viewBox: "0 0 8 12",
  width: "8",
  xmlns: "http://www.w3.org/2000/svg"
}, /* @__PURE__ */ React48__default.default.createElement("path", {
  d: "M3.64258 7.99609C4.19336 7.99609 4.5625 7.73828 4.68555 7.24609C4.69141 7.21094 4.70312 7.16406 4.70898 7.13477C4.80859 6.60742 5.05469 6.35547 6.04492 5.76367C7.14648 5.10156 7.67969 4.3457 7.67969 3.24414C7.67969 1.39844 6.17383 0.255859 3.95898 0.255859C2.32422 0.255859 1.05859 0.894531 0.548828 1.86719C0.396484 2.14844 0.320312 2.44727 0.320312 2.74023C0.314453 3.37305 0.742188 3.79492 1.42188 3.79492C1.91406 3.79492 2.33594 3.54883 2.53516 3.11523C2.78711 2.47656 3.23242 2.21289 3.83594 2.21289C4.55664 2.21289 5.10742 2.65234 5.10742 3.29102C5.10742 3.9707 4.7793 4.29883 3.81836 4.87891C3.02148 5.36523 2.50586 5.92773 2.50586 6.76562V6.90039C2.50586 7.55664 2.96289 7.99609 3.64258 7.99609ZM3.67188 11.4473C4.42773 11.4473 5.04297 10.8672 5.04297 10.1406C5.04297 9.41406 4.42773 8.83984 3.67188 8.83984C2.91602 8.83984 2.30664 9.41406 2.30664 10.1406C2.30664 10.8672 2.91602 11.4473 3.67188 11.4473Z",
  fill: "currentColor"
}));
var InfoButton = ({
  "aria-label": ariaLabel = "Info",
  onClick
}) => {
  const mobile = isMobile$1();
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    "aria-label": ariaLabel,
    as: "button",
    background: "closeButtonBackground",
    borderColor: "actionButtonBorder",
    borderRadius: "full",
    borderStyle: "solid",
    borderWidth: mobile ? "0" : "1",
    className: touchableStyles({
      active: "shrinkSm",
      hover: "growLg"
    }),
    color: "closeButton",
    display: "flex",
    height: mobile ? "30" : "28",
    justifyContent: "center",
    onClick,
    style: {
      willChange: "transform"
    },
    transition: "default",
    type: "button",
    width: mobile ? "30" : "28"
  }, /* @__PURE__ */ React48__default.default.createElement(InfoIcon, null));
};
var useCoolMode = (imageUrl) => {
  const ref = React48.useRef(null);
  const coolModeEnabled = React48.useContext(CoolModeContext);
  const resolvedImageUrl = useAsyncImage(imageUrl);
  React48.useEffect(() => {
    if (coolModeEnabled && ref.current && resolvedImageUrl) {
      return makeElementCool(ref.current, resolvedImageUrl);
    }
  }, [coolModeEnabled, resolvedImageUrl]);
  return ref;
};
var getContainer = () => {
  const id2 = "_rk_coolMode";
  const existingContainer = document.getElementById(id2);
  if (existingContainer) {
    return existingContainer;
  }
  const container = document.createElement("div");
  container.setAttribute("id", id2);
  container.setAttribute("style", ["overflow:hidden", "position:fixed", "height:100%", "top:0", "left:0", "right:0", "bottom:0", "pointer-events:none", "z-index:2147483647"].join(";"));
  document.body.appendChild(container);
  return container;
};
var instanceCounter = 0;
function makeElementCool(element2, imageUrl) {
  instanceCounter++;
  const sizes = [15, 20, 25, 35, 45];
  const limit = 35;
  let particles = [];
  let autoAddParticle = false;
  let mouseX = 0;
  let mouseY = 0;
  const container = getContainer();
  function createParticle() {
    const size2 = sizes[Math.floor(Math.random() * sizes.length)];
    const speedHorz = Math.random() * 10;
    const speedUp = Math.random() * 25;
    const spinVal = Math.random() * 360;
    const spinSpeed = Math.random() * 35 * (Math.random() <= 0.5 ? -1 : 1);
    const top = mouseY - size2 / 2;
    const left = mouseX - size2 / 2;
    const direction = Math.random() <= 0.5 ? -1 : 1;
    const particle = document.createElement("div");
    particle.innerHTML = `<img src="${imageUrl}" width="${size2}" height="${size2}" style="border-radius: 25%">`;
    particle.setAttribute("style", ["position:absolute", "will-change:transform", `top:${top}px`, `left:${left}px`, `transform:rotate(${spinVal}deg)`].join(";"));
    container.appendChild(particle);
    particles.push({
      direction,
      element: particle,
      left,
      size: size2,
      speedHorz,
      speedUp,
      spinSpeed,
      spinVal,
      top
    });
  }
  function updateParticles() {
    particles.forEach((p2) => {
      p2.left = p2.left - p2.speedHorz * p2.direction;
      p2.top = p2.top - p2.speedUp;
      p2.speedUp = Math.min(p2.size, p2.speedUp - 1);
      p2.spinVal = p2.spinVal + p2.spinSpeed;
      if (p2.top >= Math.max(window.innerHeight, document.body.clientHeight) + p2.size) {
        particles = particles.filter((o2) => o2 !== p2);
        p2.element.remove();
      }
      p2.element.setAttribute("style", ["position:absolute", "will-change:transform", `top:${p2.top}px`, `left:${p2.left}px`, `transform:rotate(${p2.spinVal}deg)`].join(";"));
    });
  }
  let animationFrame2;
  function loop() {
    if (autoAddParticle && particles.length < limit) {
      createParticle();
    }
    updateParticles();
    animationFrame2 = requestAnimationFrame(loop);
  }
  loop();
  const isTouchInteraction = "ontouchstart" in window || navigator.msMaxTouchPoints;
  const tap2 = isTouchInteraction ? "touchstart" : "mousedown";
  const tapEnd = isTouchInteraction ? "touchend" : "mouseup";
  const move = isTouchInteraction ? "touchmove" : "mousemove";
  const updateMousePosition = (e2) => {
    var _a2, _b2;
    if ("touches" in e2) {
      mouseX = (_a2 = e2.touches) == null ? void 0 : _a2[0].clientX;
      mouseY = (_b2 = e2.touches) == null ? void 0 : _b2[0].clientY;
    } else {
      mouseX = e2.clientX;
      mouseY = e2.clientY;
    }
  };
  const tapHandler = (e2) => {
    updateMousePosition(e2);
    autoAddParticle = true;
  };
  const disableAutoAddParticle = () => {
    autoAddParticle = false;
  };
  element2.addEventListener(move, updateMousePosition, {
    passive: false
  });
  element2.addEventListener(tap2, tapHandler);
  element2.addEventListener(tapEnd, disableAutoAddParticle);
  element2.addEventListener("mouseleave", disableAutoAddParticle);
  return () => {
    element2.removeEventListener(move, updateMousePosition);
    element2.removeEventListener(tap2, tapHandler);
    element2.removeEventListener(tapEnd, disableAutoAddParticle);
    element2.removeEventListener("mouseleave", disableAutoAddParticle);
    let interval2 = setInterval(() => {
      if (animationFrame2 && particles.length === 0) {
        cancelAnimationFrame(animationFrame2);
        clearInterval(interval2);
        if (--instanceCounter === 0) {
          container.remove();
        }
      }
    }, 500);
  };
}
var transparentBorder = "g5kl0l0";
var ModalSelection = ({
  as = "button",
  currentlySelected = false,
  iconBackground,
  iconUrl,
  name: name2,
  onClick,
  ready,
  recent,
  testId,
  ...urlProps
}) => {
  const coolModeRef = useCoolMode(iconUrl);
  const [isMouseOver, setIsMouseOver] = React48.useState(false);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    onMouseEnter: () => setIsMouseOver(true),
    onMouseLeave: () => setIsMouseOver(false),
    ref: coolModeRef
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    as,
    borderRadius: "menuButton",
    borderStyle: "solid",
    borderWidth: "1",
    className: !currentlySelected ? [transparentBorder, touchableStyles({
      active: "shrink"
    })] : void 0,
    disabled: currentlySelected,
    onClick,
    padding: "5",
    style: {
      willChange: "transform"
    },
    testId,
    transition: "default",
    width: "full",
    ...currentlySelected ? {
      background: "accentColor",
      borderColor: "selectedOptionBorder",
      boxShadow: "selectedWallet"
    } : {
      background: {
        hover: "menuItemBackground"
      }
    },
    ...urlProps
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    color: currentlySelected ? "accentColorForeground" : "modalText",
    disabled: !ready,
    fontFamily: "body",
    fontSize: "16",
    fontWeight: "bold",
    transition: "default"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    gap: "12"
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    background: iconBackground,
    ...isMouseOver ? {} : {
      borderColor: "actionButtonBorder"
    },
    borderRadius: "6",
    height: "28",
    src: iconUrl,
    width: "28"
  }), /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      marginTop: recent ? -2 : void 0
    }
  }, name2), recent && /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: currentlySelected ? "accentColorForeground" : "accentColor",
    size: "12",
    style: {
      lineHeight: 1,
      marginTop: -1
    },
    weight: "medium"
  }, "Recent"))))));
};
ModalSelection.displayName = "ModalSelection";
var convertHexToRGBA = (hexCode, opacity = 1) => {
  let hex2 = hexCode.replace("#", "");
  if (hex2.length === 3) {
    hex2 = `${hex2[0]}${hex2[0]}${hex2[1]}${hex2[1]}${hex2[2]}${hex2[2]}`;
  }
  const r2 = parseInt(hex2.substring(0, 2), 16);
  const g2 = parseInt(hex2.substring(2, 4), 16);
  const b2 = parseInt(hex2.substring(4, 6), 16);
  if (opacity > 1 && opacity <= 100) {
    opacity = opacity / 100;
  }
  return `rgba(${r2},${g2},${b2},${opacity})`;
};
var getGradientRGBAs = (hexColor) => {
  if (!hexColor)
    return null;
  return [convertHexToRGBA(hexColor, 0.2), convertHexToRGBA(hexColor, 0.14), convertHexToRGBA(hexColor, 0.1)];
};
var isHexString$5 = (color) => {
  return /^#([0-9a-f]{3}){1,2}$/i.test(color);
};
var src3 = async () => (await Promise.resolve($$17)).default;
var preloadCreateIcon = () => loadImages(src3);
var CreateIcon = () => /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
  background: "#e3a5e8",
  borderColor: "generalBorder",
  borderRadius: "10",
  height: "48",
  src: src3,
  width: "48"
});
var src4 = async () => (await Promise.resolve($$18)).default;
var preloadRefreshIcon = () => loadImages(src4);
var RefreshIcon = () => /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
  background: "#515a70",
  borderColor: "generalBorder",
  borderRadius: "10",
  height: "48",
  src: src4,
  width: "48"
});
var src5 = async () => (await Promise.resolve($$19)).default;
var preloadScanIcon = () => loadImages(src5);
var ScanIcon = () => /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
  background: "#515a70",
  borderColor: "generalBorder",
  borderRadius: "10",
  height: "48",
  src: src5,
  width: "48"
});
var QRCodeBackgroundClassName = "_1vwt0cg0";
var ScrollClassName = "_1vwt0cg2 ju367v75 ju367v7q";
var sidebar = "_1vwt0cg3";
var sidebarCompactMode = "_1vwt0cg4";
var generateMatrix = (value, errorCorrectionLevel2) => {
  const arr2 = Array.prototype.slice.call(browser$3.create(value, {
    errorCorrectionLevel: errorCorrectionLevel2
  }).modules.data, 0);
  const sqrt = Math.sqrt(arr2.length);
  return arr2.reduce((rows, key2, index2) => (index2 % sqrt === 0 ? rows.push([key2]) : rows[rows.length - 1].push(key2)) && rows, []);
};
function QRCode$5({
  ecl = "M",
  logoBackground,
  logoMargin = 10,
  logoSize = 50,
  logoUrl,
  size: sizeProp = 200,
  uri
}) {
  const padding2 = "20";
  const size2 = sizeProp - parseInt(padding2, 10) * 2;
  const dots = React48.useMemo(() => {
    const dots2 = [];
    const matrix = generateMatrix(uri, ecl);
    const cellSize = size2 / matrix.length;
    let qrList = [{
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 0
    }, {
      x: 0,
      y: 1
    }];
    qrList.forEach(({
      x: x2,
      y: y2
    }) => {
      const x1 = (matrix.length - 7) * cellSize * x2;
      const y1 = (matrix.length - 7) * cellSize * y2;
      for (let i = 0; i < 3; i++) {
        dots2.push(/* @__PURE__ */ React48__default.default.createElement("rect", {
          fill: i % 2 !== 0 ? "white" : "black",
          height: cellSize * (7 - i * 2),
          key: `${i}-${x2}-${y2}`,
          rx: (i - 2) * -5 + (i === 0 ? 2 : 0),
          ry: (i - 2) * -5 + (i === 0 ? 2 : 0),
          width: cellSize * (7 - i * 2),
          x: x1 + cellSize * i,
          y: y1 + cellSize * i
        }));
      }
    });
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    matrix.forEach((row, i) => {
      row.forEach((_2, j2) => {
        if (matrix[i][j2]) {
          if (!(i < 7 && j2 < 7 || i > matrix.length - 8 && j2 < 7 || i < 7 && j2 > matrix.length - 8)) {
            if (!(i > matrixMiddleStart && i < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              dots2.push(/* @__PURE__ */ React48__default.default.createElement("circle", {
                cx: i * cellSize + cellSize / 2,
                cy: j2 * cellSize + cellSize / 2,
                fill: "black",
                key: `circle-${i}-${j2}`,
                r: cellSize / 3
              }));
            }
          }
        }
      });
    });
    return dots2;
  }, [ecl, logoSize, size2, uri]);
  const logoPosition = size2 / 2 - logoSize / 2;
  const logoWrapperSize = logoSize + logoMargin * 2;
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    borderColor: "generalBorder",
    borderRadius: "menuButton",
    borderStyle: "solid",
    borderWidth: "1",
    className: QRCodeBackgroundClassName,
    padding: padding2,
    width: "max"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      height: size2,
      userSelect: "none",
      width: size2
    },
    userSelect: "none"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    justifyContent: "center",
    position: "relative",
    style: {
      height: 0,
      top: logoPosition,
      width: size2
    },
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    background: logoBackground,
    borderColor: {
      custom: "rgba(0, 0, 0, 0.06)"
    },
    borderRadius: "13",
    height: logoSize,
    src: logoUrl,
    width: logoSize
  })), /* @__PURE__ */ React48__default.default.createElement("svg", {
    height: size2,
    style: {
      all: "revert"
    },
    width: size2
  }, /* @__PURE__ */ React48__default.default.createElement("defs", null, /* @__PURE__ */ React48__default.default.createElement("clipPath", {
    id: "clip-wrapper"
  }, /* @__PURE__ */ React48__default.default.createElement("rect", {
    height: logoWrapperSize,
    width: logoWrapperSize
  })), /* @__PURE__ */ React48__default.default.createElement("clipPath", {
    id: "clip-logo"
  }, /* @__PURE__ */ React48__default.default.createElement("rect", {
    height: logoSize,
    width: logoSize
  }))), /* @__PURE__ */ React48__default.default.createElement("rect", {
    fill: "transparent",
    height: size2,
    width: size2
  }), dots)));
}
var getBrowserSrc = async () => {
  const browser2 = getBrowser();
  switch (browser2) {
    case "Chrome":
      return (await Promise.resolve($$20)).default;
    case "Brave":
      return (await Promise.resolve($$21)).default;
    case "Edge":
      return (await Promise.resolve($$22)).default;
    case "Firefox":
      return (await Promise.resolve($$23)).default;
    default:
      return (await Promise.resolve($$24)).default;
  }
};
var preloadBrowserIcon = () => loadImages(getBrowserSrc);
function GetDetail({
  getWalletDownload
}) {
  const wallets2 = useWalletConnectors();
  const shownWallets = wallets2.splice(0, 5);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    height: "full",
    marginTop: "18",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "28",
    height: "full",
    width: "full"
  }, shownWallets == null ? void 0 : shownWallets.filter((wallet) => {
    var _a2, _b2;
    return ((_a2 = wallet.downloadUrls) == null ? void 0 : _a2.browserExtension) || wallet.qrCode && ((_b2 = wallet.downloadUrls) == null ? void 0 : _b2.qrCode);
  }).map((wallet) => {
    const {
      downloadUrls,
      iconBackground,
      iconUrl,
      id: id2,
      name: name2,
      qrCode
    } = wallet;
    const hasMobileCompanionApp = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && qrCode;
    const hasMobileAndExtension = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && (downloadUrls == null ? void 0 : downloadUrls.browserExtension);
    return /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      gap: "16",
      justifyContent: "space-between",
      key: wallet.id,
      width: "full"
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      gap: "16"
    }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
      background: iconBackground,
      borderColor: "actionButtonBorder",
      borderRadius: "10",
      height: "48",
      src: iconUrl,
      width: "48"
    }), /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }, /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalText",
      size: "14",
      weight: "bold"
    }, name2), /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalTextSecondary",
      size: "14",
      weight: "medium"
    }, hasMobileAndExtension ? "Mobile Wallet and Extension" : hasMobileCompanionApp ? "Mobile Wallet" : (downloadUrls == null ? void 0 : downloadUrls.browserExtension) ? "Browser Extension" : null))), /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: "flex",
      flexDirection: "column",
      gap: "4"
    }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
      label: "GET",
      onClick: () => getWalletDownload(id2),
      type: "secondary"
    })));
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    borderRadius: "10",
    display: "flex",
    flexDirection: "column",
    gap: "8",
    justifyContent: "space-between",
    marginBottom: "4",
    paddingY: "8",
    style: {
      maxWidth: 275,
      textAlign: "center"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "14",
    weight: "bold"
  }, "Not what you\u2019re looking for?"), /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, "Select a wallet on the left to get started with a different wallet provider.")));
}
var LOGO_SIZE = "44";
function ConnectDetail({
  changeWalletStep,
  compactModeEnabled,
  connectionError,
  qrCodeUri,
  reconnect,
  wallet
}) {
  var _a2;
  const {
    downloadUrls,
    iconBackground,
    iconUrl,
    name: name2,
    qrCode,
    ready,
    showWalletConnectModal
  } = wallet;
  const getDesktopDeepLink = (_a2 = wallet.desktop) == null ? void 0 : _a2.getUri;
  const safari = isSafari();
  const hasQrCodeAndExtension = (downloadUrls == null ? void 0 : downloadUrls.qrCode) && (downloadUrls == null ? void 0 : downloadUrls.browserExtension);
  const hasQrCode = qrCode && qrCodeUri;
  const secondaryAction = showWalletConnectModal ? {
    description: `Need the ${compactModeEnabled ? "" : "official"} WalletConnect modal?`,
    label: "OPEN",
    onClick: showWalletConnectModal
  } : hasQrCode ? {
    description: `Don\u2019t have ${name2}?`,
    label: "GET",
    onClick: () => changeWalletStep(hasQrCodeAndExtension ? "DOWNLOAD_OPTIONS" : "DOWNLOAD")
  } : null;
  const {
    width: windowWidth
  } = useWindowSize();
  const smallWindow = windowWidth && windowWidth < 768;
  React48.useEffect(() => {
    preloadBrowserIcon();
  }, []);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    height: "full",
    width: "full"
  }, hasQrCode ? /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    height: "full",
    justifyContent: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(QRCode$5, {
    logoBackground: iconBackground,
    logoSize: compactModeEnabled ? 60 : 72,
    logoUrl: iconUrl,
    size: compactModeEnabled ? 318 : smallWindow ? Math.max(280, Math.min(windowWidth - 308, 382)) : 382,
    uri: qrCodeUri
  })) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    justifyContent: "center",
    style: {
      flexGrow: 1
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "8"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    borderRadius: "10",
    height: LOGO_SIZE,
    overflow: "hidden"
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    height: LOGO_SIZE,
    src: iconUrl,
    width: LOGO_SIZE
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "4",
    paddingX: "32",
    style: {
      textAlign: "center"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "18",
    weight: "bold"
  }, ready ? `Opening ${name2}...` : (downloadUrls == null ? void 0 : downloadUrls.browserExtension) ? `${name2} is not installed` : `${name2} is not available`), !ready && (downloadUrls == null ? void 0 : downloadUrls.browserExtension) ? /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingTop: "20"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    href: downloadUrls.browserExtension,
    label: "INSTALL",
    type: "secondary"
  })) : null, ready && !hasQrCode && /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    textAlign: "center",
    weight: "medium"
  }, "Confirm connection in the extension")), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    color: "modalText",
    display: "flex",
    flexDirection: "row",
    height: "32",
    marginTop: "8"
  }, connectionError ? /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: "RETRY",
    onClick: getDesktopDeepLink ? async () => {
      const uri = await getDesktopDeepLink();
      window.open(uri, safari ? "_blank" : "_self");
    } : () => {
      reconnect(wallet);
    }
  }) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    color: "modalTextSecondary"
  }, /* @__PURE__ */ React48__default.default.createElement(SpinnerIcon, null))))))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    borderRadius: "10",
    display: "flex",
    flexDirection: "row",
    gap: "8",
    height: "28",
    justifyContent: "space-between",
    marginTop: "12"
  }, ready && secondaryAction && /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, secondaryAction.description), /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: secondaryAction.label,
    onClick: secondaryAction.onClick,
    type: "secondary"
  }))));
}
var DownloadOptionsBox = ({
  actionLabel,
  description: description2,
  iconAccent,
  iconBackground,
  iconUrl,
  isCompact,
  onAction,
  title,
  url,
  variant
}) => {
  const isBrowserCard = variant === "browser";
  const gradientRgbas = !isBrowserCard && iconAccent && getGradientRGBAs(iconAccent);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    borderRadius: "13",
    display: "flex",
    justifyContent: "center",
    overflow: "hidden",
    paddingX: isCompact ? "18" : "44",
    position: "relative",
    style: {
      flex: 1,
      isolation: "isolate"
    },
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    borderColor: "actionButtonBorder",
    borderRadius: "13",
    borderStyle: "solid",
    borderWidth: "1",
    style: {
      bottom: "0",
      left: "0",
      position: "absolute",
      right: "0",
      top: "0",
      zIndex: 1
    }
  }), isBrowserCard && /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "downloadTopCardBackground",
    height: "full",
    position: "absolute",
    style: {
      zIndex: 0
    },
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    style: {
      bottom: "0",
      filter: "blur(20px)",
      left: "0",
      position: "absolute",
      right: "0",
      top: "0",
      transform: "translate3d(0, 0, 0)"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      filter: "blur(100px)",
      marginLeft: -27,
      marginTop: -20,
      opacity: 0.6,
      transform: "translate3d(0, 0, 0)"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    borderRadius: "full",
    height: "200",
    src: iconUrl,
    width: "200"
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      filter: "blur(100px)",
      marginRight: 0,
      marginTop: 105,
      opacity: 0.6,
      overflow: "auto",
      transform: "translate3d(0, 0, 0)"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    borderRadius: "full",
    height: "200",
    src: iconUrl,
    width: "200"
  })))), !isBrowserCard && gradientRgbas && /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "downloadBottomCardBackground",
    style: {
      bottom: "0",
      left: "0",
      position: "absolute",
      right: "0",
      top: "0"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    position: "absolute",
    style: {
      background: `radial-gradient(50% 50% at 50% 50%, ${gradientRgbas[0]} 0%, ${gradientRgbas[1]} 25%, rgba(0,0,0,0) 100%)`,
      height: 564,
      left: -215,
      top: -197,
      transform: "translate3d(0, 0, 0)",
      width: 564
    }
  }), /* @__PURE__ */ React48__default.default.createElement(Box, {
    position: "absolute",
    style: {
      background: `radial-gradient(50% 50% at 50% 50%, ${gradientRgbas[2]} 0%, rgba(0, 0, 0, 0) 100%)`,
      height: 564,
      left: -1,
      top: -76,
      transform: "translate3d(0, 0, 0)",
      width: 564
    }
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "flex-start",
    display: "flex",
    flexDirection: "row",
    gap: "24",
    height: "max",
    justifyContent: "center",
    style: {
      zIndex: 1
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    height: "60",
    src: iconUrl,
    width: "60",
    ...iconBackground ? {
      background: iconBackground,
      borderColor: "generalBorder",
      borderRadius: "10"
    } : null
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "4",
    style: {
      flex: 1
    },
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "14",
    weight: "bold"
  }, title), /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, description2), /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginTop: "14",
    width: "max"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    href: url,
    label: actionLabel,
    onClick: onAction,
    size: "medium"
  })))));
};
function DownloadOptionsDetail({
  changeWalletStep,
  wallet
}) {
  var _a2;
  const browser2 = getBrowser();
  const modalSize = React48.useContext(ModalSizeContext);
  const isCompact = modalSize === "compact";
  React48.useEffect(() => {
    preloadCreateIcon();
    preloadScanIcon();
    preloadRefreshIcon();
  }, []);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "24",
    height: "full",
    marginBottom: "8",
    marginTop: "4",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "8",
    height: "full",
    justifyContent: "center",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(DownloadOptionsBox, {
    actionLabel: `Add to ${browser2}`,
    description: "Access your wallet right from your favorite web browser.",
    iconUrl: getBrowserSrc,
    isCompact,
    onAction: () => changeWalletStep("INSTRUCTIONS_EXTENSION"),
    title: `${wallet.name} for ${browser2}`,
    url: (_a2 = wallet == null ? void 0 : wallet.downloadUrls) == null ? void 0 : _a2.browserExtension,
    variant: "browser"
  }), /* @__PURE__ */ React48__default.default.createElement(DownloadOptionsBox, {
    actionLabel: "Get the app",
    description: "Use the mobile wallet to explore the world of Ethereum.",
    iconAccent: wallet.iconAccent,
    iconBackground: wallet.iconBackground,
    iconUrl: wallet.iconUrl,
    isCompact,
    onAction: () => {
      changeWalletStep("DOWNLOAD");
    },
    title: `${wallet.name} for Mobile`,
    variant: "app"
  })));
}
function DownloadDetail({
  changeWalletStep,
  wallet
}) {
  const {
    downloadUrls,
    qrCode
  } = wallet;
  React48.useEffect(() => {
    preloadCreateIcon();
    preloadScanIcon();
  }, []);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "24",
    height: "full",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      maxWidth: 220,
      textAlign: "center"
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "semibold"
  }, "Scan with your phone to download on iOS or Android")), /* @__PURE__ */ React48__default.default.createElement(Box, {
    height: "full"
  }, (downloadUrls == null ? void 0 : downloadUrls.qrCode) ? /* @__PURE__ */ React48__default.default.createElement(QRCode$5, {
    logoSize: 0,
    size: 268,
    uri: downloadUrls.qrCode
  }) : null), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    borderRadius: "10",
    display: "flex",
    flexDirection: "row",
    gap: "8",
    height: "34",
    justifyContent: "space-between",
    marginBottom: "12",
    paddingY: "8"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: "Continue",
    onClick: () => changeWalletStep((qrCode == null ? void 0 : qrCode.instructions) ? "INSTRUCTIONS_MOBILE" : "CONNECT")
  })));
}
var stepIcons = {
  create: () => /* @__PURE__ */ React48__default.default.createElement(CreateIcon, null),
  install: (wallet) => /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    background: wallet.iconBackground,
    borderColor: "generalBorder",
    borderRadius: "10",
    height: "48",
    src: wallet.iconUrl,
    width: "48"
  }),
  refresh: () => /* @__PURE__ */ React48__default.default.createElement(RefreshIcon, null),
  scan: () => /* @__PURE__ */ React48__default.default.createElement(ScanIcon, null)
};
function InstructionMobileDetail({
  connectWallet,
  wallet
}) {
  var _a2, _b2, _c2, _d;
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    height: "full",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "28",
    height: "full",
    justifyContent: "center",
    paddingY: "32",
    style: {
      maxWidth: 320
    }
  }, (_b2 = (_a2 = wallet == null ? void 0 : wallet.qrCode) == null ? void 0 : _a2.instructions) == null ? void 0 : _b2.steps.map((d2, idx) => {
    var _a22;
    return /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      gap: "16",
      key: idx
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      borderRadius: "10",
      height: "48",
      minWidth: "48",
      overflow: "hidden",
      position: "relative",
      width: "48"
    }, (_a22 = stepIcons[d2.step]) == null ? void 0 : _a22.call(stepIcons, wallet)), /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: "flex",
      flexDirection: "column",
      gap: "4"
    }, /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalText",
      size: "14",
      weight: "bold"
    }, d2.title), /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalTextSecondary",
      size: "14",
      weight: "medium"
    }, d2.description)));
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "12",
    justifyContent: "center",
    marginBottom: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: "Connect",
    onClick: () => connectWallet(wallet)
  }), /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "a",
    className: touchableStyles({
      active: "shrink",
      hover: "grow"
    }),
    display: "block",
    href: (_d = (_c2 = wallet == null ? void 0 : wallet.qrCode) == null ? void 0 : _c2.instructions) == null ? void 0 : _d.learnMoreUrl,
    paddingX: "12",
    paddingY: "4",
    rel: "noreferrer",
    style: {
      willChange: "transform"
    },
    target: "_blank",
    transition: "default"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "accentColor",
    size: "14",
    weight: "bold"
  }, "Learn More"))));
}
function InstructionExtensionDetail({
  wallet
}) {
  var _a2, _b2;
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    height: "full",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "28",
    height: "full",
    justifyContent: "center",
    paddingY: "32",
    style: {
      maxWidth: 320
    }
  }, (_b2 = (_a2 = wallet == null ? void 0 : wallet.extension) == null ? void 0 : _a2.instructions) == null ? void 0 : _b2.steps.map((d2, idx) => {
    var _a22;
    return /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      flexDirection: "row",
      gap: "16",
      key: idx
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      borderRadius: "10",
      height: "48",
      minWidth: "48",
      overflow: "hidden",
      position: "relative",
      width: "48"
    }, (_a22 = stepIcons[d2.step]) == null ? void 0 : _a22.call(stepIcons, wallet)), /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: "flex",
      flexDirection: "column",
      gap: "4"
    }, /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalText",
      size: "14",
      weight: "bold"
    }, d2.title), /* @__PURE__ */ React48__default.default.createElement(Text, {
      color: "modalTextSecondary",
      size: "14",
      weight: "medium"
    }, d2.description)));
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "12",
    justifyContent: "center",
    marginBottom: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
    label: "Refresh",
    onClick: window.location.reload.bind(window.location)
  })));
}
function DesktopOptions({
  onClose
}) {
  var _a2, _b2, _c2;
  const titleId = "rk_connect_title";
  const safari = isSafari();
  const [selectedOptionId, setSelectedOptionId] = React48.useState();
  const [selectedWallet, setSelectedWallet] = React48.useState();
  const [qrCodeUri, setQrCodeUri] = React48.useState();
  const hasQrCode = !!(selectedWallet == null ? void 0 : selectedWallet.qrCode) && qrCodeUri;
  const [connectionError, setConnectionError] = React48.useState(false);
  const modalSize = React48.useContext(ModalSizeContext);
  const compactModeEnabled = modalSize === ModalSizeOptions.COMPACT;
  const {
    disclaimer: Disclaimer
  } = React48.useContext(AppContext);
  const wallets2 = useWalletConnectors().filter((wallet) => {
    var _a22;
    return wallet.ready || ((_a22 = wallet.downloadUrls) == null ? void 0 : _a22.browserExtension);
  }).sort((a2, b2) => a2.groupIndex - b2.groupIndex);
  const groupedWallets = groupBy$1(wallets2, (wallet) => wallet.groupName);
  const connectToWallet = (wallet) => {
    var _a22, _b22, _c22;
    setConnectionError(false);
    if (wallet.ready) {
      (_b22 = (_a22 = wallet == null ? void 0 : wallet.connect) == null ? void 0 : _a22.call(wallet)) == null ? void 0 : _b22.catch(() => {
        setConnectionError(true);
      });
      const getDesktopDeepLink = (_c22 = wallet.desktop) == null ? void 0 : _c22.getUri;
      if (getDesktopDeepLink) {
        setTimeout(async () => {
          const uri = await getDesktopDeepLink();
          window.open(uri, safari ? "_blank" : "_self");
        }, 0);
      }
    }
  };
  const selectWallet = (wallet) => {
    var _a22;
    connectToWallet(wallet);
    setSelectedOptionId(wallet.id);
    if (wallet.ready) {
      let callbackFired = false;
      (_a22 = wallet == null ? void 0 : wallet.onConnecting) == null ? void 0 : _a22.call(wallet, async () => {
        var _a3, _b22;
        if (callbackFired)
          return;
        callbackFired = true;
        const sWallet = wallets2.find((w2) => wallet.id === w2.id);
        const uri = await ((_a3 = sWallet == null ? void 0 : sWallet.qrCode) == null ? void 0 : _a3.getUri());
        setQrCodeUri(uri);
        setTimeout(() => {
          setSelectedWallet(sWallet);
          changeWalletStep("CONNECT");
        }, uri ? 0 : 50);
        const provider = await (sWallet == null ? void 0 : sWallet.connector.getProvider());
        const connection = (_b22 = provider == null ? void 0 : provider.signer) == null ? void 0 : _b22.connection;
        if ((connection == null ? void 0 : connection.on) && (connection == null ? void 0 : connection.off)) {
          const handleConnectionClose = () => {
            removeHandlers();
            selectWallet(wallet);
          };
          const removeHandlers = () => {
            connection.off("close", handleConnectionClose);
            connection.off("open", removeHandlers);
          };
          connection.on("close", handleConnectionClose);
          connection.on("open", removeHandlers);
        }
      });
    } else {
      setSelectedWallet(wallet);
      changeWalletStep("CONNECT");
    }
  };
  const getWalletDownload = (id2) => {
    var _a22, _b22;
    setSelectedOptionId(id2);
    const sWallet = wallets2.find((w2) => id2 === w2.id);
    const isMobile2 = (_a22 = sWallet == null ? void 0 : sWallet.downloadUrls) == null ? void 0 : _a22.qrCode;
    const isExtension = (_b22 = sWallet == null ? void 0 : sWallet.downloadUrls) == null ? void 0 : _b22.browserExtension;
    setSelectedWallet(sWallet);
    if (isMobile2 && isExtension) {
      changeWalletStep("DOWNLOAD_OPTIONS");
    } else if (isMobile2) {
      changeWalletStep("DOWNLOAD");
    } else {
      changeWalletStep("INSTRUCTIONS_EXTENSION");
    }
  };
  const clearSelectedWallet = () => {
    setSelectedOptionId(void 0);
    setSelectedWallet(void 0);
    setQrCodeUri(void 0);
  };
  const changeWalletStep = (newWalletStep, isBack = false) => {
    if (isBack && newWalletStep === "GET" && initialWalletStep === "GET") {
      clearSelectedWallet();
    } else if (!isBack && newWalletStep === "GET") {
      setInitialWalletStep("GET");
    } else if (!isBack && newWalletStep === "CONNECT") {
      setInitialWalletStep("CONNECT");
    }
    setWalletStep(newWalletStep);
  };
  const [initialWalletStep, setInitialWalletStep] = React48.useState("NONE");
  const [walletStep, setWalletStep] = React48.useState("NONE");
  let walletContent = null;
  let headerLabel = null;
  let headerBackButtonLink = null;
  let headerBackButtonCallback;
  React48.useEffect(() => {
    setConnectionError(false);
  }, [walletStep, selectedWallet]);
  const hasExtensionAndMobile = !!(((_a2 = selectedWallet == null ? void 0 : selectedWallet.downloadUrls) == null ? void 0 : _a2.browserExtension) && (((_b2 = selectedWallet == null ? void 0 : selectedWallet.downloadUrls) == null ? void 0 : _b2.android) || ((_c2 = selectedWallet == null ? void 0 : selectedWallet.downloadUrls) == null ? void 0 : _c2.ios)));
  switch (walletStep) {
    case "NONE":
      walletContent = /* @__PURE__ */ React48__default.default.createElement(ConnectModalIntro, {
        getWallet: () => changeWalletStep("GET")
      });
      break;
    case "LEARN_COMPACT":
      walletContent = /* @__PURE__ */ React48__default.default.createElement(ConnectModalIntro, {
        compactModeEnabled,
        getWallet: () => changeWalletStep("GET")
      });
      headerLabel = "What is a Wallet?";
      headerBackButtonLink = "NONE";
      break;
    case "GET":
      walletContent = /* @__PURE__ */ React48__default.default.createElement(GetDetail, {
        getWalletDownload
      });
      headerLabel = "Get a Wallet";
      headerBackButtonLink = compactModeEnabled ? "LEARN_COMPACT" : "NONE";
      break;
    case "CONNECT":
      walletContent = selectedWallet && /* @__PURE__ */ React48__default.default.createElement(ConnectDetail, {
        changeWalletStep,
        compactModeEnabled,
        connectionError,
        qrCodeUri,
        reconnect: connectToWallet,
        wallet: selectedWallet
      });
      headerLabel = hasQrCode && `Scan with ${selectedWallet.name === "WalletConnect" ? "your phone" : selectedWallet.name}`;
      headerBackButtonLink = compactModeEnabled ? "NONE" : null;
      headerBackButtonCallback = compactModeEnabled ? clearSelectedWallet : () => {
      };
      break;
    case "DOWNLOAD_OPTIONS":
      walletContent = selectedWallet && /* @__PURE__ */ React48__default.default.createElement(DownloadOptionsDetail, {
        changeWalletStep,
        wallet: selectedWallet
      });
      headerLabel = selectedWallet && `Get ${selectedWallet.name}`;
      headerBackButtonLink = initialWalletStep;
      break;
    case "DOWNLOAD":
      walletContent = selectedWallet && /* @__PURE__ */ React48__default.default.createElement(DownloadDetail, {
        changeWalletStep,
        wallet: selectedWallet
      });
      headerLabel = selectedWallet && `Install ${selectedWallet.name}`;
      headerBackButtonLink = hasExtensionAndMobile ? "DOWNLOAD_OPTIONS" : initialWalletStep;
      break;
    case "INSTRUCTIONS_MOBILE":
      walletContent = selectedWallet && /* @__PURE__ */ React48__default.default.createElement(InstructionMobileDetail, {
        connectWallet: selectWallet,
        wallet: selectedWallet
      });
      headerLabel = selectedWallet && `Get started with ${compactModeEnabled ? selectedWallet.shortName || selectedWallet.name : selectedWallet.name}`;
      headerBackButtonLink = "DOWNLOAD";
      break;
    case "INSTRUCTIONS_EXTENSION":
      walletContent = selectedWallet && /* @__PURE__ */ React48__default.default.createElement(InstructionExtensionDetail, {
        wallet: selectedWallet
      });
      headerLabel = selectedWallet && `Get started with ${compactModeEnabled ? selectedWallet.shortName || selectedWallet.name : selectedWallet.name}`;
      headerBackButtonLink = "DOWNLOAD_OPTIONS";
      break;
  }
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "row",
    style: {
      maxHeight: compactModeEnabled ? 468 : 504
    }
  }, (compactModeEnabled ? walletStep === "NONE" : true) && /* @__PURE__ */ React48__default.default.createElement(Box, {
    className: compactModeEnabled ? sidebarCompactMode : sidebar,
    display: "flex",
    flexDirection: "column",
    marginTop: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    justifyContent: "space-between"
  }, compactModeEnabled && Disclaimer && /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginLeft: "16",
    width: "28"
  }, /* @__PURE__ */ React48__default.default.createElement(InfoButton, {
    onClick: () => changeWalletStep("LEARN_COMPACT")
  })), compactModeEnabled && !Disclaimer && /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginLeft: "16",
    width: "28"
  }), /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginLeft: compactModeEnabled ? "0" : "6",
    paddingBottom: "8",
    paddingTop: "2",
    paddingX: "18"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    as: "h1",
    color: "modalText",
    id: titleId,
    size: "18",
    weight: "heavy"
  }, "Connect a Wallet")), compactModeEnabled && /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginRight: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(CloseButton, {
    onClose
  }))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    className: ScrollClassName,
    paddingBottom: "18"
  }, Object.entries(groupedWallets).map(([groupName, wallets22], index2) => wallets22.length > 0 && /* @__PURE__ */ React48__default.default.createElement(React48.Fragment, {
    key: index2
  }, groupName ? /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginBottom: "8",
    marginTop: "16",
    marginX: "6"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "bold"
  }, groupName)) : null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    gap: "4"
  }, wallets22.map((wallet) => {
    return /* @__PURE__ */ React48__default.default.createElement(ModalSelection, {
      currentlySelected: wallet.id === selectedOptionId,
      iconBackground: wallet.iconBackground,
      iconUrl: wallet.iconUrl,
      key: wallet.id,
      name: wallet.name,
      onClick: () => selectWallet(wallet),
      ready: wallet.ready,
      recent: wallet.recent,
      testId: `wallet-option-${wallet.id}`
    });
  }))))), compactModeEnabled && /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "generalBorder",
    height: "1",
    marginTop: "-1"
  }), Disclaimer ? /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingX: "24",
    paddingY: "16",
    textAlign: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Disclaimer, {
    Link: DisclaimerLink,
    Text: DisclaimerText
  })) : /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    justifyContent: "space-between",
    paddingX: "24",
    paddingY: "16"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingY: "4"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalTextSecondary",
    size: "14",
    weight: "medium"
  }, "New to Ethereum wallets?")), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    gap: "4",
    justifyContent: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    className: touchableStyles({
      active: "shrink",
      hover: "grow"
    }),
    cursor: "pointer",
    onClick: () => changeWalletStep("LEARN_COMPACT"),
    paddingY: "4",
    style: {
      willChange: "transform"
    },
    transition: "default"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "accentColor",
    size: "14",
    weight: "bold"
  }, "Learn More")))))), (compactModeEnabled ? walletStep !== "NONE" : true) && /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, !compactModeEnabled && /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: "generalBorder",
    minWidth: "1",
    width: "1"
  }), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    margin: "16",
    style: {
      flexGrow: 1
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    justifyContent: "space-between",
    marginBottom: "12"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    width: "28"
  }, headerBackButtonLink && /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "button",
    className: touchableStyles({
      active: "shrinkSm",
      hover: "growLg"
    }),
    color: "accentColor",
    onClick: () => {
      headerBackButtonLink && changeWalletStep(headerBackButtonLink, true);
      headerBackButtonCallback == null ? void 0 : headerBackButtonCallback();
    },
    paddingX: "8",
    paddingY: "4",
    style: {
      boxSizing: "content-box",
      height: 17,
      willChange: "transform"
    },
    transition: "default",
    type: "button"
  }, /* @__PURE__ */ React48__default.default.createElement(BackIcon, null))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    justifyContent: "center",
    style: {
      flexGrow: 1
    }
  }, headerLabel && /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "modalText",
    size: "18",
    textAlign: "center",
    weight: "heavy"
  }, headerLabel)), /* @__PURE__ */ React48__default.default.createElement(CloseButton, {
    onClose
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    style: {
      minHeight: compactModeEnabled ? 396 : 432
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    gap: "6",
    height: "full",
    justifyContent: "center",
    marginX: "8"
  }, walletContent)))));
}
var scroll = "_1am14410";
function WalletButton$1({
  wallet
}) {
  const {
    connect,
    connector,
    iconBackground,
    iconUrl,
    id: id2,
    mobile,
    name: name2,
    onConnecting,
    ready,
    shortName
  } = wallet;
  const getMobileUri = mobile == null ? void 0 : mobile.getUri;
  const coolModeRef = useCoolMode(iconUrl);
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "button",
    color: ready ? "modalText" : "modalTextSecondary",
    disabled: !ready,
    fontFamily: "body",
    key: id2,
    onClick: React48.useCallback(async () => {
      connect == null ? void 0 : connect();
      let callbackFired = false;
      onConnecting == null ? void 0 : onConnecting(async () => {
        if (callbackFired)
          return;
        callbackFired = true;
        if (getMobileUri) {
          const mobileUri = await getMobileUri();
          if (connector.id === "walletConnect") {
            setWalletConnectDeepLink({
              mobileUri,
              name: name2
            });
          }
          if (mobileUri.startsWith("http")) {
            const link = document.createElement("a");
            link.href = mobileUri;
            link.target = "_blank";
            link.rel = "noreferrer noopener";
            link.click();
          } else {
            window.location.href = mobileUri;
          }
        }
      });
    }, [connector, connect, getMobileUri, onConnecting, name2]),
    ref: coolModeRef,
    style: {
      overflow: "visible",
      textAlign: "center"
    },
    testId: `wallet-option-${id2}`,
    type: "button",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    paddingBottom: "8",
    paddingTop: "10"
  }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
    background: iconBackground,
    borderRadius: "13",
    boxShadow: "walletLogo",
    height: "60",
    src: iconUrl,
    width: "60"
  })), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    textAlign: "center"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    as: "h2",
    color: wallet.ready ? "modalText" : "modalTextSecondary",
    size: "13",
    weight: "medium"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    as: "span",
    position: "relative"
  }, shortName != null ? shortName : name2, !wallet.ready && " (unsupported)")), wallet.recent && /* @__PURE__ */ React48__default.default.createElement(Text, {
    color: "accentColor",
    size: "12",
    weight: "medium"
  }, "Recent"))));
}
function MobileOptions({
  onClose
}) {
  var _a2;
  const titleId = "rk_connect_title";
  const wallets2 = useWalletConnectors();
  const {
    disclaimer: Disclaimer,
    learnMoreUrl
  } = React48.useContext(AppContext);
  let headerLabel = null;
  let walletContent = null;
  let headerBackgroundContrast = false;
  let headerBackButtonLink = null;
  const [walletStep, setWalletStep] = React48.useState("CONNECT");
  const ios = isIOS$1();
  switch (walletStep) {
    case "CONNECT": {
      headerLabel = "Connect a Wallet";
      headerBackgroundContrast = true;
      walletContent = /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
        background: "profileForeground",
        className: scroll,
        display: "flex",
        paddingBottom: "20",
        paddingTop: "6"
      }, /* @__PURE__ */ React48__default.default.createElement(Box, {
        display: "flex",
        style: {
          margin: "0 auto"
        }
      }, wallets2.filter((wallet) => wallet.ready).map((wallet) => {
        return /* @__PURE__ */ React48__default.default.createElement(Box, {
          key: wallet.id,
          paddingX: "20"
        }, /* @__PURE__ */ React48__default.default.createElement(Box, {
          width: "60"
        }, /* @__PURE__ */ React48__default.default.createElement(WalletButton$1, {
          wallet
        })));
      }))), /* @__PURE__ */ React48__default.default.createElement(Box, {
        background: "generalBorder",
        height: "1",
        marginBottom: "32",
        marginTop: "-1"
      }), /* @__PURE__ */ React48__default.default.createElement(Box, {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "32",
        paddingX: "32",
        style: {
          textAlign: "center"
        }
      }, /* @__PURE__ */ React48__default.default.createElement(Box, {
        display: "flex",
        flexDirection: "column",
        gap: "8",
        textAlign: "center"
      }, /* @__PURE__ */ React48__default.default.createElement(Text, {
        color: "modalText",
        size: "16",
        weight: "bold"
      }, "What is a Wallet?"), /* @__PURE__ */ React48__default.default.createElement(Text, {
        color: "modalTextSecondary",
        size: "16"
      }, "A wallet is used to send, receive, store, and display digital assets. It\u2019s also a new way to log in, without needing to create new accounts and passwords on\xA0every\xA0website."))), /* @__PURE__ */ React48__default.default.createElement(Box, {
        paddingTop: "32",
        paddingX: "20"
      }, /* @__PURE__ */ React48__default.default.createElement(Box, {
        display: "flex",
        gap: "14",
        justifyContent: "center"
      }, /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
        label: "Get a Wallet",
        onClick: () => setWalletStep("GET"),
        size: "large",
        type: "secondary"
      }), /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
        href: learnMoreUrl,
        label: "Learn More",
        size: "large",
        type: "secondary"
      }))), Disclaimer && /* @__PURE__ */ React48__default.default.createElement(Box, {
        marginTop: "28",
        marginX: "32",
        textAlign: "center"
      }, /* @__PURE__ */ React48__default.default.createElement(Disclaimer, {
        Link: DisclaimerLink,
        Text: DisclaimerText
      })));
      break;
    }
    case "GET": {
      headerLabel = "Get a Wallet";
      headerBackButtonLink = "CONNECT";
      const mobileWallets = (_a2 = wallets2 == null ? void 0 : wallets2.filter((wallet) => {
        var _a22, _b2;
        return ((_a22 = wallet.downloadUrls) == null ? void 0 : _a22.ios) || ((_b2 = wallet.downloadUrls) == null ? void 0 : _b2.android);
      })) == null ? void 0 : _a2.splice(0, 3);
      walletContent = /* @__PURE__ */ React48__default.default.createElement(Box, null, /* @__PURE__ */ React48__default.default.createElement(Box, {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        height: "full",
        marginBottom: "36",
        marginTop: "5",
        paddingTop: "12",
        width: "full"
      }, mobileWallets.map((wallet, index2) => {
        const {
          downloadUrls,
          iconBackground,
          iconUrl,
          name: name2
        } = wallet;
        if (!(downloadUrls == null ? void 0 : downloadUrls.ios) && !(downloadUrls == null ? void 0 : downloadUrls.android)) {
          return null;
        }
        return /* @__PURE__ */ React48__default.default.createElement(Box, {
          display: "flex",
          gap: "16",
          key: wallet.id,
          paddingX: "20",
          width: "full"
        }, /* @__PURE__ */ React48__default.default.createElement(Box, {
          style: {
            minHeight: 48,
            minWidth: 48
          }
        }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
          background: iconBackground,
          borderColor: "generalBorder",
          borderRadius: "10",
          height: "48",
          src: iconUrl,
          width: "48"
        })), /* @__PURE__ */ React48__default.default.createElement(Box, {
          display: "flex",
          flexDirection: "column",
          width: "full"
        }, /* @__PURE__ */ React48__default.default.createElement(Box, {
          alignItems: "center",
          display: "flex",
          height: "48"
        }, /* @__PURE__ */ React48__default.default.createElement(Box, {
          width: "full"
        }, /* @__PURE__ */ React48__default.default.createElement(Text, {
          color: "modalText",
          size: "18",
          weight: "bold"
        }, name2)), /* @__PURE__ */ React48__default.default.createElement(ActionButton, {
          href: ios ? downloadUrls == null ? void 0 : downloadUrls.ios : downloadUrls == null ? void 0 : downloadUrls.android,
          label: "GET",
          size: "small",
          type: "secondary"
        })), index2 < mobileWallets.length - 1 && /* @__PURE__ */ React48__default.default.createElement(Box, {
          background: "generalBorderDim",
          height: "1",
          marginY: "10",
          width: "full"
        })));
      })), /* @__PURE__ */ React48__default.default.createElement(Box, {
        style: {
          marginBottom: "42px"
        }
      }), /* @__PURE__ */ React48__default.default.createElement(Box, {
        alignItems: "center",
        display: "flex",
        flexDirection: "column",
        gap: "36",
        paddingX: "36",
        style: {
          textAlign: "center"
        }
      }, /* @__PURE__ */ React48__default.default.createElement(Box, {
        display: "flex",
        flexDirection: "column",
        gap: "12",
        textAlign: "center"
      }, /* @__PURE__ */ React48__default.default.createElement(Text, {
        color: "modalText",
        size: "16",
        weight: "bold"
      }, "Not what you\u2019re looking for?"), /* @__PURE__ */ React48__default.default.createElement(Text, {
        color: "modalTextSecondary",
        size: "16"
      }, "Select a wallet on the main screen to get started with a different wallet provider."))));
      break;
    }
  }
  return /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    paddingBottom: "36"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    background: headerBackgroundContrast ? "profileForeground" : "modalBackground",
    display: "flex",
    flexDirection: "column",
    paddingBottom: "4",
    paddingTop: "14"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    justifyContent: "center",
    paddingBottom: "6",
    paddingX: "20",
    position: "relative"
  }, headerBackButtonLink && /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    position: "absolute",
    style: {
      left: 0,
      marginBottom: -20,
      marginTop: -20
    }
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    as: "button",
    className: touchableStyles({
      active: "shrinkSm",
      hover: "growLg"
    }),
    color: "accentColor",
    display: "flex",
    marginLeft: "4",
    marginTop: "20",
    onClick: () => setWalletStep(headerBackButtonLink),
    padding: "16",
    style: {
      height: 17,
      willChange: "transform"
    },
    transition: "default",
    type: "button"
  }, /* @__PURE__ */ React48__default.default.createElement(BackIcon, null))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    marginTop: "4",
    textAlign: "center",
    width: "full"
  }, /* @__PURE__ */ React48__default.default.createElement(Text, {
    as: "h1",
    color: "modalText",
    id: titleId,
    size: "20",
    weight: "bold"
  }, headerLabel)), /* @__PURE__ */ React48__default.default.createElement(Box, {
    alignItems: "center",
    display: "flex",
    height: "32",
    paddingRight: "14",
    position: "absolute",
    right: "0"
  }, /* @__PURE__ */ React48__default.default.createElement(Box, {
    style: {
      marginBottom: -20,
      marginTop: -20
    }
  }, /* @__PURE__ */ React48__default.default.createElement(CloseButton, {
    onClose
  }))))), /* @__PURE__ */ React48__default.default.createElement(Box, {
    display: "flex",
    flexDirection: "column"
  }, walletContent));
}
function ConnectOptions({
  onClose
}) {
  return isMobile$1() ? /* @__PURE__ */ React48__default.default.createElement(MobileOptions, {
    onClose
  }) : /* @__PURE__ */ React48__default.default.createElement(DesktopOptions, {
    onClose
  });
}
function ConnectModal({
  onClose,
  open: open2
}) {
  const titleId = "rk_connect_title";
  const connectionStatus = useConnectionStatus();
  if (connectionStatus === "disconnected") {
    return /* @__PURE__ */ React48__default.default.createElement(Dialog, {
      onClose,
      open: open2,
      titleId
    }, /* @__PURE__ */ React48__default.default.createElement(DialogContent, {
      bottomSheetOnMobile: true,
      padding: "0",
      wide: true
    }, /* @__PURE__ */ React48__default.default.createElement(ConnectOptions, {
      onClose
    })));
  }
  if (connectionStatus === "unauthenticated") {
    return /* @__PURE__ */ React48__default.default.createElement(Dialog, {
      onClose,
      open: open2,
      titleId
    }, /* @__PURE__ */ React48__default.default.createElement(DialogContent, {
      bottomSheetOnMobile: true,
      padding: "0"
    }, /* @__PURE__ */ React48__default.default.createElement(SignIn, {
      onClose
    })));
  }
  return null;
}
function useModalStateValue() {
  const [isModalOpen, setModalOpen] = React48.useState(false);
  return {
    closeModal: React48.useCallback(() => setModalOpen(false), []),
    isModalOpen,
    openModal: React48.useCallback(() => setModalOpen(true), [])
  };
}
var ModalContext = React48.createContext({
  accountModalOpen: false,
  chainModalOpen: false,
  connectModalOpen: false
});
function ModalProvider({
  children
}) {
  const {
    closeModal: closeConnectModal,
    isModalOpen: connectModalOpen,
    openModal: openConnectModal
  } = useModalStateValue();
  const {
    closeModal: closeAccountModal,
    isModalOpen: accountModalOpen,
    openModal: openAccountModal
  } = useModalStateValue();
  const {
    closeModal: closeChainModal,
    isModalOpen: chainModalOpen,
    openModal: openChainModal
  } = useModalStateValue();
  const connectionStatus = useConnectionStatus();
  const {
    chain
  } = wagmi.useNetwork();
  const chainSupported = !(chain == null ? void 0 : chain.unsupported);
  function closeModals({
    keepConnectModalOpen = false
  } = {}) {
    if (!keepConnectModalOpen) {
      closeConnectModal();
    }
    closeAccountModal();
    closeChainModal();
  }
  const isUnauthenticated = useAuthenticationStatus() === "unauthenticated";
  wagmi.useAccount({
    onConnect: () => closeModals({
      keepConnectModalOpen: isUnauthenticated
    }),
    onDisconnect: () => closeModals()
  });
  return /* @__PURE__ */ React48__default.default.createElement(ModalContext.Provider, {
    value: React48.useMemo(() => ({
      accountModalOpen,
      chainModalOpen,
      connectModalOpen,
      openAccountModal: chainSupported && connectionStatus === "connected" ? openAccountModal : void 0,
      openChainModal: connectionStatus === "connected" ? openChainModal : void 0,
      openConnectModal: connectionStatus === "disconnected" || connectionStatus === "unauthenticated" ? openConnectModal : void 0
    }), [connectionStatus, chainSupported, accountModalOpen, chainModalOpen, connectModalOpen, openAccountModal, openChainModal, openConnectModal])
  }, children, /* @__PURE__ */ React48__default.default.createElement(ConnectModal, {
    onClose: closeConnectModal,
    open: connectModalOpen
  }), /* @__PURE__ */ React48__default.default.createElement(AccountModal, {
    onClose: closeAccountModal,
    open: accountModalOpen
  }), /* @__PURE__ */ React48__default.default.createElement(ChainModal, {
    onClose: closeChainModal,
    open: chainModalOpen
  }));
}
function useModalState() {
  const {
    accountModalOpen,
    chainModalOpen,
    connectModalOpen
  } = React48.useContext(ModalContext);
  return {
    accountModalOpen,
    chainModalOpen,
    connectModalOpen
  };
}
function useAccountModal() {
  const {
    openAccountModal
  } = React48.useContext(ModalContext);
  return {
    openAccountModal
  };
}
function useChainModal() {
  const {
    openChainModal
  } = React48.useContext(ModalContext);
  return {
    openChainModal
  };
}
function useConnectModal() {
  const {
    openConnectModal
  } = React48.useContext(ModalContext);
  return {
    openConnectModal
  };
}
var noop$4 = () => {
};
function ConnectButtonRenderer({
  children
}) {
  var _a2, _b2, _c2;
  const mounted = useIsMounted();
  const {
    address
  } = wagmi.useAccount();
  const ensAvatar = useMainnetEnsAvatar(address);
  const ensName = useMainnetEnsName(address);
  const {
    data: balanceData
  } = wagmi.useBalance({
    address
  });
  const {
    chain: activeChain
  } = wagmi.useNetwork();
  const rainbowkitChainsById = useRainbowKitChainsById();
  const authenticationStatus = (_a2 = useAuthenticationStatus()) != null ? _a2 : void 0;
  const rainbowKitChain = activeChain ? rainbowkitChainsById[activeChain.id] : void 0;
  const chainIconUrl = (_b2 = rainbowKitChain == null ? void 0 : rainbowKitChain.iconUrl) != null ? _b2 : void 0;
  const chainIconBackground = (_c2 = rainbowKitChain == null ? void 0 : rainbowKitChain.iconBackground) != null ? _c2 : void 0;
  const resolvedChainIconUrl = useAsyncImage(chainIconUrl);
  const showRecentTransactions = React48.useContext(ShowRecentTransactionsContext);
  const hasPendingTransactions = useRecentTransactions().some(({
    status
  }) => status === "pending") && showRecentTransactions;
  const displayBalance = balanceData ? `${abbreviateETHBalance(parseFloat(balanceData.formatted))} ${balanceData.symbol}` : void 0;
  const {
    openConnectModal
  } = useConnectModal();
  const {
    openChainModal
  } = useChainModal();
  const {
    openAccountModal
  } = useAccountModal();
  const {
    accountModalOpen,
    chainModalOpen,
    connectModalOpen
  } = useModalState();
  return /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, children({
    account: address ? {
      address,
      balanceDecimals: balanceData == null ? void 0 : balanceData.decimals,
      balanceFormatted: balanceData == null ? void 0 : balanceData.formatted,
      balanceSymbol: balanceData == null ? void 0 : balanceData.symbol,
      displayBalance,
      displayName: ensName ? formatENS(ensName) : formatAddress(address),
      ensAvatar: ensAvatar != null ? ensAvatar : void 0,
      ensName: ensName != null ? ensName : void 0,
      hasPendingTransactions
    } : void 0,
    accountModalOpen,
    authenticationStatus,
    chain: activeChain ? {
      hasIcon: Boolean(chainIconUrl),
      iconBackground: chainIconBackground,
      iconUrl: resolvedChainIconUrl,
      id: activeChain.id,
      name: activeChain.name,
      unsupported: activeChain.unsupported
    } : void 0,
    chainModalOpen,
    connectModalOpen,
    mounted,
    openAccountModal: openAccountModal != null ? openAccountModal : noop$4,
    openChainModal: openChainModal != null ? openChainModal : noop$4,
    openConnectModal: openConnectModal != null ? openConnectModal : noop$4
  }));
}
ConnectButtonRenderer.displayName = "ConnectButton.Custom";
var defaultProps = {
  accountStatus: "full",
  chainStatus: {
    largeScreen: "full",
    smallScreen: "icon"
  },
  label: "Connect Wallet",
  showBalance: {
    largeScreen: true,
    smallScreen: false
  }
};
function ConnectButton$1({
  accountStatus = defaultProps.accountStatus,
  chainStatus = defaultProps.chainStatus,
  label = defaultProps.label,
  showBalance = defaultProps.showBalance
}) {
  const chains = useRainbowKitChains();
  const connectionStatus = useConnectionStatus();
  return /* @__PURE__ */ React48__default.default.createElement(ConnectButtonRenderer, null, ({
    account,
    chain,
    mounted,
    openAccountModal,
    openChainModal,
    openConnectModal
  }) => {
    var _a2, _b2, _c2;
    const ready = mounted && connectionStatus !== "loading";
    const unsupportedChain = (_a2 = chain == null ? void 0 : chain.unsupported) != null ? _a2 : false;
    return /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: "flex",
      gap: "12",
      ...!ready && {
        "aria-hidden": true,
        "style": {
          opacity: 0,
          pointerEvents: "none",
          userSelect: "none"
        }
      }
    }, ready && account && connectionStatus === "connected" ? /* @__PURE__ */ React48__default.default.createElement(React48__default.default.Fragment, null, chain && (chains.length > 1 || unsupportedChain) && /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      "aria-label": "Chain Selector",
      as: "button",
      background: unsupportedChain ? "connectButtonBackgroundError" : "connectButtonBackground",
      borderRadius: "connectButton",
      boxShadow: "connectButton",
      className: touchableStyles({
        active: "shrink",
        hover: "grow"
      }),
      color: unsupportedChain ? "connectButtonTextError" : "connectButtonText",
      display: mapResponsiveValue(chainStatus, (value) => value === "none" ? "none" : "flex"),
      fontFamily: "body",
      fontWeight: "bold",
      gap: "6",
      key: unsupportedChain ? "unsupported" : "supported",
      onClick: openChainModal,
      paddingX: "10",
      paddingY: "8",
      testId: unsupportedChain ? "wrong-network-button" : "chain-button",
      transition: "default",
      type: "button"
    }, unsupportedChain ? /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      height: "24",
      paddingX: "4"
    }, "Wrong network") : /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      gap: "6"
    }, chain.hasIcon ? /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: mapResponsiveValue(chainStatus, (value) => value === "full" || value === "icon" ? "block" : "none"),
      height: "24",
      width: "24"
    }, /* @__PURE__ */ React48__default.default.createElement(AsyncImage, {
      alt: (_b2 = chain.name) != null ? _b2 : "Chain icon",
      background: chain.iconBackground,
      borderRadius: "full",
      height: "24",
      src: chain.iconUrl,
      width: "24"
    })) : null, /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: mapResponsiveValue(chainStatus, (value) => {
        if (value === "icon" && !chain.iconUrl) {
          return "block";
        }
        return value === "full" || value === "name" ? "block" : "none";
      })
    }, (_c2 = chain.name) != null ? _c2 : chain.id)), /* @__PURE__ */ React48__default.default.createElement(DropdownIcon, null)), !unsupportedChain && /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      as: "button",
      background: "connectButtonBackground",
      borderRadius: "connectButton",
      boxShadow: "connectButton",
      className: touchableStyles({
        active: "shrink",
        hover: "grow"
      }),
      color: "connectButtonText",
      display: "flex",
      fontFamily: "body",
      fontWeight: "bold",
      onClick: openAccountModal,
      testId: "account-button",
      transition: "default",
      type: "button"
    }, account.displayBalance && /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: mapResponsiveValue(showBalance, (value) => value ? "block" : "none"),
      padding: "8",
      paddingLeft: "12"
    }, account.displayBalance), /* @__PURE__ */ React48__default.default.createElement(Box, {
      background: normalizeResponsiveValue(showBalance)[isMobile$1() ? "smallScreen" : "largeScreen"] ? "connectButtonInnerBackground" : "connectButtonBackground",
      borderColor: "connectButtonBackground",
      borderRadius: "connectButton",
      borderStyle: "solid",
      borderWidth: "2",
      color: "connectButtonText",
      fontFamily: "body",
      fontWeight: "bold",
      paddingX: "8",
      paddingY: "6",
      transition: "default"
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      gap: "6",
      height: "24"
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: mapResponsiveValue(accountStatus, (value) => value === "full" || value === "avatar" ? "block" : "none")
    }, /* @__PURE__ */ React48__default.default.createElement(Avatar, {
      address: account.address,
      imageUrl: account.ensAvatar,
      loading: account.hasPendingTransactions,
      size: 24
    })), /* @__PURE__ */ React48__default.default.createElement(Box, {
      alignItems: "center",
      display: "flex",
      gap: "6"
    }, /* @__PURE__ */ React48__default.default.createElement(Box, {
      display: mapResponsiveValue(accountStatus, (value) => value === "full" || value === "address" ? "block" : "none")
    }, account.displayName), /* @__PURE__ */ React48__default.default.createElement(DropdownIcon, null)))))) : /* @__PURE__ */ React48__default.default.createElement(Box, {
      as: "button",
      background: "accentColor",
      borderRadius: "connectButton",
      boxShadow: "connectButton",
      className: touchableStyles({
        active: "shrink",
        hover: "grow"
      }),
      color: "accentColorForeground",
      fontFamily: "body",
      fontWeight: "bold",
      height: "40",
      key: "connect",
      onClick: openConnectModal,
      paddingX: "14",
      testId: "connect-button",
      transition: "default",
      type: "button"
    }, label));
  });
}
ConnectButton$1.__defaultProps = defaultProps;
ConnectButton$1.Custom = ConnectButtonRenderer;
var events = { exports: {} };
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$1 && typeof R$1.ownKeys === "function") {
  ReflectOwnKeys = R$1.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1;
events.exports.once = once$2;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$1.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function emit(type2) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type2 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type2];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone$1(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type2, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type2, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (existing === void 0) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type2;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter$1.prototype.addListener = function addListener(type2, listener) {
  return _addListener(this, type2, listener, false);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function prependListener(type2, listener) {
  return _addListener(this, type2, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type2, listener) {
  var state2 = {
    fired: false,
    wrapFn: void 0,
    target,
    type: type2,
    listener
  };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$1.prototype.once = function once(type2, listener) {
  checkListener(listener);
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
  checkListener(listener);
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter$1.prototype.removeListener = function removeListener(type2, listener) {
  var list, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type2];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type2] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type2) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type2] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key2;
    for (i = 0; i < keys.length; ++i) {
      key2 = keys[i];
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type2];
  if (typeof listeners2 === "function") {
    this.removeListener(type2, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type2, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type2, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type2];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone$1(evlistener, evlistener.length);
}
EventEmitter$1.prototype.listeners = function listeners(type2) {
  return _listeners(this, type2, true);
};
EventEmitter$1.prototype.rawListeners = function rawListeners(type2) {
  return _listeners(this, type2, false);
};
EventEmitter$1.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount.call(emitter, type2);
  }
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type2) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$1(arr2, n2) {
  var copy2 = new Array(n2);
  for (var i = 0; i < n2; ++i)
    copy2[i] = arr2[i];
  return copy2;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr2) {
  var ret = new Array(arr2.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr2[i].listener || arr2[i];
  }
  return ret;
}
function once$2(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, {
      once: true
    });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
const PARSE_ERROR = "PARSE_ERROR";
const INVALID_REQUEST = "INVALID_REQUEST";
const METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
const INVALID_PARAMS = "INVALID_PARAMS";
const INTERNAL_ERROR = "INTERNAL_ERROR";
const SERVER_ERROR = "SERVER_ERROR";
const RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
const STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: {
    code: -32700,
    message: "Parse error"
  },
  [INVALID_REQUEST]: {
    code: -32600,
    message: "Invalid Request"
  },
  [METHOD_NOT_FOUND]: {
    code: -32601,
    message: "Method not found"
  },
  [INVALID_PARAMS]: {
    code: -32602,
    message: "Invalid params"
  },
  [INTERNAL_ERROR]: {
    code: -32603,
    message: "Internal error"
  },
  [SERVER_ERROR]: {
    code: -32e3,
    message: "Server error"
  }
};
const DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function getError$1(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function parseConnectionError(e2, url, type2) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e2;
}
var cjs$3 = {};
var tslib = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate2;
  var __param2;
  var __metadata2;
  var __awaiter2;
  var __generator2;
  var __exportStar2;
  var __values2;
  var __read2;
  var __spread2;
  var __spreadArrays2;
  var __await2;
  var __asyncGenerator2;
  var __asyncDelegator2;
  var __asyncValues2;
  var __makeTemplateObject2;
  var __importStar2;
  var __importDefault2;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __createBinding2;
  (function(factory) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory(createExporter(root, createExporter(module2.exports)));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id2, v2) {
        return exports2[id2] = previous ? previous(id2, v2) : v2;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (b2.hasOwnProperty(p2))
          d2[p2] = b2[p2];
    };
    __extends2 = function(d2, b2) {
      extendStatics2(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
    __assign2 = Object.assign || function(t2) {
      for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
        s2 = arguments[i];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    __rest2 = function(s2, e2) {
      var t2 = {};
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
            t2[p2[i]] = s2[p2[i]];
        }
      return t2;
    };
    __decorate2 = function(decorators, target, key2, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d2 = decorators[i])
            r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
    };
    __param2 = function(paramIndex, decorator) {
      return function(target, key2) {
        decorator(target, key2, paramIndex);
      };
    };
    __metadata2 = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _2 = {
        label: 0,
        sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        },
        trys: [],
        ops: []
      }, f2, y2, t2, g2;
      return g2 = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    __createBinding2 = function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    };
    __exportStar2 = function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !exports2.hasOwnProperty(p2))
          exports2[p2] = m2[p2];
    };
    __values2 = function(o2) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i >= o2.length)
              o2 = void 0;
            return {
              value: o2 && o2[i++],
              done: !o2
            };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = {
          error
        };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spread2 = function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read2(arguments[i]));
      return ar;
    };
    __spreadArrays2 = function() {
      for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
        s2 += arguments[i].length;
      for (var r2 = Array(s2), k2 = 0, i = 0; i < il; i++)
        for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    };
    __await2 = function(v2) {
      return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
    };
    __asyncGenerator2 = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n2) {
        if (g2[n2])
          i[n2] = function(v2) {
            return new Promise(function(a2, b2) {
              q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
            });
          };
      }
      function resume(n2, v2) {
        try {
          step(g2[n2](v2));
        } catch (e2) {
          settle(q2[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v2) {
        if (f2(v2), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator2 = function(o2) {
      var i, p2;
      return i = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n2, f2) {
        i[n2] = o2[n2] ? function(v2) {
          return (p2 = !p2) ? {
            value: __await2(o2[n2](v2)),
            done: n2 === "return"
          } : f2 ? f2(v2) : v2;
        } : f2;
      }
    };
    __asyncValues2 = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o2[Symbol.asyncIterator], i;
      return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n2) {
        i[n2] = o2[n2] && function(v2) {
          return new Promise(function(resolve, reject) {
            v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
          });
        };
      }
      function settle(resolve, reject, d2, v2) {
        Promise.resolve(v2).then(function(v3) {
          resolve({
            value: v3,
            done: d2
          });
        }, reject);
      }
    };
    __makeTemplateObject2 = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
          value: raw
        });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar2 = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (Object.hasOwnProperty.call(mod, k2))
            result[k2] = mod[k2];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault2 = function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    __classPrivateFieldGet2 = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet2 = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate2);
    exporter("__param", __param2);
    exporter("__metadata", __metadata2);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar2);
    exporter("__createBinding", __createBinding2);
    exporter("__values", __values2);
    exporter("__read", __read2);
    exporter("__spread", __spread2);
    exporter("__spreadArrays", __spreadArrays2);
    exporter("__await", __await2);
    exporter("__asyncGenerator", __asyncGenerator2);
    exporter("__asyncDelegator", __asyncDelegator2);
    exporter("__asyncValues", __asyncValues2);
    exporter("__makeTemplateObject", __makeTemplateObject2);
    exporter("__importStar", __importStar2);
    exporter("__importDefault", __importDefault2);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
  });
})(tslib);
var crypto$2 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto)
    return crypto$2;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$2, "__esModule", {
    value: true
  });
  crypto$2.isBrowserCryptoAvailable = crypto$2.getSubtleCrypto = crypto$2.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$2.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto$2.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto$2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  return crypto$2;
}
var env = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv)
    return env;
  hasRequiredEnv = 1;
  Object.defineProperty(env, "__esModule", {
    value: true
  });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }
  env.isReactNative = isReactNative;
  function isNode2() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }
  env.isNode = isNode2;
  function isBrowser2() {
    return !isReactNative() && !isNode2();
  }
  env.isBrowser = isBrowser2;
  return env;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  const tslib_12 = tslib.exports;
  tslib_12.__exportStar(requireCrypto(), exports2);
  tslib_12.__exportStar(requireEnv(), exports2);
})(cjs$3);
function payloadId$1(entropy = 3) {
  const date2 = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date2 + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId$1(entropy));
}
function formatJsonRpcRequest(method, params, id2) {
  return {
    id: id2 || payloadId$1(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcError(id2, error, data) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError$1(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError$1(SERVER_ERROR)), {
      message: error
    });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
class IEvents {
}
class IJsonRpcConnection extends IEvents {
  constructor(opts) {
    super();
  }
}
class IBaseJsonRpcProvider extends IEvents {
  constructor() {
    super();
  }
}
class IJsonRpcProvider extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
}
const HTTP_REGEX = "^https?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex2) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex2).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
class JsonRpcProvider extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new events.exports.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e2) {
          reject(e2);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e2) {
        reject(e2);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  onClose(event) {
    if (event && event.code === 3e3) {
      this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
    }
    this.events.emit("disconnect");
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", (event) => this.onClose(event));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.connection.on("register_error", (error) => this.onClose());
    this.hasRegisteredEventListeners = true;
  }
}
var browserPonyfill = { exports: {} };
(function(module2, exports2) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports3) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name2) {
        if (typeof name2 !== "string") {
          name2 = String(name2);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name2.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator2 = {
          next: function() {
            var value = items.shift();
            return {
              done: value === void 0,
              value
            };
          }
        };
        if (support.iterable) {
          iterator2[Symbol.iterator] = function() {
            return iterator2;
          };
        }
        return iterator2;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name2) {
            this.append(name2, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name2) {
            this.append(name2, headers[name2]);
          }, this);
        }
      }
      Headers.prototype.append = function(name2, value) {
        name2 = normalizeName(name2);
        value = normalizeValue(value);
        var oldValue = this.map[name2];
        this.map[name2] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name2) {
        delete this.map[normalizeName(name2)];
      };
      Headers.prototype.get = function(name2) {
        name2 = normalizeName(name2);
        return this.has(name2) ? this.map[name2] : null;
      };
      Headers.prototype.has = function(name2) {
        return this.map.hasOwnProperty(normalizeName(name2));
      };
      Headers.prototype.set = function(name2, value) {
        this.map[normalizeName(name2)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name2 in this.map) {
          if (this.map.hasOwnProperty(name2)) {
            callback.call(thisArg, this.map[name2], name2, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push(name2);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push([name2, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, {
          body: this._bodyInit
        });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes3) {
          if (bytes3) {
            var split2 = bytes3.split("=");
            var name2 = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name2), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key2 = parts.shift().trim();
          if (key2) {
            var value = parts.join(":").trim();
            headers.append(key2, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, {
          status: 0,
          statusText: ""
        });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, {
          status,
          headers: {
            location: url
          }
        });
      };
      exports3.DOMException = self2.DOMException;
      try {
        new exports3.DOMException();
      } catch (err) {
        exports3.DOMException = function(message, name2) {
          this.message = message;
          this.name = name2;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports3.DOMException.prototype = Object.create(Error.prototype);
        exports3.DOMException.prototype.constructor = exports3.DOMException;
      }
      function fetch2(input, init3) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init3);
          if (request.signal && request.signal.aborted) {
            return reject(new exports3.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports3.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name2) {
            xhr.setRequestHeader(name2, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports3.Headers = Headers;
      exports3.Request = Request;
      exports3.Response = Response;
      exports3.fetch = fetch2;
      Object.defineProperty(exports3, "__esModule", {
        value: true
      });
      return exports3;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports2 = ctx.fetch;
  exports2.default = ctx.fetch;
  exports2.fetch = ctx.fetch;
  exports2.Headers = ctx.Headers;
  exports2.Request = ctx.Request;
  exports2.Response = ctx.Response;
  module2.exports = exports2;
})(browserPonyfill, browserPonyfill.exports);
const fetch$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfill.exports);
const JSONStringify = (data) => JSON.stringify(data, (_2, value) => typeof value === "bigint" ? value.toString() + "n" : value);
const JSONParse = (json2) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json2.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_2, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse$1(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify$1(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}
const DEFAULT_HTTP_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json"
};
const DEFAULT_HTTP_METHOD = "POST";
const DEFAULT_FETCH_OPTS = {
  headers: DEFAULT_HTTP_HEADERS,
  method: DEFAULT_HTTP_METHOD
};
const EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
class HttpConnection {
  constructor(url, disableProviderPing = false) {
    this.url = url;
    this.disableProviderPing = disableProviderPing;
    this.events = new events.exports.EventEmitter();
    this.isAvailable = false;
    this.registering = false;
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    this.url = url;
    this.disableProviderPing = disableProviderPing;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    if (!this.isAvailable) {
      throw new Error("Connection already closed");
    }
    this.onClose();
  }
  async send(payload, context) {
    if (!this.isAvailable) {
      await this.register();
    }
    try {
      const body = safeJsonStringify$1(payload);
      const res = await fetch$1(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {
        body
      }));
      const data = await res.json();
      this.onPayload({
        data
      });
    } catch (e2) {
      this.onError(payload.id, e2);
    }
  }
  async register(url = this.url) {
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.isAvailable === "undefined") {
            return reject(new Error("HTTP connection is missing or invalid"));
          }
          resolve();
        });
      });
    }
    this.url = url;
    this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const body = safeJsonStringify$1({
          id: 1,
          jsonrpc: "2.0",
          method: "test",
          params: []
        });
        await fetch$1(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {
          body
        }));
      }
      this.onOpen();
    } catch (e2) {
      const error = this.parseError(e2);
      this.events.emit("register_error", error);
      this.onClose();
      throw error;
    }
  }
  onOpen() {
    this.isAvailable = true;
    this.registering = false;
    this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false;
    this.registering = false;
    this.events.emit("close");
  }
  onPayload(e2) {
    if (typeof e2.data === "undefined")
      return;
    const payload = typeof e2.data === "string" ? safeJsonParse$1(e2.data) : e2.data;
    this.events.emit("payload", payload);
  }
  onError(id2, e2) {
    const error = this.parseError(e2);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id2, message);
    this.events.emit("payload", payload);
  }
  parseError(e2, url = this.url) {
    return parseConnectionError(e2, url, "HTTP");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
}
const ERROR_SESSION_CONNECTED = "Session currently connected";
const ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
const ERROR_SESSION_REJECTED = "Session Rejected";
const ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
const ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
const ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
const ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
const ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
const ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
const ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
const ERROR_INVALID_URI = "URI format is invalid";
const ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
const ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
const RESERVED_EVENTS = ["session_request", "session_update", "exchange_key", "connect", "disconnect", "display_uri", "modal_closed", "transport_open", "transport_close", "transport_error"];
const WALLET_METHODS = ["wallet_addEthereumChain", "wallet_switchEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
const SIGNING_METHODS = ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "eth_signTypedData", "eth_signTypedData_v1", "eth_signTypedData_v2", "eth_signTypedData_v3", "eth_signTypedData_v4", "personal_sign", ...WALLET_METHODS];
const MOBILE_LINK_CHOICE_KEY = "WALLETCONNECT_DEEPLINK_CHOICE";
const INFURA_NETWORKS = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};
var isTypedarray = isTypedArray$3;
isTypedArray$3.strict = isStrictTypedArray;
isTypedArray$3.loose = isLooseTypedArray;
var toString = Object.prototype.toString;
var names$1 = {
  "[object Int8Array]": true,
  "[object Int16Array]": true,
  "[object Int32Array]": true,
  "[object Uint8Array]": true,
  "[object Uint8ClampedArray]": true,
  "[object Uint16Array]": true,
  "[object Uint32Array]": true,
  "[object Float32Array]": true,
  "[object Float64Array]": true
};
function isTypedArray$3(arr2) {
  return isStrictTypedArray(arr2) || isLooseTypedArray(arr2);
}
function isStrictTypedArray(arr2) {
  return arr2 instanceof Int8Array || arr2 instanceof Int16Array || arr2 instanceof Int32Array || arr2 instanceof Uint8Array || arr2 instanceof Uint8ClampedArray || arr2 instanceof Uint16Array || arr2 instanceof Uint32Array || arr2 instanceof Float32Array || arr2 instanceof Float64Array;
}
function isLooseTypedArray(arr2) {
  return names$1[toString.call(arr2)];
}
var isTypedArray$2 = isTypedarray.strict;
var typedarrayToBuffer = function typedarrayToBuffer2(arr2) {
  if (isTypedArray$2(arr2)) {
    var buf = Buffer.from(arr2.buffer);
    if (arr2.byteLength !== arr2.buffer.byteLength) {
      buf = buf.slice(arr2.byteOffset, arr2.byteOffset + arr2.byteLength);
    }
    return buf;
  } else {
    return Buffer.from(arr2);
  }
};
const ENC_HEX = "hex";
const ENC_UTF8 = "utf8";
const ENC_BIN = "binary";
const TYPE_BUFFER = "buffer";
const TYPE_ARRAY = "array";
const TYPE_TYPED_ARRAY = "typed-array";
const TYPE_ARRAY_BUFFER = "array-buffer";
const STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex$1(buf, prefixed = false) {
  const hex2 = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix$1(hex2) : hex2;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function bufferToNumber(buf) {
  return buf.readUIntBE(0, buf.length);
}
function arrayToBuffer(arr2) {
  return typedarrayToBuffer(arr2);
}
function arrayToHex(arr2, prefixed = false) {
  return bufferToHex$1(arrayToBuffer(arr2), prefixed);
}
function arrayToUtf8(arr2) {
  return bufferToUtf8(arrayToBuffer(arr2));
}
function arrayToNumber(arr2) {
  return bufferToNumber(arrayToBuffer(arr2));
}
function hexToBuffer(hex2) {
  return Buffer.from(removeHexPrefix$1(hex2), ENC_HEX);
}
function hexToArray(hex2) {
  return bufferToArray(hexToBuffer(hex2));
}
function hexToUtf8(hex2) {
  return bufferToUtf8(hexToBuffer(hex2));
}
function hexToNumber$1(hex2) {
  return arrayToNumber(hexToArray(hex2));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex$1(utf8ToBuffer(utf8), prefixed);
}
function utf8ToNumber(utf8) {
  const num = parseInt(utf8, 10);
  assert$c(isDefined(num), "Number can only safely store up to 53 bits");
  return num;
}
function numberToBuffer(num) {
  return binaryToBuffer(numberToBinary(num));
}
function numberToArray(num) {
  return binaryToArray(numberToBinary(num));
}
function numberToHex$1(num, prefixed) {
  return binaryToHex(numberToBinary(num), prefixed);
}
function numberToUtf8(num) {
  return `${num}`;
}
function numberToBinary(num) {
  const bin = (num >>> 0).toString(2);
  return sanitizeBytes(bin);
}
function binaryToBuffer(bin) {
  return arrayToBuffer(binaryToArray(bin));
}
function binaryToArray(bin) {
  return new Uint8Array(splitBytes(bin).map((x2) => parseInt(x2, 2)));
}
function binaryToHex(bin, prefixed) {
  return arrayToHex(binaryToArray(bin), prefixed);
}
function isBinaryString(str) {
  if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
    return false;
  }
  if (str.length % 8 !== 0) {
    return false;
  }
  return true;
}
function isHexString$4(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function isBuffer$2(val) {
  return Buffer.isBuffer(val);
}
function isTypedArray$1(val) {
  return isTypedarray.strict(val) && !isBuffer$2(val);
}
function isArrayBuffer$1(val) {
  return !isTypedArray$1(val) && !isBuffer$2(val) && typeof val.byteLength !== "undefined";
}
function getType$1(val) {
  if (isBuffer$2(val)) {
    return TYPE_BUFFER;
  } else if (isTypedArray$1(val)) {
    return TYPE_TYPED_ARRAY;
  } else if (isArrayBuffer$1(val)) {
    return TYPE_ARRAY_BUFFER;
  } else if (Array.isArray(val)) {
    return TYPE_ARRAY;
  } else {
    return typeof val;
  }
}
function getEncoding$1(str) {
  if (isBinaryString(str)) {
    return ENC_BIN;
  }
  if (isHexString$4(str)) {
    return ENC_HEX;
  }
  return ENC_UTF8;
}
function concatBuffers$1(...args) {
  const result = Buffer.concat(args);
  return result;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function splitBytes(str, byteSize = 8) {
  const bytes3 = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
  return Array.from(bytes3 || []);
}
function sanitizeBytes(str, byteSize = 8, padding2 = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding2);
}
function padLeft(str, length, padding2 = STRING_ZERO) {
  return padString(str, length, true, padding2);
}
function removeHexPrefix$1(hex2) {
  return hex2.replace(/^0x/, "");
}
function addHexPrefix$1(hex2) {
  return hex2.startsWith("0x") ? hex2 : `0x${hex2}`;
}
function sanitizeHex$1(hex2) {
  hex2 = removeHexPrefix$1(hex2);
  hex2 = sanitizeBytes(hex2, 2);
  if (hex2) {
    hex2 = addHexPrefix$1(hex2);
  }
  return hex2;
}
function removeHexLeadingZeros$1(hex2) {
  const prefixed = hex2.startsWith("0x");
  hex2 = removeHexPrefix$1(hex2);
  hex2 = hex2.startsWith(STRING_ZERO) ? hex2.substring(1) : hex2;
  return prefixed ? addHexPrefix$1(hex2) : hex2;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isDefined(value) {
  return !isUndefined(value);
}
function assert$c(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
function padString(str, length, left, padding2 = STRING_ZERO) {
  const diff2 = length - str.length;
  let result = str;
  if (diff2 > 0) {
    const pad2 = padding2.repeat(diff2);
    result = left ? pad2 + str : str + pad2;
  }
  return result;
}
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToUtf8(arrBuf) {
  return arrayToUtf8(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertArrayBufferToNumber(arrBuf) {
  return arrayToNumber(new Uint8Array(arrBuf));
}
function concatArrayBuffers(...args) {
  return hexToArray(args.map((b2) => arrayToHex(new Uint8Array(b2))).join("")).buffer;
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertBufferToUtf8(buf) {
  return bufferToUtf8(buf);
}
function convertBufferToHex(buf, noPrefix) {
  return bufferToHex$1(buf, !noPrefix);
}
function convertBufferToNumber(buf) {
  return bufferToNumber(buf);
}
function concatBuffers(...args) {
  return concatBuffers$1(...args);
}
function convertUtf8ToArrayBuffer(utf8) {
  return utf8ToArray(utf8).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertUtf8ToNumber(utf8) {
  return utf8ToNumber(utf8);
}
function convertHexToBuffer(hex2) {
  return hexToBuffer(hex2);
}
function convertHexToArrayBuffer(hex2) {
  return hexToArray(hex2).buffer;
}
function convertHexToUtf8(hex2) {
  return hexToUtf8(hex2);
}
function convertHexToNumber(hex2) {
  return hexToNumber$1(hex2);
}
function convertNumberToBuffer(num) {
  return numberToBuffer(num);
}
function convertNumberToArrayBuffer(num) {
  return numberToArray(num).buffer;
}
function convertNumberToUtf8(num) {
  return numberToUtf8(num);
}
function convertNumberToHex(num, noPrefix) {
  return numberToHex$1(Number(num), !noPrefix);
}
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = function() {
  function BrowserInfo2(name2, version2, os) {
    this.name = name2;
    this.version = version2;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name2, version2, os, bot) {
    this.name = name2;
    this.version = version2;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", SEARCHBOX_UA_REGEX]];
var operatingSystemRules = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex2 = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS$1(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version2, os);
}
function detectOS$1(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a2 = operatingSystemRules[ii], os = _a2[0], regex2 = _a2[1];
    var match = regex2.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii = 0; ii < count2; ii++) {
    output.push("0");
  }
  return output;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", {
  value: true
});
var getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorageOrThrow_1 = cjs$2.getLocalStorageOrThrow = getCrypto_1 = cjs$2.getCrypto = getCryptoOrThrow_1 = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = getLocationOrThrow_1 = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = getNavigatorOrThrow_1 = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = getDocumentOrThrow_1 = cjs$2.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$2.getFromWindowOrThrow = getFromWindow_1 = cjs$2.getFromWindow = void 0;
function getFromWindow$1(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
var getFromWindow_1 = cjs$2.getFromWindow = getFromWindow$1;
function getFromWindowOrThrow$1(name2) {
  const res = getFromWindow$1(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1 = cjs$2.getFromWindowOrThrow = getFromWindowOrThrow$1;
function getDocumentOrThrow$1() {
  return getFromWindowOrThrow$1("document");
}
var getDocumentOrThrow_1 = cjs$2.getDocumentOrThrow = getDocumentOrThrow$1;
function getDocument$1() {
  return getFromWindow$1("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument$1;
function getNavigatorOrThrow$1() {
  return getFromWindowOrThrow$1("navigator");
}
var getNavigatorOrThrow_1 = cjs$2.getNavigatorOrThrow = getNavigatorOrThrow$1;
function getNavigator$1() {
  return getFromWindow$1("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator$1;
function getLocationOrThrow$1() {
  return getFromWindowOrThrow$1("location");
}
var getLocationOrThrow_1 = cjs$2.getLocationOrThrow = getLocationOrThrow$1;
function getLocation$1() {
  return getFromWindow$1("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation$1;
function getCryptoOrThrow$1() {
  return getFromWindowOrThrow$1("crypto");
}
var getCryptoOrThrow_1 = cjs$2.getCryptoOrThrow = getCryptoOrThrow$1;
function getCrypto$1() {
  return getFromWindow$1("crypto");
}
var getCrypto_1 = cjs$2.getCrypto = getCrypto$1;
function getLocalStorageOrThrow$1() {
  return getFromWindowOrThrow$1("localStorage");
}
var getLocalStorageOrThrow_1 = cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow$1;
function getLocalStorage$1() {
  return getFromWindow$1("localStorage");
}
getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorage$1;
const getFromWindow = getFromWindow_1;
const getFromWindowOrThrow = getFromWindowOrThrow_1;
const getDocumentOrThrow = getDocumentOrThrow_1;
const getDocument = getDocument_1;
const getNavigatorOrThrow = getNavigatorOrThrow_1;
const getNavigator = getNavigator_1;
const getLocationOrThrow = getLocationOrThrow_1;
const getLocation = getLocation_1;
const getCryptoOrThrow = getCryptoOrThrow_1;
const getCrypto = getCrypto_1;
const getLocalStorageOrThrow = getLocalStorageOrThrow_1;
const getLocalStorage = getLocalStorage_1;
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS() {
  const env2 = detectEnv();
  return env2 && env2.os ? env2.os : void 0;
}
function isAndroid() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS();
  return os ? isAndroid() || isIOS() : false;
}
function isNode$1() {
  const env2 = detectEnv();
  const result = env2 && env2.name ? env2.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode$1() && !!getNavigator();
  return result;
}
const safeJsonParse = safeJsonParse$1;
const safeJsonStringify = safeJsonStringify$1;
function setLocal(key2, data) {
  const raw = safeJsonStringify(data);
  const local = getLocalStorage();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data = null;
  let raw = null;
  const local = getLocalStorage();
  if (local) {
    raw = local.getItem(key2);
  }
  data = raw ? safeJsonParse(raw) : raw;
  return data;
}
function removeLocal(key2) {
  const local = getLocalStorage();
  if (local) {
    local.removeItem(key2);
  }
}
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", {
  value: true
});
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i = 0; i < links.length; i++) {
      const link = links[i];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i = 0; i < metaTags.length; i++) {
      const tag = metaTags[i];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr2) => {
        if (attr2) {
          return args.includes(attr2);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content2 = tag.getAttribute("content");
        if (content2) {
          return content2;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc.title;
    }
    return name3;
  }
  function getDescription() {
    const description3 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description3;
  }
  const name2 = getName();
  const description2 = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description: description2,
    url,
    icons,
    name: name2
  };
  return meta;
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
function getClientMeta() {
  return getWindowMetadata_1();
}
function sanitizeHex(hex2) {
  return sanitizeHex$1(hex2);
}
function addHexPrefix(hex2) {
  return addHexPrefix$1(hex2);
}
function removeHexPrefix(hex2) {
  return removeHexPrefix$1(hex2);
}
function removeHexLeadingZeros(hex2) {
  return removeHexLeadingZeros$1(addHexPrefix$1(hex2));
}
const payloadId = payloadId$1;
function uuid() {
  const result = ((a2, b2) => {
    for (b2 = a2 = ""; a2++ < 36; b2 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}
function logDeprecationWarning() {
  console.warn("DEPRECATION WARNING: This WalletConnect client library will be deprecated in favor of @walletconnect/client. Please check docs.walletconnect.org to learn more about this migration!");
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = INFURA_NETWORKS[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(MOBILE_LINK_CHOICE_KEY, Object.assign(Object.assign({}, data), {
    href: focusUri
  }));
}
function getMobileRegistryEntry(registry, name2) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
  }
  return links;
}
function promisify(originalFn, thisArg) {
  const promisifiedFunction = async (...callArgs) => {
    return new Promise((resolve, reject) => {
      const callback = (err, data) => {
        if (err === null || typeof err === "undefined") {
          reject(err);
        }
        resolve(data);
      };
      originalFn.apply(thisArg, [...callArgs, callback]);
    });
  };
  return promisifiedFunction;
}
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code2 = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code2 = -32700;
        break;
      case "Invalid request":
        code2 = -32600;
        break;
      case "Method not found":
        code2 = -32601;
        break;
      case "Invalid params":
        code2 = -32602;
        break;
      case "Internal error":
        code2 = -32603;
        break;
      default:
        code2 = -32e3;
        break;
    }
  }
  const result = {
    code: code2,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}
const API_URL = "https://registry.walletconnect.com";
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a2;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a2 = entry.image_url.sm) !== null && _a2 !== void 0 ? _a2 : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split2) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split2 = split2 || 1;
  var left = components.slice(0, split2);
  var right = components.slice(split2);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode$3(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher) || [];
    for (var i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join("");
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "\uFFFD\uFFFD",
    "%FF%FE": "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode$3(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "\uFFFD";
  var entries = Object.keys(replaceMap);
  for (var i = 0; i < entries.length; i++) {
    var key2 = entries[i];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string2, separator) => {
  if (!(typeof string2 === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [string2.slice(0, separatorIndex), string2.slice(separatorIndex + separator.length)];
};
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i = 0; i < keys.length; i++) {
    var key2 = keys[i];
    var val = obj[key2];
    if (isArr ? predicate.indexOf(key2) !== -1 : predicate(key2, val, obj)) {
      ret[key2] = val;
    }
  }
  return ret;
};
(function(exports2) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const filterObject = filterObj;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode6(key2, options), "[", index2, "]"].join("")];
          }
          return [...result, [encode6(key2, options), "[", encode6(index2, options), "]=", encode6(value, options)].join("")];
        };
      case "bracket":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode6(key2, options), "[]"].join("")];
          }
          return [...result, [encode6(key2, options), "[]=", encode6(value, options)].join("")];
        };
      case "comma":
      case "separator":
        return (key2) => (result, value) => {
          if (value === null || value === void 0 || value.length === 0) {
            return result;
          }
          if (result.length === 0) {
            return [[encode6(key2, options), "=", encode6(value, options)].join("")];
          }
          return [[result, encode6(value, options)].join(options.arrayFormatSeparator)];
        };
      default:
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode6(key2, options)];
          }
          return [...result, [encode6(key2, options), "=", encode6(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value;
        };
      case "bracket":
        return (key2, value, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "comma":
      case "separator":
        return (key2, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key2] = newValue;
        };
      default:
        return (key2, value, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode6(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query2, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query2 !== "string") {
      return ret;
    }
    query2 = query2.trim().replace(/^[?#&]/, "");
    if (!query2) {
      return ret;
    }
    for (const param of query2.split("&")) {
      if (param === "") {
        continue;
      }
      let [key2, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key2, options), value, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value = ret[key2];
      if (typeof value === "object" && value !== null) {
        for (const k2 of Object.keys(value)) {
          value[k2] = parseValue(value[k2], options);
        }
      } else {
        ret[key2] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value = ret[key2];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key2] = keysSorter(value);
      } else {
        result[key2] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports2.extract = extract;
  exports2.parse = parse2;
  exports2.stringify = (object2, options) => {
    if (!object2) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object2[key2]) || options.skipEmptyString && object2[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object2)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object2[key2];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map((key2) => {
      const value = object2[key2];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode6(key2, options);
      }
      if (Array.isArray(value)) {
        return value.reduce(formatter(key2), []).join("&");
      }
      return encode6(key2, options) + "=" + encode6(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports2.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign({
      url: url_.split("?")[0] || "",
      query: parse2(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash2 ? {
      fragmentIdentifier: decode2(hash2, options)
    } : {});
  };
  exports2.stringifyUrl = (object2, options) => {
    options = Object.assign({
      encode: true,
      strict: true
    }, options);
    const url = removeHash(object2.url).split("?")[0] || "";
    const queryFromUrl = exports2.extract(object2.url);
    const parsedQueryFromUrl = exports2.parse(queryFromUrl, {
      sort: false
    });
    const query2 = Object.assign(parsedQueryFromUrl, object2.query);
    let queryString2 = exports2.stringify(query2, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object2.url);
    if (object2.fragmentIdentifier) {
      hash2 = `#${encode6(object2.fragmentIdentifier, options)}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports2.pick = (input, filter2, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true
    }, options);
    const {
      url,
      query: query2,
      fragmentIdentifier
    } = exports2.parseUrl(input, options);
    return exports2.stringifyUrl({
      url,
      query: filterObject(query2, filter2),
      fragmentIdentifier
    }, options);
  };
  exports2.exclude = (input, filter2, options) => {
    const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
    return exports2.pick(input, exclusionFilter, options);
  };
})(queryString);
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString2 = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString2;
}
function appendToQueryString(queryString2, newQueryParams) {
  let queryParams = parseQueryString(queryString2);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString2 = formatQueryString(queryParams);
  return queryString2;
}
function parseQueryString(queryString$1) {
  return queryString.parse(queryString$1);
}
function formatQueryString(queryParams) {
  return queryString.stringify(queryParams);
}
function isWalletConnectSession(object2) {
  return typeof object2.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString2 = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString3) {
    const result2 = parseQueryString(queryString3);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString2);
  const result = Object.assign(Object.assign({
    protocol
  }, requiredParams), queryParams);
  return result;
}
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array2) {
  return !(array2 && array2.length);
}
function isBuffer$1(val) {
  return isBuffer$2(val);
}
function isTypedArray(val) {
  return isTypedArray$1(val);
}
function isArrayBuffer(val) {
  return isArrayBuffer$1(val);
}
function getType(val) {
  return getType$1(val);
}
function getEncoding(val) {
  return getEncoding$1(val);
}
function isHexString$3(value, length) {
  return isHexString$4(value, length);
}
function isJsonRpcSubscription(object2) {
  return typeof object2.params === "object";
}
function isJsonRpcRequest(object2) {
  return typeof object2.method !== "undefined";
}
function isJsonRpcResponseSuccess(object2) {
  return typeof object2.result !== "undefined";
}
function isJsonRpcResponseError(object2) {
  return typeof object2.error !== "undefined";
}
function isInternalEvent(object2) {
  return typeof object2.event !== "undefined";
}
function isReservedEvent(event) {
  return RESERVED_EVENTS.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (SIGNING_METHODS.includes(request.method)) {
    return false;
  }
  return true;
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertArrayBufferToBuffer,
  convertArrayBufferToUtf8,
  convertArrayBufferToHex,
  convertArrayBufferToNumber,
  concatArrayBuffers,
  convertBufferToArrayBuffer,
  convertBufferToUtf8,
  convertBufferToHex,
  convertBufferToNumber,
  concatBuffers,
  convertUtf8ToArrayBuffer,
  convertUtf8ToBuffer,
  convertUtf8ToHex,
  convertUtf8ToNumber,
  convertHexToBuffer,
  convertHexToArrayBuffer,
  convertHexToUtf8,
  convertHexToNumber,
  convertNumberToBuffer,
  convertNumberToArrayBuffer,
  convertNumberToUtf8,
  convertNumberToHex,
  detectEnv,
  detectOS,
  isAndroid,
  isIOS,
  isMobile,
  isNode: isNode$1,
  isBrowser,
  safeJsonParse,
  safeJsonStringify,
  setLocal,
  getLocal,
  removeLocal,
  getClientMeta,
  sanitizeHex,
  addHexPrefix,
  removeHexPrefix,
  removeHexLeadingZeros,
  payloadId,
  uuid,
  logDeprecationWarning,
  getInfuraRpcUrl,
  getRpcUrl,
  formatIOSMobile,
  saveMobileLinkInfo,
  getMobileRegistryEntry,
  getMobileLinkRegistry,
  promisify,
  formatRpcError,
  getWalletRegistryUrl,
  getDappRegistryUrl,
  formatMobileRegistryEntry,
  formatMobileRegistry,
  isWalletConnectSession,
  parseWalletConnectUri,
  getQueryString,
  appendToQueryString,
  parseQueryString,
  formatQueryString,
  isEmptyString,
  isEmptyArray,
  isBuffer: isBuffer$1,
  isTypedArray,
  isArrayBuffer,
  getType,
  getEncoding,
  isHexString: isHexString$3,
  isJsonRpcSubscription,
  isJsonRpcRequest,
  isJsonRpcResponseSuccess,
  isJsonRpcResponseError,
  isInternalEvent,
  isReservedEvent,
  isSilentPayload,
  getFromWindow,
  getFromWindowOrThrow,
  getDocumentOrThrow,
  getDocument,
  getNavigatorOrThrow,
  getNavigator,
  getLocationOrThrow,
  getLocation,
  getCryptoOrThrow,
  getCrypto,
  getLocalStorageOrThrow,
  getLocalStorage
}, Symbol.toStringTag, { value: "Module" }));
class NetworkMonitor {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
}
const WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require("ws");
class SocketTransport {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new NetworkMonitor();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({
      event,
      callback
    });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events2 = this._events.filter((event2) => event2.event === "message");
      if (events2 && events2.length) {
        events2.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e2) {
    const events2 = this._events.filter((event) => event.event === "error");
    if (events2 && events2.length) {
      events2.forEach((event) => event.callback(e2));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue2 = this._queue;
    queue2.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
}
function getWebSocketUrl(_url, protocol, version2) {
  var _a2, _b2;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version2,
    env: "browser",
    host: ((_a2 = getLocation()) === null || _a2 === void 0 ? void 0 : _a2.host) || ""
  } : {
    protocol,
    version: version2,
    env: ((_b2 = detectEnv()) === null || _b2 === void 0 ? void 0 : _b2.name) || ""
  };
  const queryString2 = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString2;
}
class EventManager {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x2) => x2.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
}
class SessionStorage {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json2 = getLocal(this.storageId);
    if (json2 && isWalletConnectSession(json2)) {
      session = json2;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
}
const domain = "walletconnect.org";
const alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
const bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}
class Connector$1 {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new EventManager();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...SIGNING_METHODS, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new SocketTransport({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key2 = convertHexToArrayBuffer(value);
    this._key = key2;
  }
  get key() {
    if (this._key) {
      const key2 = convertArrayBufferToHex(this._key, true);
      return key2;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const {
      handshakeTopic,
      bridge,
      key: key2
    } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key2;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [{
        peerId: this.clientId,
        peerMeta: this.clientMeta,
        request: this._formatRequest(instantRequest)
      }]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [{
        peerId: this.clientId,
        peerMeta: this.clientMeta,
        chainId: opts && opts.chainId ? opts.chainId : null
      }]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [{
        peerId: this.peerId,
        peerMeta: this.peerMeta,
        chainId: this.chainId,
        accounts: this.accounts
      }]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: {
        message
      }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{
        message
      }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [{
        chainId: this.chainId,
        accounts: this.accounts
      }]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = tx;
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = tx;
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{
        request,
        options
      }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params)
          ;
        break;
      case "personal_sign":
        if (request.params)
          ;
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{
        request,
        options
      }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = {
      id: response.id,
      jsonrpc: "2.0"
    };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {
        error
      });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(MOBILE_LINK_CHOICE_KEY);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{
        message
      }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [{
              peerId: this.peerId,
              peerMeta: this.peerMeta,
              chainId: this.chainId,
              accounts: this.accounts
            }]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [{
              chainId: this.chainId,
              accounts: this.accounts
            }]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id2, callback) {
    this.on(`response:${id2}`, callback);
  }
  _subscribeToSessionResponse(id2, errorMsg) {
    this._subscribeToResponse(id2, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id2) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id2, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const {
        request
      } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(MOBILE_LINK_CHOICE_KEY);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [{
            code: "SESSION_REQUEST_ERROR",
            message: error.toString()
          }]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), {
        method: "session_request"
      });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({
      event: "transport_open",
      params: []
    }));
    this._transport.on("close", () => this._eventManager.trigger({
      event: "transport_close",
      params: []
    }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version2 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key2 = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version2}?bridge=${bridge}&key=${key2}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key2 = result.key;
      return {
        handshakeTopic,
        bridge,
        key: key2
      };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.encrypt(data, key2);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.decrypt(payload, key2);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json2 = await response.json();
        if (!json2.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
}
function randomBytes$1(length) {
  const browserCrypto = cjs$3.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}
const LENGTH_256 = 256;
const AES_LENGTH = LENGTH_256;
const HMAC_LENGTH = LENGTH_256;
const AES_BROWSER_ALGO = "AES-CBC";
const HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
const HMAC_BROWSER = "HMAC";
const ENCRYPT_OP = "encrypt";
const DECRYPT_OP = "decrypt";
const SIGN_OP = "sign";
const VERIFY_OP = "verify";
function getAlgo(type2) {
  return type2 === AES_BROWSER_ALGO ? {
    length: AES_LENGTH,
    name: AES_BROWSER_ALGO
  } : {
    hash: {
      name: HMAC_BROWSER_ALGO
    },
    name: HMAC_BROWSER
  };
}
function getOps(type2) {
  return type2 === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type2 = AES_BROWSER_ALGO) {
  return cjs$3.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type2), true, getOps(type2));
}
async function browserAesEncrypt(iv, key2, data) {
  const subtle = cjs$3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key2, data) {
  const subtle = cjs$3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key2, data) {
  const subtle = cjs$3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature2);
}
function aesCbcEncrypt(iv, key2, data) {
  return browserAesEncrypt(iv, key2, data);
}
function aesCbcDecrypt(iv, key2, data) {
  return browserAesDecrypt(iv, key2, data);
}
async function hmacSha256Sign(key2, msg) {
  const result = await browserHmacSha256Sign(key2, msg);
  return result;
}
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes3 = randomBytes$1(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes3));
  return result;
}
async function verifyHmac(payload, key2) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac3 = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac3, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key2, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix$1(hmacHex) === removeHexPrefix$1(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt$2(data, key2, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content2 = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content2);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac3 = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac3, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt$3(payload, key2) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer2);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}
const cryptoLib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generateKey,
  verifyHmac,
  encrypt: encrypt$2,
  decrypt: decrypt$3
}, Symbol.toStringTag, { value: "Module" }));
class WalletConnect extends Connector$1 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib,
      connectorOpts,
      pushServerOpts
    });
  }
}
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(esm);
var browser$2 = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var utils$g = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$g.getSymbolSize = function getSymbolSize2(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$g.getSymbolTotalCodewords = function getSymbolTotalCodewords2(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$g.getBCHDigit = function(data) {
  let digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
};
utils$g.setToSJISFunction = function setToSJISFunction2(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
utils$g.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$g.toSJIS = function toSJIS2(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports2) {
  exports2.L = {
    bit: 1
  };
  exports2.M = {
    bit: 0
  };
  exports2.Q = {
    bit: 3
  };
  exports2.H = {
    bit: 2
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports2.L;
      case "m":
      case "medium":
        return exports2.M;
      case "q":
      case "quartile":
        return exports2.Q;
      case "h":
      case "high":
        return exports2.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports2.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports2) {
  const getSymbolSize4 = utils$g.getSymbolSize;
  exports2.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize4(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i = 1; i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports2.getPositions = function getPositions3(version2) {
    const coords = [];
    const pos = exports2.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i = 0; i < posLength; i++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i === 0 && j2 === 0 || i === 0 && j2 === posLength - 1 || i === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
const getSymbolSize3 = utils$g.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions2(version2) {
  const size2 = getSymbolSize3(version2);
  return [
    [0, 0],
    [size2 - FINDER_PATTERN_SIZE, 0],
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports2) {
  exports2.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports2.isValid = function isValid3(mask2) {
    return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
  };
  exports2.from = function from2(value) {
    return exports2.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports2.getPenaltyN1 = function getPenaltyN1(data) {
    const size2 = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module2 = data.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports2.getPenaltyN2 = function getPenaltyN2(data) {
    const size2 = data.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last2 === 4 || last2 === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports2.getPenaltyN3 = function getPenaltyN3(data) {
    const size2 = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports2.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for (let i = 0; i < modulesCount; i++)
      darkCount += data.data[i];
    const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i, j2) {
    switch (maskPattern2) {
      case exports2.Patterns.PATTERN000:
        return (i + j2) % 2 === 0;
      case exports2.Patterns.PATTERN001:
        return i % 2 === 0;
      case exports2.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports2.Patterns.PATTERN011:
        return (i + j2) % 3 === 0;
      case exports2.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports2.Patterns.PATTERN101:
        return i * j2 % 2 + i * j2 % 3 === 0;
      case exports2.Patterns.PATTERN110:
        return (i * j2 % 2 + i * j2 % 3) % 2 === 0;
      case exports2.Patterns.PATTERN111:
        return (i * j2 % 3 + (i + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports2.applyMask = function applyMask(pattern2, data) {
    const size2 = data.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data.isReserved(row, col))
          continue;
        data.xor(row, col, getMaskAt(pattern2, row, col));
      }
    }
  };
  exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports2.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports2.applyMask(p2, data);
      const penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
      exports2.applyMask(p2, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel;
const EC_BLOCKS_TABLE = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount2(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount2(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables2() {
  let x2 = 1;
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x2;
    LOG_TABLE[x2] = i;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
})();
galoisField.log = function log2(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE[n2];
};
galoisField.exp = function exp2(n2) {
  return EXP_TABLE[n2];
};
galoisField.mul = function mul2(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
(function(exports2) {
  const GF = galoisField;
  exports2.mul = function mul5(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i = 0; i < p1.length; i++) {
      for (let j2 = 0; j2 < p2.length; j2++) {
        coeff[i + j2] ^= GF.mul(p1[i], p2[j2]);
      }
    }
    return coeff;
  };
  exports2.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i = 0; i < divisor.length; i++) {
        result[i] ^= GF.mul(divisor[i], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports2.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i = 0; i < degree; i++) {
      poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i)]));
    }
    return poly;
  };
})(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize2(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode2(data) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data.length + this.degree);
  paddedData.set(data);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version$o = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid2(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
const numeric$1 = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric$1, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric$1 + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji2(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric2(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric2(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports2) {
  const VersionCheck = versionCheck;
  const Regex = regex;
  exports2.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports2.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports2.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports2.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports2.MIXED = {
    bit: -1
  };
  exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports2.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports2.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports2.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports2.KANJI;
    else
      return exports2.BYTE;
  };
  exports2.toString = function toString2(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports2.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports2.NUMERIC;
      case "alphanumeric":
        return exports2.ALPHANUMERIC;
      case "kanji":
        return exports2.KANJI;
      case "byte":
        return exports2.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports2) {
  const Utils2 = utils$g;
  const ECCode2 = errorCorrectionCode;
  const ECLevel2 = errorCorrectionLevel;
  const Mode2 = mode;
  const VersionCheck = versionCheck;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data) {
      const reservedBits = getReservedBitsCount(data.mode, version2);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports2.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports2.getEncodedBits = function getEncodedBits3(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version$o);
var formatInfo = {};
const Utils$3 = utils$g;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits2(errorCorrectionLevel2, mask2) {
  const data = errorCorrectionLevel2.bit << 3 | mask2;
  let d2 = data << 10;
  while (Utils$3.getBCHDigit(d2) - G15_BCH >= 0) {
    d2 ^= G15 << Utils$3.getBCHDigit(d2) - G15_BCH;
  }
  return (data << 10 | d2) ^ G15_MASK;
};
var segments = {};
const Mode$4 = mode;
function NumericData(data) {
  this.mode = Mode$4.NUMERIC;
  this.data = data.toString();
}
NumericData.getBitsLength = function getBitsLength9(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength5() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength10() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write3(bitBuffer2) {
  let i, group, value;
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const Mode$3 = mode;
const ALPHA_NUM_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function AlphanumericData(data) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data;
}
AlphanumericData.getBitsLength = function getBitsLength11(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength6() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength12() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write4(bitBuffer2) {
  let i;
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};
var alphanumericData = AlphanumericData;
const encodeUtf82 = encodeUtf8$2;
const Mode$2 = mode;
function ByteData(data) {
  this.mode = Mode$2.BYTE;
  if (typeof data === "string") {
    data = encodeUtf82(data);
  }
  this.data = new Uint8Array(data);
}
ByteData.getBitsLength = function getBitsLength13(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength7() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength14() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i = 0, l2 = this.data.length; i < l2; i++) {
    bitBuffer2.put(this.data[i], 8);
  }
};
var byteData = ByteData;
const Mode$1 = mode;
const Utils$2 = utils$g;
function KanjiData(data) {
  this.mode = Mode$1.KANJI;
  this.data = data;
}
KanjiData.getBitsLength = function getBitsLength15(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength8() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength16() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i;
  for (i = 0; i < this.data.length; i++) {
    let value = Utils$2.toSJIS(this.data[i]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error("Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8");
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
(function(exports2) {
  const Mode2 = mode;
  const NumericData2 = numericData;
  const AlphanumericData2 = alphanumericData;
  const ByteData2 = byteData;
  const KanjiData2 = kanjiData;
  const Regex = regex;
  const Utils2 = utils$g;
  const dijkstra$1 = dijkstra.exports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i = 0; i < segs.length; i++) {
      const seg = segs[i];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([seg, {
            data: seg.data,
            mode: Mode2.ALPHANUMERIC,
            length: seg.length
          }, {
            data: seg.data,
            mode: Mode2.BYTE,
            length: seg.length
          }]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([seg, {
            data: seg.data,
            mode: Mode2.BYTE,
            length: seg.length
          }]);
          break;
        case Mode2.KANJI:
          nodes.push([seg, {
            data: seg.data,
            mode: Mode2.BYTE,
            length: getStringByteLength(seg.data)
          }]);
          break;
        case Mode2.BYTE:
          nodes.push([{
            data: seg.data,
            mode: Mode2.BYTE,
            length: getStringByteLength(seg.data)
          }]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = {
      start: {}
    };
    let prevNodeIds = ["start"];
    for (let i = 0; i < nodes.length; i++) {
      const nodeGroup = nodes[i];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node = nodeGroup[j2];
        const key2 = "" + i + j2;
        currentNodeIds.push(key2);
        table[key2] = {
          node,
          lastCount: 0
        };
        graph[key2] = {};
        for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
          const prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]].end = 0;
    }
    return {
      map: graph,
      table
    };
  }
  function buildSingleSegment(data, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data);
      case Mode2.KANJI:
        return new KanjiData2(data);
      case Mode2.BYTE:
        return new ByteData2(data);
    }
  }
  exports2.fromArray = function fromArray2(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports2.fromString = function fromString(data, version2) {
    const segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra$1.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i = 1; i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node);
    }
    return exports2.fromArray(mergeSegments(optimizedSegs));
  };
  exports2.rawSplit = function rawSplit(data) {
    return exports2.fromArray(getSegmentsFromString(data, Utils2.isKanjiModeEnabled()));
  };
})(segments);
const Utils$1 = utils$g;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version$o;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size;
  for (let r2 = 8; r2 < size2 - 8; r2++) {
    const value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod;
  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size2 - 8 - 3;
    mod = (bits >> i & 1) === 1;
    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i, mod;
  for (i = 0; i < 15; i++) {
    mod = (bits >> i & 1) === 1;
    if (i < 6) {
      matrix.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true);
    } else {
      matrix.set(size2 - 15 + i, 8, mod, true);
    }
    if (i < 8) {
      matrix.set(8, size2 - i - 1, mod, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i - 1, mod, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data) {
  const size2 = matrix.size;
  let inc2 = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc2;
      if (row < 0 || size2 <= row) {
        row -= inc2;
        inc2 = -inc2;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data) {
    buffer2.put(data.mode.bit, 4);
    buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
    data.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i = 0; i < remainingByte; i++) {
    buffer2.put(i % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
    const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset, offset + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i, r2;
  for (i = 0; i < maxDataSize; i++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i < dcData[r2].length) {
        data[index2++] = dcData[r2][i];
      }
    }
  }
  for (i = 0; i < ecCount; i++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data[index2++] = ecData[r2][i];
    }
  }
  return data;
}
function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data)) {
    segments2 = Segments.fromArray(data);
  } else if (typeof data === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel2));
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create2(data, options) {
  if (typeof data === "undefined" || data === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask2;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask2 = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data, version2, errorCorrectionLevel2, mask2);
};
var canvas = {};
var utils$f = {};
(function(exports2) {
  function hex2rgba(hex2) {
    if (typeof hex2 === "number") {
      hex2 = hex2.toString();
    }
    if (typeof hex2 !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex2.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex2);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue2 = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue2 >> 24 & 255,
      g: hexValue2 >> 16 & 255,
      b: hexValue2 >> 8 & 255,
      a: hexValue2 & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports2.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports2.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports2.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports2.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports2.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i = 0; i < symbolSize; i++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j2 >= scaledMargin && i < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i - scaledMargin) / scale);
          const jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$f);
(function(exports2) {
  const Utils2 = utils$f;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports2.render = function render3(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports2.render(qrData, canvas2, opts);
    const type2 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type2, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
const Utils = utils$f;
function getColorAttrib(color, attrib) {
  const alpha = color.a / 255;
  const str = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y2) {
  let str = cmd + x2;
  if (typeof y2 !== "undefined")
    str += " " + y2;
  return str;
}
function qrToPath(data, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size2);
    const row = Math.floor(i / size2);
    if (!col && !newRow)
      newRow = true;
    if (data[i]) {
      lineLength++;
      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data[i + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render2(qrData, options, cb) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
  if (typeof cb === "function") {
    cb(null, svgTag2);
  }
  return svgTag2;
};
const canPromise = canPromise$1;
const QRCode$4 = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text, opts, cb) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === "undefined") {
        cb = opts;
        opts = void 0;
      } else {
        cb = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data = QRCode$4.create(text, opts);
        resolve(renderFunc(data, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data = QRCode$4.create(text, opts);
    cb(null, renderFunc(data, canvas2, opts));
  } catch (e2) {
    cb(e2);
  }
}
browser$2.create = QRCode$4.create;
browser$2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser$2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser$2.toString = renderCanvas.bind(null, function(data, _2, opts) {
  return SvgRenderer.render(data, opts);
});
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active2 = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active2.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active2.blur();
      break;
    default:
      active2 = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range2) {
        selection.addRange(range2);
      });
    }
    active2 && active2.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$1(text, options) {
  var debug2, message, reselectPrevious, range2, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug2 = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range2 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug2 && console.warn("unable to use e.clipboardData");
          debug2 && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range2.selectNodeContents(mark);
    selection.addRange(range2);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug2 && console.error("unable to copy using execCommand: ", err);
    debug2 && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug2 && console.error("unable to copy using clipboardData: ", err2);
      debug2 && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range2);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy$1;
var n, l$1, u$1, t$3, i$2, o$1, r$3, f$2, e$1, c$1 = {}, s$2 = [], a$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, h$1 = Array.isArray;
function v$1(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function p$1(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function y$1(l2, u2, t2) {
  var i, o2, r2, f2 = {};
  for (r2 in u2)
    "key" == r2 ? i = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f2[r2] = u2[r2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps)
    for (r2 in l2.defaultProps)
      void 0 === f2[r2] && (f2[r2] = l2.defaultProps[r2]);
  return d$1(l2, f2, i, o2, null);
}
function d$1(n2, t2, i, o2, r2) {
  var f2 = {
    type: n2,
    props: t2,
    key: i,
    ref: o2,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    __h: null,
    constructor: void 0,
    __v: null == r2 ? ++u$1 : r2
  };
  return null == r2 && null != l$1.vnode && l$1.vnode(f2), f2;
}
function _$1() {
  return {
    current: null
  };
}
function k$2(n2) {
  return n2.children;
}
function b$1(n2, l2) {
  this.props = n2, this.context = l2;
}
function g$2(n2, l2) {
  if (null == l2)
    return n2.__ ? g$2(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if (null != (u2 = n2.__k[l2]) && null != u2.__e)
      return u2.__e;
  return "function" == typeof n2.type ? g$2(n2) : null;
}
function m$1(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return m$1(n2);
  }
}
function w$2(n2) {
  (!n2.__d && (n2.__d = true) && i$2.push(n2) && !x$2.__r++ || o$1 !== l$1.debounceRendering) && ((o$1 = l$1.debounceRendering) || r$3)(x$2);
}
function x$2() {
  var n2, l2, u2, t2, o2, r2, e2, c2, s2;
  for (i$2.sort(f$2); n2 = i$2.shift(); )
    n2.__d && (l2 = i$2.length, t2 = void 0, o2 = void 0, r2 = void 0, c2 = (e2 = (u2 = n2).__v).__e, (s2 = u2.__P) && (t2 = [], o2 = [], (r2 = v$1({}, e2)).__v = e2.__v + 1, L$1(s2, e2, r2, u2.__n, void 0 !== s2.ownerSVGElement, null != e2.__h ? [c2] : null, t2, null == c2 ? g$2(e2) : c2, e2.__h, o2), M$1(t2, e2, o2), e2.__e != c2 && m$1(e2)), i$2.length > l2 && i$2.sort(f$2));
  x$2.__r = 0;
}
function P$2(n2, l2, u2, t2, i, o2, r2, f2, e2, a2, v2) {
  var p2, y2, _2, b2, g2, m2, w2, x2, P2, S2, H2 = 0, I2 = t2 && t2.__k || s$2, T2 = I2.length, j2 = T2, z2 = l2.length;
  for (u2.__k = [], p2 = 0; p2 < z2; p2++)
    null != (b2 = u2.__k[p2] = null == (b2 = l2[p2]) || "boolean" == typeof b2 || "function" == typeof b2 ? null : "string" == typeof b2 || "number" == typeof b2 || "bigint" == typeof b2 ? d$1(null, b2, null, null, b2) : h$1(b2) ? d$1(k$2, {
      children: b2
    }, null, null, null) : b2.__b > 0 ? d$1(b2.type, b2.props, b2.key, b2.ref ? b2.ref : null, b2.__v) : b2) && (b2.__ = u2, b2.__b = u2.__b + 1, -1 === (x2 = A$2(b2, I2, w2 = p2 + H2, j2)) ? _2 = c$1 : (_2 = I2[x2] || c$1, I2[x2] = void 0, j2--), L$1(n2, b2, _2, i, o2, r2, f2, e2, a2, v2), g2 = b2.__e, (y2 = b2.ref) && _2.ref != y2 && (_2.ref && O$1(_2.ref, null, b2), v2.push(y2, b2.__c || g2, b2)), null != g2 && (null == m2 && (m2 = g2), S2 = !(P2 = _2 === c$1 || null === _2.__v) && x2 === w2, P2 ? -1 == x2 && H2-- : x2 !== w2 && (x2 === w2 + 1 ? (H2++, S2 = true) : x2 > w2 ? j2 > z2 - w2 ? (H2 += x2 - w2, S2 = true) : H2-- : H2 = x2 < w2 && x2 == w2 - 1 ? x2 - w2 : 0), w2 = p2 + H2, S2 = S2 || x2 == p2 && !P2, "function" != typeof b2.type || x2 === w2 && _2.__k !== b2.__k ? "function" == typeof b2.type || S2 ? void 0 !== b2.__d ? (e2 = b2.__d, b2.__d = void 0) : e2 = g2.nextSibling : e2 = $$1(n2, g2, e2) : e2 = C$1(b2, e2, n2), "function" == typeof u2.type && (u2.__d = e2)));
  for (u2.__e = m2, p2 = T2; p2--; )
    null != I2[p2] && ("function" == typeof u2.type && null != I2[p2].__e && I2[p2].__e == u2.__d && (u2.__d = I2[p2].__e.nextSibling), q$2(I2[p2], I2[p2]));
}
function C$1(n2, l2, u2) {
  for (var t2, i = n2.__k, o2 = 0; i && o2 < i.length; o2++)
    (t2 = i[o2]) && (t2.__ = n2, l2 = "function" == typeof t2.type ? C$1(t2, l2, u2) : $$1(u2, t2.__e, l2));
  return l2;
}
function S(n2, l2) {
  return l2 = l2 || [], null == n2 || "boolean" == typeof n2 || (h$1(n2) ? n2.some(function(n3) {
    S(n3, l2);
  }) : l2.push(n2)), l2;
}
function $$1(n2, l2, u2) {
  return null == u2 || u2.parentNode !== n2 ? n2.insertBefore(l2, null) : l2 == u2 && null != l2.parentNode || n2.insertBefore(l2, u2), l2.nextSibling;
}
function A$2(n2, l2, u2, t2) {
  var i = n2.key, o2 = n2.type, r2 = u2 - 1, f2 = u2 + 1, e2 = l2[u2];
  if (null === e2 || e2 && i == e2.key && o2 === e2.type)
    return u2;
  if (t2 > (null != e2 ? 1 : 0))
    for (; r2 >= 0 || f2 < l2.length; ) {
      if (r2 >= 0) {
        if ((e2 = l2[r2]) && i == e2.key && o2 === e2.type)
          return r2;
        r2--;
      }
      if (f2 < l2.length) {
        if ((e2 = l2[f2]) && i == e2.key && o2 === e2.type)
          return f2;
        f2++;
      }
    }
  return -1;
}
function H$1(n2, l2, u2, t2, i) {
  var o2;
  for (o2 in u2)
    "children" === o2 || "key" === o2 || o2 in l2 || T$2(n2, o2, null, u2[o2], t2);
  for (o2 in l2)
    i && "function" != typeof l2[o2] || "children" === o2 || "key" === o2 || "value" === o2 || "checked" === o2 || u2[o2] === l2[o2] || T$2(n2, o2, l2[o2], u2[o2], t2);
}
function I$1(n2, l2, u2) {
  "-" === l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || a$1.test(l2) ? u2 : u2 + "px";
}
function T$2(n2, l2, u2, t2, i) {
  var o2;
  n:
    if ("style" === l2) {
      if ("string" == typeof u2)
        n2.style.cssText = u2;
      else {
        if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2)
          for (l2 in t2)
            u2 && l2 in u2 || I$1(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            t2 && u2[l2] === t2[l2] || I$1(n2.style, l2, u2[l2]);
      }
    } else if ("o" === l2[0] && "n" === l2[1])
      o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), l2 = l2.toLowerCase() in n2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t2 || n2.addEventListener(l2, o2 ? z$2 : j$2, o2) : n2.removeEventListener(l2, o2 ? z$2 : j$2, o2);
    else if ("dangerouslySetInnerHTML" !== l2) {
      if (i)
        l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l2 && "height" !== l2 && "href" !== l2 && "list" !== l2 && "form" !== l2 && "tabIndex" !== l2 && "download" !== l2 && "rowSpan" !== l2 && "colSpan" !== l2 && l2 in n2)
        try {
          n2[l2] = null == u2 ? "" : u2;
          break n;
        } catch (n3) {
        }
      "function" == typeof u2 || (null == u2 || false === u2 && "-" !== l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
    }
}
function j$2(n2) {
  return this.l[n2.type + false](l$1.event ? l$1.event(n2) : n2);
}
function z$2(n2) {
  return this.l[n2.type + true](l$1.event ? l$1.event(n2) : n2);
}
function L$1(n2, u2, t2, i, o2, r2, f2, e2, c2, s2) {
  var a2, p2, y2, d2, _2, g2, m2, w2, x2, C2, S2, $2, A2, H2, I2, T2 = u2.type;
  if (void 0 !== u2.constructor)
    return null;
  null != t2.__h && (c2 = t2.__h, e2 = u2.__e = t2.__e, u2.__h = null, r2 = [e2]), (a2 = l$1.__b) && a2(u2);
  try {
    n:
      if ("function" == typeof T2) {
        if (w2 = u2.props, x2 = (a2 = T2.contextType) && i[a2.__c], C2 = a2 ? x2 ? x2.props.value : a2.__ : i, t2.__c ? m2 = (p2 = u2.__c = t2.__c).__ = p2.__E : ("prototype" in T2 && T2.prototype.render ? u2.__c = p2 = new T2(w2, C2) : (u2.__c = p2 = new b$1(w2, C2), p2.constructor = T2, p2.render = B$2), x2 && x2.sub(p2), p2.props = w2, p2.state || (p2.state = {}), p2.context = C2, p2.__n = i, y2 = p2.__d = true, p2.__h = [], p2._sb = []), null == p2.__s && (p2.__s = p2.state), null != T2.getDerivedStateFromProps && (p2.__s == p2.state && (p2.__s = v$1({}, p2.__s)), v$1(p2.__s, T2.getDerivedStateFromProps(w2, p2.__s))), d2 = p2.props, _2 = p2.state, p2.__v = u2, y2)
          null == T2.getDerivedStateFromProps && null != p2.componentWillMount && p2.componentWillMount(), null != p2.componentDidMount && p2.__h.push(p2.componentDidMount);
        else {
          if (null == T2.getDerivedStateFromProps && w2 !== d2 && null != p2.componentWillReceiveProps && p2.componentWillReceiveProps(w2, C2), !p2.__e && (null != p2.shouldComponentUpdate && false === p2.shouldComponentUpdate(w2, p2.__s, C2) || u2.__v === t2.__v)) {
            for (u2.__v !== t2.__v && (p2.props = w2, p2.state = p2.__s, p2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.forEach(function(n3) {
              n3 && (n3.__ = u2);
            }), S2 = 0; S2 < p2._sb.length; S2++)
              p2.__h.push(p2._sb[S2]);
            p2._sb = [], p2.__h.length && f2.push(p2);
            break n;
          }
          null != p2.componentWillUpdate && p2.componentWillUpdate(w2, p2.__s, C2), null != p2.componentDidUpdate && p2.__h.push(function() {
            p2.componentDidUpdate(d2, _2, g2);
          });
        }
        if (p2.context = C2, p2.props = w2, p2.__P = n2, p2.__e = false, $2 = l$1.__r, A2 = 0, "prototype" in T2 && T2.prototype.render) {
          for (p2.state = p2.__s, p2.__d = false, $2 && $2(u2), a2 = p2.render(p2.props, p2.state, p2.context), H2 = 0; H2 < p2._sb.length; H2++)
            p2.__h.push(p2._sb[H2]);
          p2._sb = [];
        } else
          do {
            p2.__d = false, $2 && $2(u2), a2 = p2.render(p2.props, p2.state, p2.context), p2.state = p2.__s;
          } while (p2.__d && ++A2 < 25);
        p2.state = p2.__s, null != p2.getChildContext && (i = v$1(v$1({}, i), p2.getChildContext())), y2 || null == p2.getSnapshotBeforeUpdate || (g2 = p2.getSnapshotBeforeUpdate(d2, _2)), P$2(n2, h$1(I2 = null != a2 && a2.type === k$2 && null == a2.key ? a2.props.children : a2) ? I2 : [I2], u2, t2, i, o2, r2, f2, e2, c2, s2), p2.base = u2.__e, u2.__h = null, p2.__h.length && f2.push(p2), m2 && (p2.__E = p2.__ = null);
      } else
        null == r2 && u2.__v === t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : u2.__e = N$2(t2.__e, u2, t2, i, o2, r2, f2, c2, s2);
    (a2 = l$1.diffed) && a2(u2);
  } catch (n3) {
    u2.__v = null, (c2 || null != r2) && (u2.__e = e2, u2.__h = !!c2, r2[r2.indexOf(e2)] = null), l$1.__e(n3, u2, t2);
  }
}
function M$1(n2, u2, t2) {
  for (var i = 0; i < t2.length; i++)
    O$1(t2[i], t2[++i], t2[++i]);
  l$1.__c && l$1.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$1.__e(n3, u3.__v);
    }
  });
}
function N$2(l2, u2, t2, i, o2, r2, f2, e2, s2) {
  var a2, v2, y2, d2 = t2.props, _2 = u2.props, k2 = u2.type, b2 = 0;
  if ("svg" === k2 && (o2 = true), null != r2) {
    for (; b2 < r2.length; b2++)
      if ((a2 = r2[b2]) && "setAttribute" in a2 == !!k2 && (k2 ? a2.localName === k2 : 3 === a2.nodeType)) {
        l2 = a2, r2[b2] = null;
        break;
      }
  }
  if (null == l2) {
    if (null === k2)
      return document.createTextNode(_2);
    l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", k2) : document.createElement(k2, _2.is && _2), r2 = null, e2 = false;
  }
  if (null === k2)
    d2 === _2 || e2 && l2.data === _2 || (l2.data = _2);
  else {
    if (r2 = r2 && n.call(l2.childNodes), v2 = (d2 = t2.props || c$1).dangerouslySetInnerHTML, y2 = _2.dangerouslySetInnerHTML, !e2) {
      if (null != r2)
        for (d2 = {}, b2 = 0; b2 < l2.attributes.length; b2++)
          d2[l2.attributes[b2].name] = l2.attributes[b2].value;
      (y2 || v2) && (y2 && (v2 && y2.__html == v2.__html || y2.__html === l2.innerHTML) || (l2.innerHTML = y2 && y2.__html || ""));
    }
    if (H$1(l2, _2, d2, o2, e2), y2)
      u2.__k = [];
    else if (P$2(l2, h$1(b2 = u2.props.children) ? b2 : [b2], u2, t2, i, o2 && "foreignObject" !== k2, r2, f2, r2 ? r2[0] : t2.__k && g$2(t2, 0), e2, s2), null != r2)
      for (b2 = r2.length; b2--; )
        null != r2[b2] && p$1(r2[b2]);
    e2 || ("value" in _2 && void 0 !== (b2 = _2.value) && (b2 !== l2.value || "progress" === k2 && !b2 || "option" === k2 && b2 !== d2.value) && T$2(l2, "value", b2, d2.value, false), "checked" in _2 && void 0 !== (b2 = _2.checked) && b2 !== l2.checked && T$2(l2, "checked", b2, d2.checked, false));
  }
  return l2;
}
function O$1(n2, u2, t2) {
  try {
    "function" == typeof n2 ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l$1.__e(n3, t2);
  }
}
function q$2(n2, u2, t2) {
  var i, o2;
  if (l$1.unmount && l$1.unmount(n2), (i = n2.ref) && (i.current && i.current !== n2.__e || O$1(i, null, u2)), null != (i = n2.__c)) {
    if (i.componentWillUnmount)
      try {
        i.componentWillUnmount();
      } catch (n3) {
        l$1.__e(n3, u2);
      }
    i.base = i.__P = null, n2.__c = void 0;
  }
  if (i = n2.__k)
    for (o2 = 0; o2 < i.length; o2++)
      i[o2] && q$2(i[o2], u2, t2 || "function" != typeof n2.type);
  t2 || null == n2.__e || p$1(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function B$2(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function D$1(u2, t2, i) {
  var o2, r2, f2, e2;
  l$1.__ && l$1.__(u2, t2), r2 = (o2 = "function" == typeof i) ? null : i && i.__k || t2.__k, f2 = [], e2 = [], L$1(t2, u2 = (!o2 && i || t2).__k = y$1(k$2, null, [u2]), r2 || c$1, c$1, void 0 !== t2.ownerSVGElement, !o2 && i ? [i] : r2 ? null : t2.firstChild ? n.call(t2.childNodes) : null, f2, !o2 && i ? i : r2 ? r2.__e : t2.firstChild, o2, e2), M$1(f2, u2, e2);
}
function E$1(n2, l2) {
  D$1(n2, l2, E$1);
}
function F$2(l2, u2, t2) {
  var i, o2, r2, f2, e2 = v$1({}, l2.props);
  for (r2 in l2.type && l2.type.defaultProps && (f2 = l2.type.defaultProps), u2)
    "key" == r2 ? i = u2[r2] : "ref" == r2 ? o2 = u2[r2] : e2[r2] = void 0 === u2[r2] && void 0 !== f2 ? f2[r2] : u2[r2];
  return arguments.length > 2 && (e2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), d$1(l2.type, e2, i || l2.key, o2 || l2.ref, null);
}
function G$1(n2, l2) {
  var u2 = {
    __c: l2 = "__cC" + e$1++,
    __: n2,
    Consumer: function(n3, l3) {
      return n3.children(l3);
    },
    Provider: function(n3) {
      var u3, t2;
      return this.getChildContext || (u3 = [], (t2 = {})[l2] = this, this.getChildContext = function() {
        return t2;
      }, this.shouldComponentUpdate = function(n4) {
        this.props.value !== n4.value && u3.some(function(n5) {
          n5.__e = true, w$2(n5);
        });
      }, this.sub = function(n4) {
        u3.push(n4);
        var l3 = n4.componentWillUnmount;
        n4.componentWillUnmount = function() {
          u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
        };
      }), n3.children;
    }
  };
  return u2.Provider.__ = u2.Consumer.contextType = u2;
}
n = s$2.slice, l$1 = {
  __e: function(n2, l2, u2, t2) {
    for (var i, o2, r2; l2 = l2.__; )
      if ((i = l2.__c) && !i.__)
        try {
          if ((o2 = i.constructor) && null != o2.getDerivedStateFromError && (i.setState(o2.getDerivedStateFromError(n2)), r2 = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n2, t2 || {}), r2 = i.__d), r2)
            return i.__E = i;
        } catch (l3) {
          n2 = l3;
        }
    throw n2;
  }
}, u$1 = 0, t$3 = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, b$1.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$1({}, this.state), "function" == typeof n2 && (n2 = n2(v$1({}, u2), this.props)), n2 && v$1(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), w$2(this));
}, b$1.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), w$2(this));
}, b$1.prototype.render = k$2, i$2 = [], r$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$2 = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, x$2.__r = 0, e$1 = 0;
const preact_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Component: b$1,
  Fragment: k$2,
  cloneElement: F$2,
  createContext: G$1,
  createElement: y$1,
  createRef: _$1,
  h: y$1,
  hydrate: E$1,
  get isValidElement() {
    return t$3;
  },
  get options() {
    return l$1;
  },
  render: D$1,
  toChildArray: S
}, Symbol.toStringTag, { value: "Module" }));
var t$2, r$2, u, i$1, o = 0, f$1 = [], c = [], e = l$1.__b, a = l$1.__r, v = l$1.diffed, l = l$1.__c, m = l$1.unmount;
function d(t2, u2) {
  l$1.__h && l$1.__h(r$2, t2, o || u2), o = 0;
  var i = r$2.__H || (r$2.__H = {
    __: [],
    __h: []
  });
  return t2 >= i.__.length && i.__.push({
    __V: c
  }), i.__[t2];
}
function h(n2) {
  return o = 1, s$1(B$1, n2);
}
function s$1(n2, u2, i) {
  var o2 = d(t$2++, 2);
  if (o2.t = n2, !o2.__c && (o2.__ = [i ? i(u2) : B$1(void 0, u2), function(n3) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n3);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r$2, !r$2.u)) {
    var f2 = function(n3, t2, r2) {
      if (!o2.__c.__H)
        return true;
      var u3 = o2.__c.__H.__.filter(function(n4) {
        return n4.__c;
      });
      if (u3.every(function(n4) {
        return !n4.__N;
      }))
        return !c2 || c2.call(this, n3, t2, r2);
      var i2 = false;
      return u3.forEach(function(n4) {
        if (n4.__N) {
          var t3 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i2 = true);
        }
      }), !(!i2 && o2.__c.props === n3) && (!c2 || c2.call(this, n3, t2, r2));
    };
    r$2.u = true;
    var c2 = r$2.shouldComponentUpdate, e2 = r$2.componentWillUpdate;
    r$2.componentWillUpdate = function(n3, t2, r2) {
      if (this.__e) {
        var u3 = c2;
        c2 = void 0, f2(n3, t2, r2), c2 = u3;
      }
      e2 && e2.call(this, n3, t2, r2);
    }, r$2.shouldComponentUpdate = f2;
  }
  return o2.__N || o2.__;
}
function p(u2, i) {
  var o2 = d(t$2++, 3);
  !l$1.__s && z$1(o2.__H, i) && (o2.__ = u2, o2.i = i, r$2.__H.__h.push(o2));
}
function y(u2, i) {
  var o2 = d(t$2++, 4);
  !l$1.__s && z$1(o2.__H, i) && (o2.__ = u2, o2.i = i, r$2.__h.push(o2));
}
function _(n2) {
  return o = 5, F$1(function() {
    return {
      current: n2
    };
  }, []);
}
function A$1(n2, t2, r2) {
  o = 6, y(function() {
    return "function" == typeof n2 ? (n2(t2()), function() {
      return n2(null);
    }) : n2 ? (n2.current = t2(), function() {
      return n2.current = null;
    }) : void 0;
  }, null == r2 ? r2 : r2.concat(n2));
}
function F$1(n2, r2) {
  var u2 = d(t$2++, 7);
  return z$1(u2.__H, r2) ? (u2.__V = n2(), u2.i = r2, u2.__h = n2, u2.__V) : u2.__;
}
function T$1(n2, t2) {
  return o = 8, F$1(function() {
    return n2;
  }, t2);
}
function q$1(n2) {
  var u2 = r$2.context[n2.__c], i = d(t$2++, 9);
  return i.c = n2, u2 ? (null == i.__ && (i.__ = true, u2.sub(r$2)), u2.props.value) : n2.__;
}
function x$1(t2, r2) {
  l$1.useDebugValue && l$1.useDebugValue(r2 ? r2(t2) : t2);
}
function P$1(n2) {
  var u2 = d(t$2++, 10), i = h();
  return u2.__ = n2, r$2.componentDidCatch || (r$2.componentDidCatch = function(n3, t2) {
    u2.__ && u2.__(n3, t2), i[1](n3);
  }), [i[0], function() {
    i[1](void 0);
  }];
}
function V$1() {
  var n2 = d(t$2++, 11);
  if (!n2.__) {
    for (var u2 = r$2.__v; null !== u2 && !u2.__m && null !== u2.__; )
      u2 = u2.__;
    var i = u2.__m || (u2.__m = [0, 0]);
    n2.__ = "P" + i[0] + "-" + i[1]++;
  }
  return n2.__;
}
function b() {
  for (var t2; t2 = f$1.shift(); )
    if (t2.__P && t2.__H)
      try {
        t2.__H.__h.forEach(k$1), t2.__H.__h.forEach(w$1), t2.__H.__h = [];
      } catch (r2) {
        t2.__H.__h = [], l$1.__e(r2, t2.__v);
      }
}
l$1.__b = function(n2) {
  r$2 = null, e && e(n2);
}, l$1.__r = function(n2) {
  a && a(n2), t$2 = 0;
  var i = (r$2 = n2.__c).__H;
  i && (u === r$2 ? (i.__h = [], r$2.__h = [], i.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c, n3.__N = n3.i = void 0;
  })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [], t$2 = 0)), u = r$2;
}, l$1.diffed = function(t2) {
  v && v(t2);
  var o2 = t2.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f$1.push(o2) && i$1 === l$1.requestAnimationFrame || ((i$1 = l$1.requestAnimationFrame) || j$1)(b)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c;
  })), u = r$2 = null;
}, l$1.__c = function(t2, r2) {
  r2.some(function(t3) {
    try {
      t3.__h.forEach(k$1), t3.__h = t3.__h.filter(function(n2) {
        return !n2.__ || w$1(n2);
      });
    } catch (u2) {
      r2.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r2 = [], l$1.__e(u2, t3.__v);
    }
  }), l && l(t2, r2);
}, l$1.unmount = function(t2) {
  m && m(t2);
  var r2, u2 = t2.__c;
  u2 && u2.__H && (u2.__H.__.forEach(function(n2) {
    try {
      k$1(n2);
    } catch (n3) {
      r2 = n3;
    }
  }), u2.__H = void 0, r2 && l$1.__e(r2, u2.__v));
};
var g$1 = "function" == typeof requestAnimationFrame;
function j$1(n2) {
  var t2, r2 = function() {
    clearTimeout(u2), g$1 && cancelAnimationFrame(t2), setTimeout(n2);
  }, u2 = setTimeout(r2, 100);
  g$1 && (t2 = requestAnimationFrame(r2));
}
function k$1(n2) {
  var t2 = r$2, u2 = n2.__c;
  "function" == typeof u2 && (n2.__c = void 0, u2()), r$2 = t2;
}
function w$1(n2) {
  var t2 = r$2;
  n2.__c = n2.__(), r$2 = t2;
}
function z$1(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n2[r2];
  });
}
function B$1(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
const hooks_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useCallback: T$1,
  useContext: q$1,
  useDebugValue: x$1,
  useEffect: p,
  useErrorBoundary: P$1,
  useId: V$1,
  useImperativeHandle: A$1,
  useLayoutEffect: y,
  useMemo: F$1,
  useReducer: s$1,
  useRef: _,
  useState: h
}, Symbol.toStringTag, { value: "Module" }));
function g(n2, t2) {
  for (var e2 in t2)
    n2[e2] = t2[e2];
  return n2;
}
function C(n2, t2) {
  for (var e2 in n2)
    if ("__source" !== e2 && !(e2 in t2))
      return true;
  for (var r2 in t2)
    if ("__source" !== r2 && n2[r2] !== t2[r2])
      return true;
  return false;
}
function E(n2, t2) {
  return n2 === t2 && (0 !== n2 || 1 / n2 == 1 / t2) || n2 != n2 && t2 != t2;
}
function w(n2) {
  this.props = n2;
}
function x(n2, e2) {
  function r2(n3) {
    var t2 = this.props.ref, r3 = t2 == n3.ref;
    return !r3 && t2 && (t2.call ? t2(null) : t2.current = null), e2 ? !e2(this.props, n3) || !r3 : C(this.props, n3);
  }
  function u2(e3) {
    return this.shouldComponentUpdate = r2, y$1(n2, e3);
  }
  return u2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u2.prototype.isReactComponent = true, u2.__f = true, u2;
}
(w.prototype = new b$1()).isPureReactComponent = true, w.prototype.shouldComponentUpdate = function(n2, t2) {
  return C(this.props, n2) || C(this.state, t2);
};
var R = l$1.__b;
l$1.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), R && R(n2);
};
var N$1 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function k(n2) {
  function t2(t3) {
    var e2 = g({}, t3);
    return delete e2.ref, n2(e2, t3.ref || null);
  }
  return t2.$$typeof = N$1, t2.render = t2, t2.prototype.isReactComponent = t2.__f = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
var A = function(n2, t2) {
  return null == n2 ? null : S(S(n2).map(t2));
}, O = {
  map: A,
  forEach: A,
  count: function(n2) {
    return n2 ? S(n2).length : 0;
  },
  only: function(n2) {
    var t2 = S(n2);
    if (1 !== t2.length)
      throw "Children.only";
    return t2[0];
  },
  toArray: S
}, T = l$1.__e;
l$1.__e = function(n2, t2, e2, r2) {
  if (n2.then) {
    for (var u2, o2 = t2; o2 = o2.__; )
      if ((u2 = o2.__c) && u2.__c)
        return null == t2.__e && (t2.__e = e2.__e, t2.__k = e2.__k), u2.__c(n2, t2);
  }
  T(n2, t2, e2, r2);
};
var I = l$1.unmount;
function L(n2, t2, e2) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g({}, n2)).__c && (n2.__c.__P === e2 && (n2.__c.__P = t2), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L(n3, t2, e2);
  })), n2;
}
function U(n2, t2, e2) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t2, e2);
  }), n2.__c && n2.__c.__P === t2 && (n2.__e && e2.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e2)), n2;
}
function D() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.__a && t2.__a(n2);
}
function M(n2) {
  var e2, r2, u2;
  function o2(o3) {
    if (e2 || (e2 = n2()).then(function(n3) {
      r2 = n3.default || n3;
    }, function(n3) {
      u2 = n3;
    }), u2)
      throw u2;
    if (!r2)
      throw e2;
    return y$1(r2, o3);
  }
  return o2.displayName = "Lazy", o2.__f = true, o2;
}
function V() {
  this.u = null, this.o = null;
}
l$1.unmount = function(n2) {
  var t2 = n2.__c;
  t2 && t2.__R && t2.__R(), t2 && true === n2.__h && (n2.type = null), I && I(n2);
}, (D.prototype = new b$1()).__c = function(n2, t2) {
  var e2 = t2.__c, r2 = this;
  null == r2.t && (r2.t = []), r2.t.push(e2);
  var u2 = F(r2.__v), o2 = false, i = function() {
    o2 || (o2 = true, e2.__R = null, u2 ? u2(l2) : l2());
  };
  e2.__R = i;
  var l2 = function() {
    if (!--r2.__u) {
      if (r2.state.__a) {
        var n3 = r2.state.__a;
        r2.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t3;
      for (r2.setState({
        __a: r2.__b = null
      }); t3 = r2.t.pop(); )
        t3.forceUpdate();
    }
  }, c2 = true === t2.__h;
  r2.__u++ || c2 || r2.setState({
    __a: r2.__b = r2.__v.__k[0]
  }), n2.then(i, i);
}, D.prototype.componentWillUnmount = function() {
  this.t = [];
}, D.prototype.render = function(n2, e2) {
  if (this.__b) {
    if (this.__v.__k) {
      var r2 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L(this.__b, r2, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i = e2.__a && y$1(k$2, null, n2.fallback);
  return i && (i.__h = null), [y$1(k$2, null, e2.__a ? null : n2.children), i];
};
var W$6 = function(n2, t2, e2) {
  if (++e2[1] === e2[0] && n2.o.delete(t2), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
    for (e2 = n2.u; e2; ) {
      for (; e2.length > 3; )
        e2.pop()();
      if (e2[1] < e2[0])
        break;
      n2.u = e2 = e2[2];
    }
};
function P(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function j(n2) {
  var e2 = this, r2 = n2.i;
  e2.componentWillUnmount = function() {
    D$1(null, e2.l), e2.l = null, e2.i = null;
  }, e2.i && e2.i !== r2 && e2.componentWillUnmount(), n2.__v ? (e2.l || (e2.i = r2, e2.l = {
    nodeType: 1,
    parentNode: r2,
    childNodes: [],
    appendChild: function(n3) {
      this.childNodes.push(n3), e2.i.appendChild(n3);
    },
    insertBefore: function(n3, t2) {
      this.childNodes.push(n3), e2.i.appendChild(n3);
    },
    removeChild: function(n3) {
      this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e2.i.removeChild(n3);
    }
  }), D$1(y$1(P, {
    context: e2.context
  }, n2.__v), e2.l)) : e2.l && e2.componentWillUnmount();
}
function z(n2, e2) {
  var r2 = y$1(j, {
    __v: n2,
    i: e2
  });
  return r2.containerInfo = e2, r2;
}
(V.prototype = new b$1()).__a = function(n2) {
  var t2 = this, e2 = F(t2.__v), r2 = t2.o.get(n2);
  return r2[0]++, function(u2) {
    var o2 = function() {
      t2.props.revealOrder ? (r2.push(u2), W$6(t2, n2, r2)) : u2();
    };
    e2 ? e2(o2) : o2();
  };
}, V.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t2 = S(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t2.reverse();
  for (var e2 = t2.length; e2--; )
    this.o.set(t2[e2], this.u = [1, 0, this.u]);
  return n2.children;
}, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t2, e2) {
    W$6(n2, e2, t2);
  });
};
var B = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, H = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, Z = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, Y = /[A-Z0-9]/g, $ = "undefined" != typeof document, q = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n2);
};
function G(n2, t2, e2) {
  return null == t2.__k && (t2.textContent = ""), D$1(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
function J(n2, t2, e2) {
  return E$1(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
b$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t2) {
  Object.defineProperty(b$1.prototype, t2, {
    configurable: true,
    get: function() {
      return this["UNSAFE_" + t2];
    },
    set: function(n2) {
      Object.defineProperty(this, t2, {
        configurable: true,
        writable: true,
        value: n2
      });
    }
  });
});
var K$5 = l$1.event;
function Q() {
}
function X() {
  return this.cancelBubble;
}
function nn() {
  return this.defaultPrevented;
}
l$1.event = function(n2) {
  return K$5 && (n2 = K$5(n2)), n2.persist = Q, n2.isPropagationStopped = X, n2.isDefaultPrevented = nn, n2.nativeEvent = n2;
};
var tn, en$1 = {
  enumerable: false,
  configurable: true,
  get: function() {
    return this.class;
  }
}, rn = l$1.vnode;
l$1.vnode = function(n2) {
  "string" == typeof n2.type && function(n3) {
    var t2 = n3.props, e2 = n3.type, u2 = {};
    for (var o2 in t2) {
      var i = t2[o2];
      if (!("value" === o2 && "defaultValue" in t2 && null == i || $ && "children" === o2 && "noscript" === e2 || "class" === o2 || "className" === o2)) {
        var l2 = o2.toLowerCase();
        "defaultValue" === o2 && "value" in t2 && null == t2.value ? o2 = "value" : "download" === o2 && true === i ? i = "" : "ondoubleclick" === l2 ? o2 = "ondblclick" : "onchange" !== l2 || "input" !== e2 && "textarea" !== e2 || q(t2.type) ? "onfocus" === l2 ? o2 = "onfocusin" : "onblur" === l2 ? o2 = "onfocusout" : Z.test(o2) ? o2 = l2 : -1 === e2.indexOf("-") && H.test(o2) ? o2 = o2.replace(Y, "-$&").toLowerCase() : null === i && (i = void 0) : l2 = o2 = "oninput", "oninput" === l2 && u2[o2 = l2] && (o2 = "oninputCapture"), u2[o2] = i;
      }
    }
    "select" == e2 && u2.multiple && Array.isArray(u2.value) && (u2.value = S(t2.children).forEach(function(n4) {
      n4.props.selected = -1 != u2.value.indexOf(n4.props.value);
    })), "select" == e2 && null != u2.defaultValue && (u2.value = S(t2.children).forEach(function(n4) {
      n4.props.selected = u2.multiple ? -1 != u2.defaultValue.indexOf(n4.props.value) : u2.defaultValue == n4.props.value;
    })), t2.class && !t2.className ? (u2.class = t2.class, Object.defineProperty(u2, "className", en$1)) : (t2.className && !t2.class || t2.class && t2.className) && (u2.class = u2.className = t2.className), n3.props = u2;
  }(n2), n2.$$typeof = B, rn && rn(n2);
};
var un = l$1.__r;
l$1.__r = function(n2) {
  un && un(n2), tn = n2.__c;
};
var on = l$1.diffed;
l$1.diffed = function(n2) {
  on && on(n2);
  var t2 = n2.props, e2 = n2.__e;
  null != e2 && "textarea" === n2.type && "value" in t2 && t2.value !== e2.value && (e2.value = null == t2.value ? "" : t2.value), tn = null;
};
var ln = {
  ReactCurrentDispatcher: {
    current: {
      readContext: function(n2) {
        return tn.__n[n2.__c].props.value;
      }
    }
  }
}, cn = "17.0.2";
function fn(n2) {
  return y$1.bind(null, n2);
}
function an(n2) {
  return !!n2 && n2.$$typeof === B;
}
function sn(n2) {
  return an(n2) ? F$2.apply(null, arguments) : n2;
}
function hn(n2) {
  return !!n2.__k && (D$1(null, n2), true);
}
function vn(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
var dn = function(n2, t2) {
  return n2(t2);
}, pn = function(n2, t2) {
  return n2(t2);
}, mn = k$2;
function yn(n2) {
  n2();
}
function _n(n2) {
  return n2;
}
function bn$1() {
  return [false, yn];
}
var Sn = y;
function gn(n2, t2) {
  var e2 = t2(), r2 = h({
    h: {
      __: e2,
      v: t2
    }
  }), u2 = r2[0].h, o2 = r2[1];
  return y(function() {
    u2.__ = e2, u2.v = t2, E(u2.__, t2()) || o2({
      h: u2
    });
  }, [n2, e2, t2]), p(function() {
    return E(u2.__, u2.v()) || o2({
      h: u2
    }), n2(function() {
      E(u2.__, u2.v()) || o2({
        h: u2
      });
    });
  }, [n2]), e2;
}
var Cn = {
  useState: h,
  useId: V$1,
  useReducer: s$1,
  useEffect: p,
  useLayoutEffect: y,
  useInsertionEffect: Sn,
  useTransition: bn$1,
  useDeferredValue: _n,
  useSyncExternalStore: gn,
  startTransition: yn,
  useRef: _,
  useImperativeHandle: A$1,
  useMemo: F$1,
  useCallback: T$1,
  useContext: q$1,
  useDebugValue: x$1,
  version: "17.0.2",
  Children: O,
  render: G,
  hydrate: J,
  unmountComponentAtNode: hn,
  createPortal: z,
  createElement: y$1,
  createContext: G$1,
  createFactory: fn,
  cloneElement: sn,
  createRef: _$1,
  Fragment: k$2,
  isValidElement: an,
  findDOMNode: vn,
  Component: b$1,
  PureComponent: w,
  memo: x,
  forwardRef: k,
  flushSync: pn,
  unstable_batchedUpdates: dn,
  StrictMode: mn,
  Suspense: D,
  SuspenseList: V,
  lazy: M,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ln
};
const compat_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Children: O,
  PureComponent: w,
  StrictMode: mn,
  Suspense: D,
  SuspenseList: V,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ln,
  cloneElement: sn,
  createFactory: fn,
  createPortal: z,
  default: Cn,
  findDOMNode: vn,
  flushSync: pn,
  forwardRef: k,
  hydrate: J,
  isValidElement: an,
  lazy: M,
  memo: x,
  render: G,
  startTransition: yn,
  unmountComponentAtNode: hn,
  unstable_batchedUpdates: dn,
  useDeferredValue: _n,
  useInsertionEffect: Sn,
  useSyncExternalStore: gn,
  useTransition: bn$1,
  version: cn,
  Component: b$1,
  Fragment: k$2,
  createContext: G$1,
  createElement: y$1,
  createRef: _$1,
  useCallback: T$1,
  useContext: q$1,
  useDebugValue: x$1,
  useEffect: p,
  useErrorBoundary: P$1,
  useId: V$1,
  useImperativeHandle: A$1,
  useLayoutEffect: y,
  useMemo: F$1,
  useReducer: s$1,
  useRef: _,
  useState: h
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$2 = /* @__PURE__ */ getAugmentedNamespace(compat_module);
function _interopDefault$1(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var legacyUtils = require$$0$3;
var QRCode$3 = _interopDefault$1(browser$2);
var copy = _interopDefault$1(copyToClipboard);
var React = require$$3$2;
function open(uri) {
  QRCode$3.toString(uri, {
    type: "terminal"
  }).then(console.log);
}
var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e2) {
    return recover(e2);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='300px' height='185px' viewBox='0 0 300 185' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3EWalletConnect%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='walletconnect-logo-alt' fill='%233B99FC' fill-rule='nonzero'%3E %3Cpath d='M61.4385429,36.2562612 C110.349767,-11.6319051 189.65053,-11.6319051 238.561752,36.2562612 L244.448297,42.0196786 C246.893858,44.4140867 246.893858,48.2961898 244.448297,50.690599 L224.311602,70.406102 C223.088821,71.6033071 221.106302,71.6033071 219.883521,70.406102 L211.782937,62.4749541 C177.661245,29.0669724 122.339051,29.0669724 88.2173582,62.4749541 L79.542302,70.9685592 C78.3195204,72.1657633 76.337001,72.1657633 75.1142214,70.9685592 L54.9775265,51.2530561 C52.5319653,48.8586469 52.5319653,44.9765439 54.9775265,42.5821357 L61.4385429,36.2562612 Z M280.206339,77.0300061 L298.128036,94.5769031 C300.573585,96.9713 300.573599,100.85338 298.128067,103.247793 L217.317896,182.368927 C214.872352,184.763353 210.907314,184.76338 208.461736,182.368989 C208.461726,182.368979 208.461714,182.368967 208.461704,182.368957 L151.107561,126.214385 C150.496171,125.615783 149.504911,125.615783 148.893521,126.214385 C148.893517,126.214389 148.893514,126.214393 148.89351,126.214396 L91.5405888,182.368927 C89.095052,184.763359 85.1300133,184.763399 82.6844276,182.369014 C82.6844133,182.369 82.684398,182.368986 82.6843827,182.36897 L1.87196327,103.246785 C-0.573596939,100.852377 -0.573596939,96.9702735 1.87196327,94.5758653 L19.7936929,77.028998 C22.2392531,74.6345898 26.2042918,74.6345898 28.6498531,77.028998 L86.0048306,133.184355 C86.6162214,133.782957 87.6074796,133.782957 88.2188704,133.184355 C88.2188796,133.184346 88.2188878,133.184338 88.2188969,133.184331 L145.571,77.028998 C148.016505,74.6345347 151.981544,74.6344449 154.427161,77.028798 C154.427195,77.0288316 154.427229,77.0288653 154.427262,77.028899 L211.782164,133.184331 C212.393554,133.782932 213.384814,133.782932 213.996204,133.184331 L271.350179,77.0300061 C273.79574,74.6355969 277.760778,74.6355969 280.206339,77.0300061 Z' id='WalletConnect'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E";
var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
var ANIMATION_DURATION = 300;
var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
function Header(props) {
  return React.createElement("div", {
    className: "walletconnect-modal__header"
  }, React.createElement("img", {
    src: WALLETCONNECT_LOGO_SVG_URL,
    className: "walletconnect-modal__headerLogo"
  }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
    className: "walletconnect-modal__close__wrapper",
    onClick: props.onClose
  }, React.createElement("div", {
    id: WALLETCONNECT_CLOSE_BUTTON_ID,
    className: "walletconnect-modal__close__icon"
  }, React.createElement("div", {
    className: "walletconnect-modal__close__line1"
  }), React.createElement("div", {
    className: "walletconnect-modal__close__line2"
  }))));
}
function ConnectButton(props) {
  return React.createElement("a", {
    className: "walletconnect-connect__button",
    href: props.href,
    id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
    onClick: props.onClick,
    rel: "noopener noreferrer",
    style: {
      backgroundColor: props.color
    },
    target: "_blank"
  }, props.name);
}
var CARET_SVG_URL = "data:image/svg+xml,%3Csvg width='8' height='18' viewBox='0 0 8 18' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0.586301 0.213898C0.150354 0.552968 0.0718197 1.18124 0.41089 1.61719L5.2892 7.88931C5.57007 8.25042 5.57007 8.75608 5.2892 9.11719L0.410889 15.3893C0.071819 15.8253 0.150353 16.4535 0.586301 16.7926C1.02225 17.1317 1.65052 17.0531 1.98959 16.6172L6.86791 10.3451C7.7105 9.26174 7.7105 7.74476 6.86791 6.66143L1.98959 0.38931C1.65052 -0.0466374 1.02225 -0.125172 0.586301 0.213898Z' fill='%233C4252'/%3E %3C/svg%3E";
function WalletButton(props) {
  var color = props.color;
  var href = props.href;
  var name2 = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  return React.createElement("a", {
    className: "walletconnect-modal__base__row",
    href,
    onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("h3", {
    className: "walletconnect-modal__base__row__h3"
  }, name2), React.createElement("div", {
    className: "walletconnect-modal__base__row__right"
  }, React.createElement("div", {
    className: "walletconnect-modal__base__row__right__app-icon",
    style: {
      background: "url('" + logo + "') " + color,
      backgroundSize: "100%"
    }
  }), React.createElement("img", {
    src: CARET_SVG_URL,
    className: "walletconnect-modal__base__row__right__caret"
  })));
}
function WalletIcon(props) {
  var color = props.color;
  var href = props.href;
  var name2 = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
  return React.createElement("a", {
    className: "walletconnect-connect__button__icon_anchor",
    href,
    onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("div", {
    className: "walletconnect-connect__button__icon",
    style: {
      background: "url('" + logo + "') " + color,
      backgroundSize: "100%"
    }
  }), React.createElement("div", {
    style: {
      fontSize
    },
    className: "walletconnect-connect__button__text"
  }, name2));
}
var GRID_MIN_COUNT = 5;
var LINKS_PER_PAGE = 12;
function LinkDisplay(props) {
  var android = legacyUtils.isAndroid();
  var ref = React.useState("");
  var input = ref[0];
  var setInput = ref[1];
  var ref$1 = React.useState("");
  var filter2 = ref$1[0];
  var setFilter = ref$1[1];
  var ref$2 = React.useState(1);
  var page = ref$2[0];
  var setPage = ref$2[1];
  var links = filter2 ? props.links.filter(function(link) {
    return link.name.toLowerCase().includes(filter2.toLowerCase());
  }) : props.links;
  var errorMessage = props.errorMessage;
  var grid = filter2 || links.length > GRID_MIN_COUNT;
  var pages = Math.ceil(links.length / LINKS_PER_PAGE);
  var range2 = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
  var pageLinks = links.length ? links.filter(function(_2, index2) {
    return index2 + 1 >= range2[0] && index2 + 1 <= range2[1];
  }) : [];
  var hasPaging = !!(!android && pages > 1);
  var filterTimeout = void 0;
  function handleInput(e2) {
    setInput(e2.target.value);
    clearTimeout(filterTimeout);
    if (e2.target.value) {
      filterTimeout = setTimeout(function() {
        setFilter(e2.target.value);
        setPage(1);
      }, 1e3);
    } else {
      setInput("");
      setFilter("");
      setPage(1);
    }
  }
  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
    className: "walletconnect-search__input",
    placeholder: "Search",
    value: input,
    onChange: handleInput
  }), React.createElement("div", {
    className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
  }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
    var color = entry.color;
    var name2 = entry.name;
    var shortName = entry.shortName;
    var logo = entry.logo;
    var href = legacyUtils.formatIOSMobile(props.uri, entry);
    var handleClickIOS = React.useCallback(function() {
      legacyUtils.saveMobileLinkInfo({
        name: name2,
        href
      });
    }, [pageLinks]);
    return !grid ? React.createElement(WalletButton, {
      color,
      href,
      name: name2,
      logo,
      onClick: handleClickIOS
    }) : React.createElement(WalletIcon, {
      color,
      href,
      name: shortName || name2,
      logo,
      onClick: handleClickIOS
    });
  }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
    name: props.text.connect,
    color: DEFAULT_BUTTON_COLOR,
    href: props.uri,
    onClick: React.useCallback(function() {
      legacyUtils.saveMobileLinkInfo({
        name: "Unknown",
        href: props.uri
      });
    }, [])
  })), hasPaging && React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, Array(pages).fill(0).map(function(_2, index2) {
    var pageNumber = index2 + 1;
    var selected = page === pageNumber;
    return React.createElement("a", {
      style: {
        margin: "auto 10px",
        fontWeight: selected ? "bold" : "normal"
      },
      onClick: function() {
        return setPage(pageNumber);
      }
    }, pageNumber);
  })));
}
function Notification$1(props) {
  var show = !!props.message.trim();
  return React.createElement("div", {
    className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
  }, props.message);
}
var formatQRCodeImage = function(data) {
  try {
    var result = "";
    return Promise.resolve(QRCode$3.toString(data, {
      margin: 0,
      type: "svg"
    })).then(function(dataString) {
      if (typeof dataString === "string") {
        result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
      }
      return result;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
};
function QRCodeDisplay(props) {
  var ref = React.useState("");
  var notification = ref[0];
  var setNotification = ref[1];
  var ref$1 = React.useState("");
  var svg2 = ref$1[0];
  var setSvg = ref$1[1];
  React.useEffect(function() {
    try {
      return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
        setSvg(_formatQRCodeImage);
      });
    } catch (e2) {
      Promise.reject(e2);
    }
  }, []);
  var copyToClipboard2 = function() {
    var success = copy(props.uri);
    if (success) {
      setNotification(props.text.copied_to_clipboard);
      setInterval(function() {
        return setNotification("");
      }, 1200);
    } else {
      setNotification("Error");
      setInterval(function() {
        return setNotification("");
      }, 1200);
    }
  };
  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: svg2
    }
  }), React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, React.createElement("a", {
    onClick: copyToClipboard2
  }, props.text.copy_to_clipboard)), React.createElement(Notification$1, {
    message: notification
  }));
}
function Modal(props) {
  var android = legacyUtils.isAndroid();
  var mobile = legacyUtils.isMobile();
  var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
  var ref = React.useState(false);
  var loading = ref[0];
  var setLoading = ref[1];
  var ref$1 = React.useState(false);
  var fetched = ref$1[0];
  var setFetched = ref$1[1];
  var ref$2 = React.useState(!mobile);
  var displayQRCode = ref$2[0];
  var setDisplayQRCode = ref$2[1];
  var displayProps = {
    mobile,
    text: props.text,
    uri: props.uri,
    qrcodeModalOptions: props.qrcodeModalOptions
  };
  var ref$3 = React.useState("");
  var singleLinkHref = ref$3[0];
  var setSingleLinkHref = ref$3[1];
  var ref$4 = React.useState(false);
  var hasSingleLink = ref$4[0];
  var setHasSingleLink = ref$4[1];
  var ref$5 = React.useState([]);
  var links = ref$5[0];
  var setLinks = ref$5[1];
  var ref$6 = React.useState("");
  var errorMessage = ref$6[0];
  var setErrorMessage = ref$6[1];
  var getLinksIfNeeded = function() {
    if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
      return;
    }
    React.useEffect(function() {
      var initLinks = function() {
        try {
          if (android) {
            return Promise.resolve();
          }
          setLoading(true);
          var _temp = _catch(function() {
            var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : legacyUtils.getWalletRegistryUrl();
            return Promise.resolve(fetch(url)).then(function(registryResponse) {
              return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                var registry = _registryResponse$jso.listings;
                var platform = mobile ? "mobile" : "desktop";
                var _links = legacyUtils.getMobileLinkRegistry(legacyUtils.formatMobileRegistry(registry, platform), whitelist);
                setLoading(false);
                setFetched(true);
                setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                setLinks(_links);
                var hasSingleLink2 = _links.length === 1;
                if (hasSingleLink2) {
                  setSingleLinkHref(legacyUtils.formatIOSMobile(props.uri, _links[0]));
                  setDisplayQRCode(true);
                }
                setHasSingleLink(hasSingleLink2);
              });
            });
          }, function(e2) {
            setLoading(false);
            setFetched(true);
            setErrorMessage(props.text.something_went_wrong);
            console.error(e2);
          });
          return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
          }) : void 0);
        } catch (e2) {
          return Promise.reject(e2);
        }
      };
      initLinks();
    });
  };
  getLinksIfNeeded();
  var rightSelected = mobile ? displayQRCode : !displayQRCode;
  return React.createElement("div", {
    id: WALLETCONNECT_MODAL_ID,
    className: "walletconnect-qrcode__base animated fadeIn"
  }, React.createElement("div", {
    className: "walletconnect-modal__base"
  }, React.createElement(Header, {
    onClose: props.onClose
  }), hasSingleLink && displayQRCode ? React.createElement("div", {
    className: "walletconnect-modal__single_wallet"
  }, React.createElement("a", {
    onClick: function() {
      return legacyUtils.saveMobileLinkInfo({
        name: links[0].name,
        href: singleLinkHref
      });
    },
    href: singleLinkHref,
    rel: "noopener noreferrer",
    target: "_blank"
  }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
  }, React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle_selector"
  }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(false), getLinksIfNeeded();
    }
  }, props.text.mobile), React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(true);
    }
  }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(true);
    }
  }, props.text.qrcode), React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(false), getLinksIfNeeded();
    }
  }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
    links,
    errorMessage
  })))));
}
var de = {
  choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
  connect_mobile_wallet: "Verbinde mit Mobile Wallet",
  scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
  connect: "Verbinden",
  qrcode: "QR-Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "In die Zwischenablage kopieren",
  copied_to_clipboard: "In die Zwischenablage kopiert!",
  connect_with: "Verbinden mit Hilfe von",
  loading: "Laden...",
  something_went_wrong: "Etwas ist schief gelaufen",
  no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
  no_wallets_found: "keine Wallet gefunden"
};
var en = {
  choose_preferred_wallet: "Choose your preferred wallet",
  connect_mobile_wallet: "Connect to Mobile Wallet",
  scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
  connect: "Connect",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copy to clipboard",
  copied_to_clipboard: "Copied to clipboard!",
  connect_with: "Connect with",
  loading: "Loading...",
  something_went_wrong: "Something went wrong",
  no_supported_wallets: "There are no supported wallets yet",
  no_wallets_found: "No wallets found"
};
var es = {
  choose_preferred_wallet: "Elige tu billetera preferida",
  connect_mobile_wallet: "Conectar a billetera m\xF3vil",
  scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
  connect: "Conectar",
  qrcode: "C\xF3digo QR",
  mobile: "M\xF3vil",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Conectar mediante",
  loading: "Cargando...",
  something_went_wrong: "Algo sali\xF3 mal",
  no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
  no_wallets_found: "No se encontraron billeteras"
};
var fr = {
  choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
  connect_mobile_wallet: "Se connecter au portefeuille mobile",
  scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
  connect: "Se connecter",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copier",
  copied_to_clipboard: "Copi\xE9!",
  connect_with: "Connectez-vous \xE0 l'aide de",
  loading: "Chargement...",
  something_went_wrong: "Quelque chose a mal tourn\xE9",
  no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
  no_wallets_found: "Aucun portefeuille trouv\xE9"
};
var ko = {
  choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
  connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
  scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
  connect: "\uC5F0\uACB0",
  qrcode: "QR \uCF54\uB4DC",
  mobile: "\uBAA8\uBC14\uC77C",
  desktop: "\uB370\uC2A4\uD06C\uD0D1",
  copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
  copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
  connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
  loading: "\uB85C\uB4DC \uC911...",
  something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
  no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
  no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
};
var pt = {
  choose_preferred_wallet: "Escolha sua carteira preferida",
  connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
  scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
  connect: "Conectar",
  qrcode: "C\xF3digo QR",
  mobile: "M\xF3vel",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Ligar por meio de",
  loading: "Carregamento...",
  something_went_wrong: "Algo correu mal",
  no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
  no_wallets_found: "Nenhuma carteira encontrada"
};
var zh = {
  choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
  connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
  scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
  connect: "\u8FDE\u63A5",
  qrcode: "\u4E8C\u7EF4\u7801",
  mobile: "\u79FB\u52A8",
  desktop: "\u684C\u9762",
  copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
  copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
  connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
  loading: "\u6B63\u5728\u52A0\u8F7D...",
  something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
  no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
  no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
};
var fa = {
  choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
  connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
  scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
  connect: "\u0627\u062A\u0635\u0627\u0644",
  qrcode: "\u06A9\u062F QR",
  mobile: "\u0633\u06CC\u0627\u0631",
  desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
  copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
  copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
  connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
  loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
  something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
  no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
  no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
};
var languages = {
  de,
  en,
  es,
  fr,
  ko,
  pt,
  zh,
  fa
};
function injectStyleSheet() {
  var doc = legacyUtils.getDocumentOrThrow();
  var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
  if (prev) {
    doc.head.removeChild(prev);
  }
  var style = doc.createElement("style");
  style.setAttribute("id", WALLETCONNECT_STYLE_ID);
  style.innerText = WALLETCONNECT_STYLE_SHEET;
  doc.head.appendChild(style);
}
function renderWrapper() {
  var doc = legacyUtils.getDocumentOrThrow();
  var wrapper = doc.createElement("div");
  wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
  doc.body.appendChild(wrapper);
  return wrapper;
}
function triggerCloseAnimation() {
  var doc = legacyUtils.getDocumentOrThrow();
  var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
  if (modal) {
    modal.className = modal.className.replace("fadeIn", "fadeOut");
    setTimeout(function() {
      var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
      if (wrapper) {
        doc.body.removeChild(wrapper);
      }
    }, ANIMATION_DURATION);
  }
}
function getWrappedCallback(cb) {
  return function() {
    triggerCloseAnimation();
    if (cb) {
      cb();
    }
  };
}
function getText() {
  var lang = legacyUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
  return languages[lang] || languages["en"];
}
function open$1(uri, cb, qrcodeModalOptions) {
  injectStyleSheet();
  var wrapper = renderWrapper();
  React.render(React.createElement(Modal, {
    text: getText(),
    uri,
    onClose: getWrappedCallback(cb),
    qrcodeModalOptions
  }), wrapper);
}
function close$1() {
  triggerCloseAnimation();
}
var isNode = function() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
};
function open$2(uri, cb, qrcodeModalOptions) {
  console.log(uri);
  if (isNode()) {
    open(uri);
  } else {
    open$1(uri, cb, qrcodeModalOptions);
  }
}
function close$2() {
  if (isNode())
    ;
  else {
    close$1();
  }
}
var index$1 = {
  open: open$2,
  close: close$2
};
var cjs = index$1;
class SignerConnection extends IJsonRpcConnection {
  constructor(opts) {
    super();
    this.events = new events.exports();
    this.accounts = [];
    this.chainId = 1;
    this.pending = false;
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModalOptions = void 0;
    this.opts = opts;
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.wc = this.register(opts);
  }
  get connected() {
    return typeof this.wc !== "undefined" && this.wc.connected;
  }
  get connecting() {
    return this.pending;
  }
  get connector() {
    this.wc = this.register(this.opts);
    return this.wc;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(chainId) {
    if (this.connected) {
      this.onOpen();
      return;
    }
    return new Promise((resolve, reject) => {
      this.on("error", (err) => {
        reject(err);
      });
      this.on("open", () => {
        resolve();
      });
      this.create(chainId);
    });
  }
  async close() {
    if (typeof this.wc === "undefined")
      return;
    if (this.wc.connected) {
      this.wc.killSession();
    }
    this.onClose();
  }
  async send(payload) {
    this.wc = this.register(this.opts);
    if (!this.connected)
      await this.open();
    this.sendPayload(payload).then((res) => this.events.emit("payload", res)).catch((e2) => this.events.emit("payload", formatJsonRpcError(payload.id, e2.message)));
  }
  register(opts) {
    if (this.wc)
      return this.wc;
    this.opts = opts || this.opts;
    this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector) ? opts.connector.bridge : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
    this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
    this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : this.chainId;
    this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
    const connectorOpts = {
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? cjs : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    };
    this.wc = typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== "undefined" ? opts.connector : new WalletConnect(connectorOpts);
    if (typeof this.wc === "undefined") {
      throw new Error("Failed to register WalletConnect connector");
    }
    if (this.wc.accounts.length) {
      this.accounts = this.wc.accounts;
    }
    if (this.wc.chainId) {
      this.chainId = this.wc.chainId;
    }
    this.registerConnectorEvents();
    return this.wc;
  }
  onOpen(wc) {
    this.pending = false;
    if (wc) {
      this.wc = wc;
    }
    this.events.emit("open");
  }
  onClose() {
    this.pending = false;
    if (this.wc) {
      this.wc = void 0;
    }
    this.events.emit("close");
  }
  onError(payload, message = "Failed or Rejected Request", code2 = -32e3) {
    const errorPayload = {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      error: {
        code: code2,
        message
      }
    };
    this.events.emit("payload", errorPayload);
    return errorPayload;
  }
  create(chainId) {
    this.wc = this.register(this.opts);
    this.chainId = chainId || this.chainId;
    if (this.connected || this.pending)
      return;
    this.pending = true;
    this.registerConnectorEvents();
    this.wc.createSession({
      chainId: this.chainId
    }).then(() => this.events.emit("created")).catch((e2) => this.events.emit("error", e2));
  }
  registerConnectorEvents() {
    this.wc = this.register(this.opts);
    this.wc.on("connect", (err) => {
      var _a2, _b2;
      if (err) {
        this.events.emit("error", err);
        return;
      }
      this.accounts = ((_a2 = this.wc) === null || _a2 === void 0 ? void 0 : _a2.accounts) || [];
      this.chainId = ((_b2 = this.wc) === null || _b2 === void 0 ? void 0 : _b2.chainId) || this.chainId;
      this.onOpen();
    });
    this.wc.on("disconnect", (err) => {
      if (err) {
        this.events.emit("error", err);
        return;
      }
      this.onClose();
    });
    this.wc.on("modal_closed", () => {
      this.events.emit("error", new Error("User closed modal"));
    });
    this.wc.on("session_update", (error, payload) => {
      const {
        accounts,
        chainId
      } = payload.params[0];
      if (!this.accounts || accounts && this.accounts !== accounts) {
        this.accounts = accounts;
        this.events.emit("accountsChanged", accounts);
      }
      if (!this.chainId || chainId && this.chainId !== chainId) {
        this.chainId = chainId;
        this.events.emit("chainChanged", chainId);
      }
    });
  }
  async sendPayload(payload) {
    this.wc = this.register(this.opts);
    try {
      const response = await this.wc.unsafeSend(payload);
      return this.sanitizeResponse(response);
    } catch (error) {
      return this.onError(payload, error.message);
    }
  }
  sanitizeResponse(response) {
    return typeof response.error !== "undefined" && typeof response.error.code === "undefined" ? formatJsonRpcError(response.id, response.error.message, response.error.data) : response;
  }
}
class WalletConnectProvider {
  constructor(opts) {
    this.events = new events.exports();
    this.rpc = {
      infuraId: opts === null || opts === void 0 ? void 0 : opts.infuraId,
      custom: opts === null || opts === void 0 ? void 0 : opts.rpc
    };
    this.signer = new JsonRpcProvider(new SignerConnection(opts));
    const chainId = this.signer.connection.chainId || (opts === null || opts === void 0 ? void 0 : opts.chainId) || 1;
    this.http = this.setHttpProvider(chainId);
    this.registerEventListeners();
  }
  get connected() {
    return this.signer.connection.connected;
  }
  get connector() {
    return this.signer.connection.connector;
  }
  get accounts() {
    return this.signer.connection.accounts;
  }
  get chainId() {
    return this.signer.connection.chainId;
  }
  get rpcUrl() {
    var _a2;
    return ((_a2 = this.http) === null || _a2 === void 0 ? void 0 : _a2.connection).url || "";
  }
  async request(args) {
    switch (args.method) {
      case "eth_requestAccounts":
        await this.connect();
        return this.signer.connection.accounts;
      case "eth_accounts":
        return this.signer.connection.accounts;
      case "eth_chainId":
        return this.signer.connection.chainId;
    }
    if (SIGNING_METHODS.includes(args.method)) {
      return this.signer.request(args);
    }
    if (typeof this.http === "undefined") {
      throw new Error(`Cannot request JSON-RPC method (${args.method}) without provided rpc url`);
    }
    return this.http.request(args);
  }
  sendAsync(args, callback) {
    this.request(args).then((response) => callback(null, response)).catch((error) => callback(error, void 0));
  }
  async enable() {
    const accounts = await this.request({
      method: "eth_requestAccounts"
    });
    return accounts;
  }
  async connect() {
    if (!this.signer.connection.connected) {
      await this.signer.connect();
    }
  }
  async disconnect() {
    if (this.signer.connection.connected) {
      await this.signer.disconnect();
    }
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  get isWalletConnect() {
    return true;
  }
  registerEventListeners() {
    this.signer.connection.on("accountsChanged", (accounts) => {
      this.events.emit("accountsChanged", accounts);
    });
    this.signer.connection.on("chainChanged", (chainId) => {
      this.http = this.setHttpProvider(chainId);
      this.events.emit("chainChanged", chainId);
    });
    this.signer.on("disconnect", () => {
      this.events.emit("disconnect");
    });
  }
  setHttpProvider(chainId) {
    const rpcUrl = getRpcUrl(chainId, this.rpc);
    if (typeof rpcUrl === "undefined")
      return void 0;
    const http = new JsonRpcProvider(new HttpConnection(rpcUrl));
    return http;
  }
}
const $$25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: WalletConnectProvider
}, Symbol.toStringTag, { value: "Module" }));
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn2, context, once3) {
    this.fn = fn2;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn2, context, once3) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events2 = this._events) {
      if (has2.call(events2, name2))
        names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee = new Array(l2); i < l2; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j2;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn2, context) {
    return addListener2(this, event, fn2, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn2, context) {
    return addListener2(this, event, fn2, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn2, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn2 && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn2 || once3 && !listeners2[i].once || context && listeners2[i].context !== context) {
          events2.push(listeners2[i]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
const EventEmitter = eventemitter3.exports;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var Connector = class extends EventEmitter {
  constructor({
    chains = [mainnet, goerli],
    options
  }) {
    super();
    __publicField(this, "chains");
    __publicField(this, "options");
    this.chains = chains;
    this.options = options;
  }
  getBlockExplorerUrls(chain) {
    var _a2;
    const {
      default: blockExplorer,
      ...blockExplorers
    } = (_a2 = chain.blockExplorers) != null ? _a2 : {};
    if (blockExplorer)
      return [blockExplorer.url, ...Object.values(blockExplorers).map((x2) => x2.url)];
  }
  isChainUnsupported(chainId) {
    return !this.chains.some((x2) => x2.id === chainId);
  }
};
var utils$e = {};
var bn = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module2) {
  (function(module3, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base3, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number2 || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$3$1.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init3(number2, base3, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base3, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base3 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base3, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [number2 & 67108863, number2 / 67108864 & 67108863];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [number2 & 67108863, number2 / 67108864 & 67108863, 1];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base3, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j2 = 0; i >= 0; i -= 3) {
          w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j2 = 0; i < number2.length; i += 3) {
          w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i = number2.length - 1; i >= start; i -= 2) {
          w2 = parseHexByte(number2, start, i) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
          w2 = parseHexByte(number2, start, i) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul5) {
      var r2 = 0;
      var b2 = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c2 = str.charCodeAt(i) - 48;
        r2 *= mul5;
        if (c2 >= 49) {
          b2 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b2 = c2 - 17 + 10;
        } else {
          b2 = c2;
        }
        assert2(c2 >= 0 && b2 < mul5, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number2, i, number2.length, base3);
        for (i = 0; i < mod; i++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src6) {
      dest.words = src6.words;
      dest.length = src6.length;
      dest.negative = src6.negative;
      dest.red = src6.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect5;
      } catch (e2) {
        BN2.prototype.inspect = inspect5;
      }
    } else {
      BN2.prototype.inspect = inspect5;
    }
    function inspect5() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = this.words[i];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base3);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0; i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0; i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i = 0; i < b2.length; i++) {
        this.words[i] = a2.words[i] ^ b2.words[i];
      }
      if (this !== a2) {
        for (; i < a2.length; i++) {
          this.words[i] = a2.words[i];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0; i < b2.length; i++) {
        r2 = (a2.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a2.length; i++) {
        r2 = (a2.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i < a2.length; i++) {
          this.words[i] = a2.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add3(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp2 = this.cmp(num);
      if (cmp2 === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp2 > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0; i < b2.length; i++) {
        r2 = (a2.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a2.length; i++) {
        r2 = (a2.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a2.length && a2 !== this) {
        for (; i < a2.length; i++) {
          this.words[i] = a2.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i = k2 - j2 | 0;
          a2 = self2.words[i] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i = k2 - j2;
          var a2 = self2.words[i] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul5(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w2 = (this.words[i] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w2.length; i++, res = res.sqr()) {
        if (w2[i] !== 0)
          break;
      }
      if (++i < w2.length) {
        for (var q2 = res.sqr(); i < w2.length; i++, q2 = q2.sqr()) {
          if (w2[i] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c2 = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul5, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul5;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w2 & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w2 = (this.words[i + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w2 = -(this.words[i] | 0) + carry;
        carry = w2 >> 26;
        this.words[i] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i = 0; i < q2.length; i++) {
          q2.words[i] = 0;
        }
      }
      var diff2 = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff2.negative === 0) {
        a2 = diff2;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2._strip();
      }
      a2._strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp2 = mod.cmp(half);
      if (cmp2 < 0 || r2 === 1 && cmp2 === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p2 * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w2 = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i = 0, im = 1; (x2.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x2.iushrn(i);
          while (i-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a2.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a2.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w2 = this.words[i] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i] = w2;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp2(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a2 = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte2(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte2(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq5(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp2 = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp2 === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp2 > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask2;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w2 = num.words[i] | 0;
        lo += w2 * 977;
        num.words[i] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg3(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add3(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul5(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul5(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn);
const BN$3 = bn.exports;
const version$n = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = {
  debug: 1,
  "default": 2,
  info: 2,
  warning: 3,
  error: 4,
  off: 5
};
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex2 = "";
          for (let i = 0; i < value.length; i++) {
            hex2 += HEX[value[i] >> 4];
            hex2 += HEX[value[i] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex2 + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
        name: target.name,
        operation: "new"
      });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$n);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const lib_esm$k = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get LogLevel() {
    return LogLevel;
  },
  get ErrorCode() {
    return ErrorCode;
  },
  Logger
}, Symbol.toStringTag, { value: "Module" }));
const version$m = "bytes/5.7.0";
const logger$r = new Logger(version$m);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isBytesLike(value) {
  return isHexString$2(value) && !(value.length % 2) || isBytes$1(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes$1(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v2 = value[i];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$r.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString$2(value)) {
    let hex2 = value.substring(2);
    if (hex2.length % 2) {
      if (options.hexPad === "left") {
        hex2 = "0" + hex2;
      } else if (options.hexPad === "right") {
        hex2 += "0";
      } else {
        logger$r.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex2.length; i += 2) {
      result.push(parseInt(hex2.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes$1(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$r.throwArgumentError("invalid arrayify value", "value", value);
}
function concat$2(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object2) => {
    result.set(object2, offset);
    return offset + object2.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger$r.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString$2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$r.checkSafeUint53(value, "invalid hexlify value");
    let hex2 = "";
    while (value) {
      hex2 = HexCharacters[value & 15] + hex2;
      value = Math.floor(value / 16);
    }
    if (hex2.length) {
      if (hex2.length % 2) {
        hex2 = "0" + hex2;
      }
      return "0x" + hex2;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString$2(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$r.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes$1(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v2 = value[i];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$r.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString$2(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString$2(data) || data.length % 2) {
    logger$r.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed2 = hexStripZeros(hexlify(value, {
    hexPad: "left"
  }));
  if (trimmed2 === "0x") {
    return "0x0";
  }
  return trimmed2;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString$2(value)) {
    logger$r.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString$2(value)) {
    logger$r.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger$r.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes3 = arrayify(signature2);
    if (bytes3.length === 64) {
      result.v = 27 + (bytes3[32] >> 7);
      bytes3[32] &= 127;
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
    } else if (bytes3.length === 65) {
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
      result.v = bytes3[64];
    } else {
      logger$r.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$r.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes3[32] |= 128;
    }
    result._vs = hexlify(bytes3.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$r.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$r.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$r.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$r.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString$2(result.r)) {
      logger$r.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString$2(result.s)) {
      logger$r.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$r.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString$2(result._vs)) {
        logger$r.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$r.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat$2([signature2.r, signature2.s, signature2.recoveryParam ? "0x1c" : "0x1b"]));
}
const lib_esm$j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isBytesLike,
  isBytes: isBytes$1,
  arrayify,
  concat: concat$2,
  stripZeros,
  zeroPad,
  isHexString: isHexString$2,
  hexlify,
  hexDataLength,
  hexDataSlice,
  hexConcat,
  hexValue,
  hexStripZeros,
  hexZeroPad,
  splitSignature,
  joinSignature
}, Symbol.toStringTag, { value: "Module" }));
const version$l = "bignumber/5.7.0";
var BN$2 = BN$3.BN;
const logger$q = new Logger(version$l);
const _constructorGuard$3 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString$2(value) || typeof value === "bigint" || isBytes$1(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex2) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$q.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex2;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$q.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$q.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$q.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$q.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return {
      type: "BigNumber",
      hex: this.toHexString()
    };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$3, toHex$1(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$3, toHex$1(new BN$2(value)));
      }
      return logger$q.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes$1(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex2 = anyValue.toHexString();
        if (typeof hex2 === "string") {
          return BigNumber.from(hex2);
        }
      } else {
        let hex2 = anyValue._hex;
        if (hex2 == null && anyValue.type === "BigNumber") {
          hex2 = anyValue.hex;
        }
        if (typeof hex2 === "string") {
          if (isHexString$2(hex2) || hex2[0] === "-" && isHexString$2(hex2.substring(1))) {
            return BigNumber.from(hex2);
          }
        }
      }
    }
    return logger$q.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$1(value) {
  if (typeof value !== "string") {
    return toHex$1(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$q.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$1(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$1(value));
}
function toBN(value) {
  const hex2 = BigNumber.from(value).toHexString();
  if (hex2[0] === "-") {
    return new BN$2("-" + hex2.substring(3), 16);
  }
  return new BN$2(hex2.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = {
    fault,
    operation
  };
  if (value != null) {
    params.value = value;
  }
  return logger$q.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN$2(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN$2(value, 16).toString(36);
}
const logger$p = new Logger(version$l);
const _constructorGuard$2 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = {
    fault,
    operation
  };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$p.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
let zeros$1 = "0";
while (zeros$1.length < 256) {
  zeros$1 += zeros$1;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros$1.substring(0, decimals);
  }
  return logger$p.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$p.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$p.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$p.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$p.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$p.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key2, type2, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type2) {
          logger$p.throwArgumentError("invalid fixed format (" + key2 + " not " + type2 + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$p.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$p.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$2, signed2, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex2, value, format2) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$p.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format2;
    this._hex = hex2;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$p.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$p.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros$1.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$p.throwArgumentError("invalid byte width", "width", width);
    }
    const hex2 = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex2, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format2) {
    return FixedNumber.fromString(this._value, format2);
  }
  static fromValue(value, decimals, format2) {
    if (format2 == null && decimals != null && !isBigNumberish(decimals)) {
      format2 = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format2 == null) {
      format2 = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format2));
  }
  static fromString(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    const numeric2 = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric2.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex2 = null;
    if (fixedFormat.signed) {
      hex2 = numeric2.toTwos(fixedFormat.width).toHexString();
    } else {
      hex2 = numeric2.toHexString();
      hex2 = hexZeroPad(hex2, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex2, decimal, fixedFormat);
  }
  static fromBytes(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric2 = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric2 = numeric2.fromTwos(fixedFormat.width);
    }
    const hex2 = numeric2.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex2, decimal, fixedFormat);
  }
  static from(value, format2) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format2);
    }
    if (isBytes$1(value)) {
      return FixedNumber.fromBytes(value, format2);
    }
    try {
      return FixedNumber.fromValue(value, 0, format2);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$p.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$k = "properties/5.7.0";
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$o = new Logger(version$k);
function defineReadOnly(object2, name2, value) {
  Object.defineProperty(object2, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object2) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const promises = Object.keys(object2).map((key2) => {
      const value = object2[key2];
      return Promise.resolve(value).then((v2) => ({
        key: key2,
        value: v2
      }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object2, properties) {
  if (!object2 || typeof object2 !== "object") {
    logger$o.throwArgumentError("invalid object", "object", object2);
  }
  Object.keys(object2).forEach((key2) => {
    if (!properties[key2]) {
      logger$o.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object2);
    }
  });
}
function shallowCopy(object2) {
  const result = {};
  for (const key2 in object2) {
    result[key2] = object2[key2];
  }
  return result;
}
const opaque$1 = {
  bigint: true,
  boolean: true,
  "function": true,
  number: true,
  string: true
};
function _isFrozen(object2) {
  if (object2 === void 0 || object2 === null || opaque$1[typeof object2]) {
    return true;
  }
  if (Array.isArray(object2) || typeof object2 === "object") {
    if (!Object.isFrozen(object2)) {
      return false;
    }
    const keys = Object.keys(object2);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object2[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$o.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function _deepCopy(object2) {
  if (_isFrozen(object2)) {
    return object2;
  }
  if (Array.isArray(object2)) {
    return Object.freeze(object2.map((item) => deepCopy(item)));
  }
  if (typeof object2 === "object") {
    const result = {};
    for (const key2 in object2) {
      const value = object2[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$o.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function deepCopy(object2) {
  return _deepCopy(object2);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
const lib_esm$i = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defineReadOnly,
  getStatic,
  resolveProperties,
  checkProperties,
  shallowCopy,
  deepCopy,
  Description
}, Symbol.toStringTag, { value: "Module" }));
const version$j = "abi/5.7.0";
const logger$n = new Logger(version$j);
const _constructorGuard$1 = {};
let ModifiersBytes = {
  calldata: true,
  memory: true,
  storage: true
};
let ModifiersNest = {
  calldata: true,
  memory: true
};
function checkModifier(type2, name2) {
  if (type2 === "bytes" || type2 === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type2 === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type2.indexOf("[") >= 0 || type2 === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$n.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i) {
    logger$n.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = {
      type: "",
      name: "",
      parent: parent2,
      state: {
        allowType: true
      }
    };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = {
    type: "",
    name: "",
    state: {
      allowType: true
    }
  };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c2 = param[i];
    switch (c2) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i);
              }
              if (node.indexed) {
                throwError2(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i);
        }
        node.type += c2;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i);
        }
        node.type += c2;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c2;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c2;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c2;
        } else {
          throwError2(i);
        }
    }
  }
  if (node.parent) {
    logger$n.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object2, params) {
  for (let key2 in params) {
    defineReadOnly(object2, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$n.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$n.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format2);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format2 !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$1, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$n.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$n.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$n.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$n.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$n.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$n.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$n.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$n.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$n.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$n.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$n.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$n.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$n.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$n.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$n.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    if (format2 === FormatTypes.sighash) {
      logger$n.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$n.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger$n.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = {
      type: "constructor"
    };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$n.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$n.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format2)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$n.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = {
      type: "function"
    };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$n.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$n.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$n.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$n.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$n.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$n.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$1, params));
  }
  static fromString(value) {
    let params = {
      type: "error"
    };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$n.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type2) {
  if (type2.match(/^uint($|[^1-9])/)) {
    type2 = "uint256" + type2.substring(4);
  } else if (type2.match(/^int($|[^1-9])/)) {
    type2 = "int256" + type2.substring(3);
  }
  return type2;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$n.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$n.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$m = new Logger(version$j);
function checkResultErrors(result) {
  const errors2 = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key2 in object2) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object2[key2]);
      } catch (error) {
        errors2.push({
          path: childPath,
          error
        });
      }
    }
  };
  checkErrors([], result);
  return errors2;
}
class Coder {
  constructor(name2, type2, localName, dynamic2) {
    this.name = name2;
    this.type = type2;
    this.localName = localName;
    this.dynamic = dynamic2;
  }
  _throwError(message, value) {
    logger$m.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat$2(writer._data));
  }
  writeBytes(value) {
    let bytes3 = arrayify(value);
    const paddingOffset = bytes3.length % this.wordSize;
    if (paddingOffset) {
      bytes3 = concat$2([bytes3, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes3);
  }
  _getValue(value) {
    let bytes3 = arrayify(BigNumber.from(value));
    if (bytes3.length > this.wordSize) {
      logger$m.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes3.length
      });
    }
    if (bytes3.length % this.wordSize) {
      bytes3 = concat$2([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
    }
    return bytes3;
  }
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger$m.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes3 = this._peekBytes(0, length, !!loose);
    this._offset += bytes3.length;
    return bytes3.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module2) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type2 = OUTPUT_TYPES[i2];
        method[type2] = createMethod2(bits2, padding2, type2);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak2(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak2(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding2, outputBits).bytepad([n2, s2], w2);
        }
      };
      method.update = function(message, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [{
      name: "keccak",
      padding: KECCAK_PADDING,
      bits: BITS,
      createMethod
    }, {
      name: "sha3",
      padding: PADDING,
      bits: BITS,
      createMethod
    }, {
      name: "shake",
      padding: SHAKE_PADDING,
      bits: SHAKE_BITS,
      createMethod: createShakeMethod
    }, {
      name: "cshake",
      padding: CSHAKE_PADDING,
      bits: SHAKE_BITS,
      createMethod: createCshakeMethod
    }, {
      name: "kmac",
      padding: CSHAKE_PADDING,
      bits: SHAKE_BITS,
      createMethod: createKmacMethod
    }];
    var methods = {}, methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak2(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i2 = 0; i2 < 50; ++i2) {
        this.s[i2] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type2 = typeof message;
      if (type2 !== "string") {
        if (type2 === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i2, code2;
      while (index2 < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        if (notString) {
          for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
            blocks[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
            } else if (code2 < 2048) {
              blocks[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        if (i2 >= byteCount) {
          this.start = i2 - byteCount;
          this.block = blocks[blockCount];
          for (i2 = 0; i2 < blockCount; ++i2) {
            s2[i2] ^= blocks[i2];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i2;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x2, right) {
      var o2 = x2 & 255, n2 = 1;
      var bytes3 = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes3.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n2;
      }
      if (right) {
        bytes3.push(n2);
      } else {
        bytes3.unshift(n2);
      }
      this.update(bytes3);
      return bytes3.length;
    };
    Keccak2.prototype.encodeString = function(str) {
      var notString, type2 = typeof str;
      if (type2 !== "string") {
        if (type2 === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes3 = 0, length = str.length;
      if (notString) {
        bytes3 = length;
      } else {
        for (var i2 = 0; i2 < str.length; ++i2) {
          var code2 = str.charCodeAt(i2);
          if (code2 < 128) {
            bytes3 += 1;
          } else if (code2 < 2048) {
            bytes3 += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes3 += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i2) & 1023);
            bytes3 += 4;
          }
        }
      }
      bytes3 += this.encode(bytes3 * 8);
      this.update(str);
      return bytes3;
    };
    Keccak2.prototype.bytepad = function(strs, w2) {
      var bytes3 = this.encode(w2);
      for (var i2 = 0; i2 < strs.length; ++i2) {
        bytes3 += this.encodeString(strs[i2]);
      }
      var paddingBytes = w2 - bytes3 % w2;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i2 >> 2] |= this.padding[i2 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i2 = 1; i2 < blockCount + 1; ++i2) {
          blocks[i2] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i2 = 0; i2 < blockCount; ++i2) {
        s2[i2] ^= blocks[i2];
      }
      f2(s2);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j3 = 0;
      var hex2 = "", block;
      while (j3 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j3 < outputBlocks; ++i2, ++j3) {
          block = s2[i2];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
          i2 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i2];
        hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex2;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j3 = 0;
      var bytes3 = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes3);
      }
      var array2 = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j3 < outputBlocks; ++i2, ++j3) {
          array2[j3] = s2[i2];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array2[i2] = s2[i2];
        buffer2 = buffer2.slice(0, bytes3);
      }
      return buffer2;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j3 = 0;
      var array2 = [], offset, block;
      while (j3 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j3 < outputBlocks; ++i2, ++j3) {
          offset = j3 << 2;
          block = s2[i2];
          array2[offset] = block & 255;
          array2[offset + 1] = block >> 8 & 255;
          array2[offset + 2] = block >> 16 & 255;
          array2[offset + 3] = block >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset = j3 << 2;
        block = s2[i2];
        array2[offset] = block & 255;
        if (extraBytes > 1) {
          array2[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array2[offset + 2] = block >> 16 & 255;
        }
      }
      return array2;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak2.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module2.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
    }
  })();
})(sha3$1);
const sha3 = sha3$1.exports;
function keccak256$1(data) {
  return "0x" + sha3.keccak_256(arrayify(data));
}
const lib_esm$h = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: keccak256$1
}, Symbol.toStringTag, { value: "Module" }));
const version$i = "rlp/5.7.0";
const logger$l = new Logger(version$i);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object2)) {
    logger$l.throwArgumentError("RLP object must be BytesLike", "object", object2);
  }
  const data = Array.prototype.slice.call(arrayify(object2));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode$2(object2) {
  return hexlify(_encode(object2));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger$l.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return {
    consumed: 1 + length,
    result
  };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger$l.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger$l.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$l.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger$l.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger$l.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$l.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return {
      consumed: 1 + lengthLength + length,
      result
    };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger$l.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return {
      consumed: 1 + length,
      result
    };
  }
  return {
    consumed: 1,
    result: hexlify(data[offset])
  };
}
function decode$2(data) {
  const bytes3 = arrayify(data);
  const decoded = _decode(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger$l.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
const lib_esm$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: encode$2,
  decode: decode$2
}, Symbol.toStringTag, { value: "Module" }));
const version$h = "address/5.7.0";
const logger$k = new Logger(version$h);
function getChecksumAddress(address) {
  if (!isHexString$2(address, 20)) {
    logger$k.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$1(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER$2 = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER$2));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$k.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$k.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$k.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$k.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger$k.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$2([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$k.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$k.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256$1(concat$2(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}
const lib_esm$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAddress,
  isAddress,
  getIcapAddress,
  getContractAddress,
  getCreate2Address
}, Symbol.toStringTag, { value: "Module" }));
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
const logger$j = new Logger(version$j);
function pack$1(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$j.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger$j.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger$j.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$j.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func2) => {
    func2(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type2 = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic2 = length === -1 || coder.dynamic;
    super("array", type2, localName, dynamic2);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer.writeValue(value.length);
    }
    logger$j.checkArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack$1(writer, coders, value);
  }
  decode(reader) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader.readValue().toNumber();
      if (count2 * 32 > reader._data.length) {
        logger$j.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count2
        });
      }
    }
    let coders = [];
    for (let i = 0; i < count2; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type2, localName) {
    super(type2, type2, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v2 = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v2.lt(Zero$1) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v2);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
}
const version$g = "strings/5.7.0";
const logger$i = new Logger(version$g);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes3, output, badCodepoint) {
  return logger$i.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o2 = offset + 1; o2 < bytes3.length; o2++) {
      if (bytes3[o2] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes3);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i = 0;
  while (i < bytes3.length) {
    const c2 = bytes3[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes3, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes3, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes3.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes3, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes3[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes3, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$i.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      if (i >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex2 = "0000" + value.toString(16);
  return "\\u" + hex2.substring(hex2.length - 4);
}
function _toEscapedUtf8String(bytes3, onError) {
  return '"' + getUtf8CodePoints(bytes3, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function formatBytes32String(text) {
  const bytes3 = toUtf8Bytes(text);
  if (bytes3.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat$2([bytes3, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes3) {
  const data = arrayify(bytes3);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func2) {
  if (!func2) {
    func2 = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func2(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return {
      l: lo,
      h: hi
    };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range2 = ranges[i];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
const Table_B_2_ranges = [{
  h: 25,
  s: 32,
  l: 65
}, {
  h: 30,
  s: 32,
  e: [23],
  l: 127
}, {
  h: 54,
  s: 1,
  e: [48],
  l: 64,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 57,
  d: 2
}, {
  h: 44,
  s: 1,
  l: 17,
  d: 2
}, {
  h: 10,
  s: 1,
  e: [2, 6, 8],
  l: 61,
  d: 2
}, {
  h: 16,
  s: 1,
  l: 68,
  d: 2
}, {
  h: 84,
  s: 1,
  e: [18, 24, 66],
  l: 19,
  d: 2
}, {
  h: 26,
  s: 32,
  e: [17],
  l: 435
}, {
  h: 22,
  s: 1,
  l: 71,
  d: 2
}, {
  h: 15,
  s: 80,
  l: 40
}, {
  h: 31,
  s: 32,
  l: 16
}, {
  h: 32,
  s: 1,
  l: 80,
  d: 2
}, {
  h: 52,
  s: 1,
  l: 42,
  d: 2
}, {
  h: 12,
  s: 1,
  l: 55,
  d: 2
}, {
  h: 40,
  s: 1,
  e: [38],
  l: 15,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 48,
  d: 2
}, {
  h: 37,
  s: 48,
  l: 49
}, {
  h: 148,
  s: 1,
  l: 6351,
  d: 2
}, {
  h: 88,
  s: 1,
  l: 160,
  d: 2
}, {
  h: 15,
  s: 16,
  l: 704
}, {
  h: 25,
  s: 26,
  l: 854
}, {
  h: 25,
  s: 32,
  l: 55915
}, {
  h: 37,
  s: 40,
  l: 1247
}, {
  h: 25,
  s: -119711,
  l: 53248
}, {
  h: 25,
  s: -119763,
  l: 52
}, {
  h: 25,
  s: -119815,
  l: 52
}, {
  h: 25,
  s: -119867,
  e: [1, 4, 5, 7, 8, 11, 12, 17],
  l: 52
}, {
  h: 25,
  s: -119919,
  l: 52
}, {
  h: 24,
  s: -119971,
  e: [2, 7, 8, 17],
  l: 52
}, {
  h: 24,
  s: -120023,
  e: [2, 7, 13, 15, 16, 17],
  l: 52
}, {
  h: 25,
  s: -120075,
  l: 52
}, {
  h: 25,
  s: -120127,
  l: 52
}, {
  h: 25,
  s: -120179,
  l: 52
}, {
  h: 25,
  s: -120231,
  l: 52
}, {
  h: 25,
  s: -120283,
  l: 52
}, {
  h: 25,
  s: -120335,
  l: 52
}, {
  h: 24,
  s: -119543,
  e: [17],
  l: 56
}, {
  h: 24,
  s: -119601,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119659,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119717,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119775,
  e: [17],
  l: 58
}];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes2 = Table_B_2_lut_abs[codepoint];
  if (codes2) {
    return codes2;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes2 = toUtf8CodePoints(value);
  codes2 = flatten(codes2.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes2 = toUtf8CodePoints(_toUtf8String(codes2), UnicodeNormalizationForm.NFKC);
  codes2.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes2.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes2);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name2;
}
const lib_esm$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _toEscapedUtf8String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  formatBytes32String,
  parseBytes32String,
  nameprep
}, Symbol.toStringTag, { value: "Module" }));
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic2 = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic2 = true;
      }
      types2.push(coder.type);
    });
    const type2 = "tuple(" + types2.join(",") + ")";
    super("tuple", type2, localName, dynamic2);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack$1(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}
const logger$h = new Logger(version$j);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size2 = parseInt(match[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger$h.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size2 = parseInt(match[1]);
      if (size2 === 0 || size2 > 32) {
        logger$h.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger$h.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders = types2.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    if (types2.length !== values.length) {
      logger$h.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: {
          types: types2.length,
          values: values.length
        },
        value: {
          types: types2,
          values
        }
      });
    }
    const coders = types2.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types2, data, loose) {
    const coders = types2.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(text) {
  return keccak256$1(toUtf8Bytes(text));
}
const version$f = "hash/5.7.0";
function decode$1(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify(data);
}
function encode$1(data) {
  data = arrayify(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
const lib_esm$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$1,
  encode: encode$1
}, Symbol.toStringTag, { value: "Module" }));
function flat(array2, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr2, depth2) {
    forEach.call(arr2, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array2, depth);
  return result;
}
function fromEntries(array2) {
  const result = {};
  for (let i = 0; i < array2.length; i++) {
    const value = array2[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes3) {
  let pos = 0;
  function u16() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip2 = u16();
  let pos_payload = pos;
  pos += skip2;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range2);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a2 = low + Math.floor(range2 * acc[start] / total);
    let b2 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range2 = 1 + b2 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset + bytes3[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(bytes3) {
  return read_payload(decode_arithmetic(bytes3));
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n2, next) {
  let v2 = Array(n2);
  for (let i = 0; i < n2; i++)
    v2[i] = 1 + next();
  return v2;
}
function read_ascending(n2, next) {
  let v2 = Array(n2);
  for (let i = 0, x2 = -1; i < n2; i++)
    v2[i] = x2 += 1 + next();
  return v2;
}
function read_deltas(n2, next) {
  let v2 = Array(n2);
  for (let i = 0, x2 = 0; i < n2; i++)
    v2[i] = x2 += signed(next());
  return v2;
}
function read_member_array(next, lookup2) {
  let v2 = read_ascending(next(), next);
  let n2 = next();
  let vX = read_ascending(n2, next);
  let vN = read_counts(n2, next);
  for (let i = 0; i < n2; i++) {
    for (let j2 = 0; j2 < vN[i]; j2++) {
      v2.push(vX[i] + j2);
    }
  }
  return lookup2 ? v2.map((x2) => lookup2[x2]) : v2;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v2 = [];
  while (true) {
    let i = next();
    if (i == 0)
      break;
    v2.push(i);
  }
  return v2;
}
function read_transposed(n2, w2, next) {
  let m2 = Array(n2).fill(void 0).map(() => []);
  for (let i = 0; i < w2; i++) {
    read_deltas(n2, next).forEach((x2, j2) => m2[j2].push(x2));
  }
  return m2;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m2 = read_transposed(vN.length, 1 + w2, next);
  return flat(m2.map((v2, i) => {
    const x2 = v2[0], ys = v2.slice(1);
    return Array(vN[i]).fill(void 0).map((_2, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y2) => y2 + j_dy)];
    });
  }));
}
function read_replacement_table(w2, next) {
  let n2 = 1 + next();
  let m2 = read_transposed(n2, 1 + w2, next);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a2, b2) => a2 - b2);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({
        set: new Set(keys),
        node: read()
      });
    }
    branches.sort((a2, b2) => b2.set.size - a2.set.size);
    let temp = next();
    let valid2 = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return {
      branches,
      valid: valid2,
      fe0f,
      save,
      check
    };
  }
}
function getData() {
  return read_compressed_payload(decode$1("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$1 = getData();
const VALID = new Set(read_member_array(r$1));
const IGNORED = new Set(read_member_array(r$1));
const MAPPED = read_mapped_map(r$1);
const EMOJI_ROOT = read_emoji_trie(r$1);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize(name2, filter_fe0f));
}
function normalize(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a2;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = (_a2 = node.branches.find((x2) => x2.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
    if (!node)
      break;
    if (node.save) {
      saved = cp;
    } else if (node.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node.valid) {
      emoji = stack.slice();
      if (node.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$g = new Logger(version$f);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes3 = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last2 = 0;
  for (let i = 0; i < bytes3.length; i++) {
    const d2 = bytes3[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes3.slice(last2, i)));
      last2 = i + 1;
    }
  }
  if (last2 >= bytes3.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes3.slice(last2)));
  return comps;
}
function ensNormalize(name2) {
  return ensNameSplit(name2).map((comp) => toUtf8String(comp)).join(".");
}
function isValidName(name2) {
  try {
    return ensNameSplit(name2).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger$g.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros$1;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256$1(concat$2([result, keccak256$1(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat$2(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes3 = new Uint8Array(comp.length + 1);
    bytes3.set(comp, 1);
    bytes3[0] = bytes3.length - 1;
    return bytes3;
  }))) + "00";
}
const messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256$1(concat$2([toUtf8Bytes(messagePrefix), toUtf8Bytes(String(message.length)), message]));
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$f = new Logger(version$f);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes3 = arrayify(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return hexConcat([bytes3, padding.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$f.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$f.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger$f.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes3 = arrayify(value);
      if (bytes3.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes3);
    } catch (error) {
    }
    return logger$f.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type2) {
  {
    const match = type2.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$f.throwArgumentError("invalid numeric width", "type", type2);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$f.throwArgumentError(`value out-of-bounds for ${type2}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$f.throwArgumentError("invalid bytes width", "type", type2);
      }
      return function(value) {
        const bytes3 = arrayify(value);
        if (bytes3.length !== width) {
          logger$f.throwArgumentError(`invalid length for ${type2}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type2) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256$1(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({
    name: name3,
    type: type2
  }) => type2 + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types2)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type2) => {
      links[type2] = {};
      parents[type2] = [];
      subtypes[type2] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$f.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$f.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$f.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
    if (primaryTypes.length === 0) {
      logger$f.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$f.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types2);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type2, found) {
      if (found[type2]) {
        logger$f.throwArgumentError(`circular type reference to ${JSON.stringify(type2)}`, "types", types2);
      }
      found[type2] = true;
      Object.keys(links[type2]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type2];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types2[name2]) + st.map((t2) => encodeType(t2, types2[t2])).join("");
    }
  }
  getEncoder(type2) {
    let encoder = this._encoderCache[type2];
    if (!encoder) {
      encoder = this._encoderCache[type2] = this._getEncoder(type2);
    }
    return encoder;
  }
  _getEncoder(type2) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return encoder;
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger$f.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$1);
        }
        return keccak256$1(hexConcat(result));
      };
    }
    const fields = this.types[type2];
    if (fields) {
      const encodedType = id(this._types[type2]);
      return (value) => {
        const values = fields.map(({
          name: name2,
          type: type3
        }) => {
          const result = this.getEncoder(type3)(value[name2]);
          if (this._types[type3]) {
            return keccak256$1(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$f.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$f.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  hashStruct(name2, value) {
    return keccak256$1(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type2, value, callback) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return callback(type2, value);
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger$f.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, {
        name: name2,
        type: type3
      }) => {
        accum[name2] = this._visit(type3, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$f.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name2 in domain2) {
      const type2 = domainFieldTypes[name2];
      if (!type2) {
        logger$f.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
      }
      domainFields.push({
        name: name2,
        type: type2
      });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", {
      EIP712Domain: domainFields
    }, domain2);
  }
  static encode(domain2, types2, value) {
    return hexConcat(["0x1901", TypedDataEncoder.hashDomain(domain2), TypedDataEncoder.from(types2).hash(value)]);
  }
  static hash(domain2, types2, value) {
    return keccak256$1(TypedDataEncoder.encode(domain2, types2, value));
  }
  static resolveNames(domain2, types2, value, resolveName) {
    return __awaiter$6(this, void 0, void 0, function* () {
      domain2 = shallowCopy(domain2);
      const ensCache = {};
      if (domain2.verifyingContract && !isHexString$2(domain2.verifyingContract, 20)) {
        ensCache[domain2.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types2);
      encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && !isHexString$2(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName(name2);
      }
      if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
        domain2.verifyingContract = ensCache[domain2.verifyingContract];
      }
      value = encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return {
        domain: domain2,
        value
      };
    });
  }
  static getPayload(domain2, types2, value) {
    TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain2[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({
        name: name2,
        type: domainFieldTypes[name2]
      });
    });
    const encoder = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$f.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type2.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type2) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$f.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$f.throwArgumentError("unsupported type", "type", type2);
      })
    };
  }
}
const lib_esm$c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id,
  dnsEncode,
  namehash,
  isValidName,
  ensNormalize,
  messagePrefix,
  hashMessage,
  _TypedDataEncoder: TypedDataEncoder
}, Symbol.toStringTag, { value: "Module" }));
const logger$e = new Logger(version$j);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: true
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"]
  }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
class Interface {
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    defineReadOnly(this, "fragments", abi2.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$e.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$e.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.full;
    }
    if (format2 === FormatTypes.sighash) {
      logger$e.throwArgumentError("interface does not support formatting sighash", "format", format2);
    }
    const abi2 = this.fragments.map((fragment) => fragment.format(format2));
    if (format2 === FormatTypes.json) {
      return JSON.stringify(abi2.map((j2) => JSON.parse(j2)));
    }
    return abi2;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString$2(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$e.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$e.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$e.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$e.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString$2(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$e.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$e.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$e.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$e.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString$2(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger$e.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$e.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$e.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$e.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_2) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$e.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(fragment.inputs, bytes3.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat$2([this.getSighash(fragment), this._encodeParams(fragment.inputs, values || [])]));
  }
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$e.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(functionFragment.inputs, bytes3.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat$2([this.getSighash(functionFragment), this._encodeParams(functionFragment.inputs, values || [])]));
  }
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes3 = arrayify(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes3.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes3);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes3.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes3.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes3.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$e.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$e.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256$1(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$e.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$e.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$e.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$1(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString$2(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$e.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: topicHash,
          value: topics[0]
        });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic2 = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({
            type: "bytes32",
            name: param.name
          }));
          dynamic2.push(true);
        } else {
          indexed.push(param);
          dynamic2.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic2.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat$2(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({
            _isIndexed: true,
            hash: null
          });
        } else if (dynamic2[index2]) {
          result[index2] = new Indexed({
            _isIndexed: true,
            hash: resultIndexed[indexedIndex++]
          });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index2] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i = 0; i < result.length; i++) {
      const value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  parseLog(log4) {
    let fragment = this.getEvent(log4.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log4.data, log4.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const lib_esm$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  Fragment,
  FunctionFragment,
  ParamType,
  FormatTypes,
  AbiCoder,
  defaultAbiCoder,
  Interface,
  Indexed,
  checkResultErrors,
  LogDescription,
  TransactionDescription
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$b);
const require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$f);
const require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$d);
class BaseX {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string2 += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string2 += this.alphabet[digits[q2]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes3 = [];
    if (value.length === 0) {
      return new Uint8Array(bytes3);
    }
    bytes3.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte2 = this._alphabetMap[value[i]];
      if (byte2 === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte2;
      for (let j2 = 0; j2 < bytes3.length; ++j2) {
        carry += bytes3[j2] * this.base;
        bytes3[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes3.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes3.push(0);
    }
    return arrayify(new Uint8Array(bytes3.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const lib_esm$a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseX,
  Base32,
  Base58
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$a);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$j);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$c);
var hash$1 = {};
var utils$d = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var assert$a = minimalisticAssert$1;
var inherits$6 = inherits_browser$1.exports;
utils$d.inherits = inherits$6;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 64512) !== 55296) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 64512) === 56320;
}
function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i = 0; i < msg.length; i++) {
        var c2 = msg.charCodeAt(i);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$d.toArray = toArray$1;
function toHex(msg) {
  var res = "";
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$d.toHex = toHex;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$d.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i = 0; i < msg.length; i++) {
    var w2 = msg[i];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$d.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$d.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$d.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k2 = start; i < res.length; i++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i] = w2 >>> 0;
  }
  return res;
}
utils$d.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k2 = 0; i < msg.length; i++, k2 += 4) {
    var m2 = msg[i];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$d.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$d.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$d.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$d.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$d.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$d.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$d.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$d.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$d.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$d.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch2, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch2 + dh + carry;
  return hi >>> 0;
}
utils$d.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch2, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$d.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch2 + dh + eh + carry;
  return hi >>> 0;
}
utils$d.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$d.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$d.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$d.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$d.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$d.shr64_lo = shr64_lo$1;
var common$6 = {};
var utils$c = utils$d;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$6.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$c.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$c.join32(msg, 0, msg.length - r2, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes3 = this._delta8;
  var k2 = bytes3 - (len + this.padLength) % bytes3;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i = 1; i < k2; i++)
    res[i] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len & 255;
  } else {
    res[i++] = len & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 24 & 255;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
  }
  return res;
};
var sha$1 = {};
var common$5 = {};
var utils$b = utils$d;
var rotr32 = utils$b.rotr32;
function ft_1$1(s2, x2, y2, z2) {
  if (s2 === 0)
    return ch32$1(x2, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y2, z2);
  if (s2 === 2)
    return maj32$1(x2, y2, z2);
}
common$5.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$5.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$5.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$5.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$5.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$5.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$5.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$5.g1_256 = g1_256$1;
var utils$a = utils$d;
var common$4 = common$6;
var shaCommon$1 = common$5;
var rotl32$1 = utils$a.rotl32;
var sum32$2 = utils$a.sum32;
var sum32_5$1 = utils$a.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$4.BlockHash;
var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.W = new Array(80);
}
utils$a.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = rotl32$1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i = 0; i < W2.length; i++) {
    var s2 = ~~(i / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$a.toHex32(this.h, "big");
  else
    return utils$a.split32(this.h, "big");
};
var utils$9 = utils$d;
var common$3 = common$6;
var shaCommon = common$5;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$9.sum32;
var sum32_4$1 = utils$9.sum32_4;
var sum32_5 = utils$9.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$3.BlockHash;
var sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$9.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = sum32_4$1(g1_256(W2[i - 2]), W2[i - 7], g0_256(W2[i - 15]), W2[i - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i = 0; i < W2.length; i++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i], W2[i]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$9.toHex32(this.h, "big");
  else
    return utils$9.split32(this.h, "big");
};
var utils$8 = utils$d;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
utils$8.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$8.split32(this.h.slice(0, 7), "big");
};
var utils$7 = utils$d;
var common$2 = common$6;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$7.rotr64_hi;
var rotr64_lo = utils$7.rotr64_lo;
var shr64_hi = utils$7.shr64_hi;
var shr64_lo = utils$7.shr64_lo;
var sum64 = utils$7.sum64;
var sum64_hi = utils$7.sum64_hi;
var sum64_lo = utils$7.sum64_lo;
var sum64_4_hi = utils$7.sum64_4_hi;
var sum64_4_lo = utils$7.sum64_4_lo;
var sum64_5_hi = utils$7.sum64_5_hi;
var sum64_5_lo = utils$7.sum64_5_lo;
var BlockHash$1 = common$2.BlockHash;
var sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this);
  this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$7.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 32; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i += 2) {
    var c0_hi = g1_512_hi(W2[i - 4], W2[i - 3]);
    var c0_lo = g1_512_lo(W2[i - 4], W2[i - 3]);
    var c1_hi = W2[i - 14];
    var c1_lo = W2[i - 13];
    var c2_hi = g0_512_hi(W2[i - 30], W2[i - 29]);
    var c2_lo = g0_512_lo(W2[i - 30], W2[i - 29]);
    var c3_hi = W2[i - 32];
    var c3_lo = W2[i - 31];
    W2[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W2[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512$2.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch2 = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i = 0; i < W2.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W2[i];
    var c4_lo = W2[i + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch2);
    c1_lo = maj64_lo(ah, al, bh, bl, ch2, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch2, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$2.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$7.toHex32(this.h, "big");
  else
    return utils$7.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh2) {
  var r2 = xh & yh ^ ~xh & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh2) {
  var r2 = xh & yh ^ xh & zh2 ^ yh & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$6 = utils$d;
var SHA512$1 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this);
  this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
utils$6.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$6.split32(this.h.slice(0, 12), "big");
};
sha$1.sha1 = _1;
sha$1.sha224 = _224;
sha$1.sha256 = _256;
sha$1.sha384 = _384;
sha$1.sha512 = _512;
var ripemd = {};
var utils$5 = utils$d;
var common$1 = common$6;
var rotl32 = utils$5.rotl32;
var sum32 = utils$5.sum32;
var sum32_3 = utils$5.sum32_3;
var sum32_4 = utils$5.sum32_4;
var BlockHash = common$1.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$5.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah = A2;
  var Bh = B2;
  var Ch2 = C2;
  var Dh = D2;
  var Eh = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(rotl32(sum32_4(A2, f(j2, B2, C2, D2), msg[r[j2] + start], K$4(j2)), s[j2]), E2);
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(rotl32(sum32_4(Ah, f(79 - j2, Bh, Ch2, Dh), msg[rh[j2] + start], Kh(j2)), sh[j2]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch2, 10);
    Ch2 = Bh;
    Bh = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh);
  this.h[1] = sum32_3(this.h[2], D2, Eh);
  this.h[2] = sum32_3(this.h[3], E2, Ah);
  this.h[3] = sum32_3(this.h[4], A2, Bh);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "little");
  else
    return utils$5.split32(this.h, "little");
};
function f(j2, x2, y2, z2) {
  if (j2 <= 15)
    return x2 ^ y2 ^ z2;
  else if (j2 <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$4(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var utils$4 = utils$d;
var assert$6 = minimalisticAssert$1;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$4.toArray(key2, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i = key2.length; i < this.blockSize; i++)
    key2.push(0);
  for (i = 0; i < key2.length; i++)
    key2[i] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i = 0; i < key2.length; i++)
    key2[i] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports2) {
  var hash2 = exports2;
  hash2.utils = utils$d;
  hash2.common = common$6;
  hash2.sha = sha$1;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$1);
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$e = "sha2/5.7.0";
const logger$d = new Logger(version$e);
function ripemd160(data) {
  return "0x" + hash$1.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256$2(data) {
  return "0x" + hash$1.sha256().update(arrayify(data)).digest("hex");
}
function sha512$1(data) {
  return "0x" + hash$1.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key2, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger$d.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + hash$1.hmac(hash$1[algorithm], arrayify(key2)).update(arrayify(data)).digest("hex");
}
const lib_esm$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  computeHmac,
  ripemd160,
  sha256: sha256$2,
  sha512: sha512$1,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  }
}, Symbol.toStringTag, { value: "Module" }));
function pbkdf2$1(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T2;
  for (let i = 1; i <= l2; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    let U2 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T2 = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r2 = keylen - (l2 - 1) * hLen;
    }
    T2.set(U2);
    for (let j2 = 1; j2 < iterations; j2++) {
      U2 = arrayify(computeHmac(hashAlgorithm, password, U2));
      for (let k2 = 0; k2 < hLen; k2++)
        T2[k2] ^= U2[k2];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l2 ? r2 : hLen;
    DK.set(arrayify(T2).slice(0, len), destPos);
  }
  return hexlify(DK);
}
function createCommonjsModule(fn2, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base3) {
      return commonjsRequire(path, base3 === void 0 || base3 === null ? module2.path : base3);
    }
  }, fn2(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$3;
function assert$3(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$3.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1$1 = createCommonjsModule(function(module2, exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c2 = msg.charCodeAt(i);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero22(msg[i].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode6(arr2, enc) {
    if (enc === "hex")
      return toHex2(arr2);
    else
      return arr2;
  };
});
var utils_1$1$1 = createCommonjsModule(function(module2, exports2) {
  var utils2 = exports2;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1$1.toArray;
  utils2.zero2 = utils_1$1.zero2;
  utils2.toHex = utils_1$1.toHex;
  utils2.encode = utils_1$1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z2;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [[], []];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes3) {
    return typeof bytes3 === "string" ? utils2.toArray(bytes3, "hex") : bytes3;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes3) {
    return new BN$3(bytes3, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1$1.getNAF;
var getJSF = utils_1$1$1.getJSF;
var assert$1$1 = utils_1$1$1.assert;
function BaseCurve(type2, conf) {
  this.type = type2;
  this.p = new BN$3(conf.p, 16);
  this.red = conf.prime ? BN$3.red(conf.prime) : BN$3.mont(this.p);
  this.zero = new BN$3(0).toRed(this.red);
  this.one = new BN$3(1).toRed(this.red);
  this.two = new BN$3(2).toRed(this.red);
  this.n = conf.n && new BN$3(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i = I2; i > 0; i--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l2 = 0; i >= 0 && naf[i] === 0; i--)
      l2++;
    if (i >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i < 0)
      break;
    var z2 = naf[i];
    assert$1$1(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i;
  var j2;
  var p2;
  for (i = 0; i < len; i++) {
    p2 = points[i];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a2 = i - 1;
    var b2 = i;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max2; i >= 0; i--) {
    var k2 = 0;
    while (i >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i--;
    }
    if (i >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type2) {
  this.curve = curve;
  this.type = type2;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
  bytes3 = utils_1$1$1.toArray(bytes3, enc);
  var len = this.p.byteLength();
  if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
    if (bytes3[0] === 6)
      assert$1$1(bytes3[bytes3.length - 1] % 2 === 0);
    else if (bytes3[0] === 7)
      assert$1$1(bytes3[bytes3.length - 1] % 2 === 1);
    var res = this.point(bytes3.slice(1, 1 + len), bytes3.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
    return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact3) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact3)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode3(enc, compact3) {
  return utils_1$1$1.encode(this._encode(compact3), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl3 = max2 === 1 ? null : this.dbl();
  for (var i = 1; i < max2; i++)
    res[i] = res[i - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i = 0; i < k2; i++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module2) {
  if (typeof Object.create === "function") {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2$1 = utils_1$1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new BN$3(conf.a, 16).toRed(this.red);
  this.b = new BN$3(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$3(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$3(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2$1(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$3(vec.a, 16),
        b: new BN$3(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$3.mont(num);
  var tinv = new BN$3(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$3(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$3(1);
  var y1 = new BN$3(0);
  var x2 = new BN$3(0);
  var y2 = new BN$3(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return {
    k1,
    k2: k22
  };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$3(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x2 = point3.x;
  var y2 = point3.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split2 = this._endoSplit(coeffs[i]);
    var p2 = points[i];
    var beta = p2._getBeta();
    if (split2.k1.negative) {
      split2.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split2.k2.negative) {
      split2.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p2;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split2.k1;
    ncoeffs[i * 2 + 1] = split2.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j2 = 0; j2 < i * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point(curve, x2, y2, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$3(x2, 16);
    this.y = new BN$3(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x2, y2, isRed) {
  return new Point(this, x2, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul3(k2) {
  k2 = new BN$3(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x2, y2, z2) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$3(0);
  } else {
    this.x = new BN$3(x2, 16);
    this.y = new BN$3(y2, 16);
    this.z = new BN$3(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y2, z2) {
  return new JPoint(this, x2, y2, z2);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i = 0; i < pow; i++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul4(k2, kbase) {
  k2 = new BN$3(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module2, exports2) {
  var curve = exports2;
  curve.base = base;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module2, exports2) {
  var curves = exports2;
  var assert2 = utils_1$1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$1.sha256,
    gRed: false,
    g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$1.sha256,
    gRed: false,
    g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$1.sha256,
    gRed: false,
    g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$1.sha384,
    gRed: false,
    g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$1.sha512,
    gRed: false,
    g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$1.sha256,
    gRed: false,
    g: ["9"]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$1.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$1.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [{
      a: "3086d221a7d46bcde86c90e49284eb15",
      b: "-e4437ed6010e88286f547fa90abfe4c3"
    }, {
      a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
      b: "3086d221a7d46bcde86c90e49284eb15"
    }],
    gRed: false,
    g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1$1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1$1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1$1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1$1.toArray(entropy, entropyEnc);
  add3 = utils_1$1.toArray(add3, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1$1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1$1.encode(res, enc);
};
var assert$3$1 = utils_1$1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return {
      result: false,
      reason: "Invalid public key"
    };
  if (!pub.validate())
    return {
      result: false,
      reason: "Public key is not a point"
    };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return {
      result: false,
      reason: "Public key * N != O"
    };
  return {
    result: true,
    reason: null
  };
};
KeyPair.prototype.getPublic = function getPublic(compact3, enc) {
  if (typeof compact3 === "string") {
    enc = compact3;
    compact3 = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact3);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$3(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3$1(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3$1(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3$1(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$3(options.r, 16);
  this.s = new BN$3(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength9(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p2.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1$1.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength9(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength9(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength9(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$3(r2);
  this.s = new BN$3(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr2, len) {
  if (len < 128) {
    arr2.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr2.push(octets | 128);
  while (--octets) {
    arr2.push(len >>> (octets << 3) & 255);
  }
  arr2.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr2 = [2];
  constructLength(arr2, r2.length);
  arr2 = arr2.concat(r2);
  arr2.push(2);
  constructLength(arr2, s2.length);
  var backHalf = arr2.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1$1.encode(res, enc);
};
var rand = function() {
  throw new Error("unsupported");
};
var assert$5 = utils_1$1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = {
      curve: options
    };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes3 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$3(2));
  for (; ; ) {
    var priv = new BN$3(drbg.generate(bytes3));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$3(msg, 16));
  var bytes3 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes3);
  var nonce = msg.toArray("be", bytes3);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$3(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new BN$3(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature({
      r: r2,
      s: s2,
      recoveryParam
    });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new BN$3(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$5((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n2 = this.n;
  var e2 = new BN$3(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module2, exports2) {
  var elliptic = exports2;
  elliptic.version = {
    version: "6.5.4"
  }.version;
  elliptic.utils = utils_1$1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;
const version$d = "signing-key/5.7.0";
const logger$c = new Logger(version$d);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$c.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$c.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, {
      canonical: true
    });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = {
    r: arrayify(sig.r),
    s: arrayify(sig.s)
  };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes3 = arrayify(key2);
  if (bytes3.length === 32) {
    const signingKey = new SigningKey(bytes3);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes3).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes3.length === 33) {
    if (compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(false, "hex");
  } else if (bytes3.length === 65) {
    if (!compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(true, "hex");
  }
  return logger$c.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const lib_esm$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SigningKey,
  recoverPublicKey,
  computePublicKey
}, Symbol.toStringTag, { value: "Module" }));
const version$c = "transactions/5.7.0";
const logger$b = new Logger(version$c);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
const transactionFields = [{
  name: "nonce",
  maxLength: 32,
  numeric: true
}, {
  name: "gasPrice",
  maxLength: 32,
  numeric: true
}, {
  name: "gasLimit",
  maxLength: 32,
  numeric: true
}, {
  name: "to",
  length: 20
}, {
  name: "value",
  maxLength: 32,
  numeric: true
}, {
  name: "data"
}];
const allowedTransactionKeys$1 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest9), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$b.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey4, index2) => {
      if (hexDataLength(storageKey4) !== 32) {
        logger$b.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey4);
      }
      return storageKey4.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index2) => {
      if (Array.isArray(set2)) {
        if (set2.length > 2) {
          logger$b.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set2);
        }
        return accessSetify(set2[0], set2[1]);
      }
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey4) => {
      accum[storageKey4] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$b.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [formatNumber(transaction.chainId || 0, "chainId"), formatNumber(transaction.nonce || 0, "nonce"), formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to != null ? getAddress(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x", formatAccessList(transaction.accessList || [])];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$2(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [formatNumber(transaction.chainId || 0, "chainId"), formatNumber(transaction.nonce || 0, "nonce"), formatNumber(transaction.gasPrice || 0, "gasPrice"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to != null ? getAddress(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x", formatAccessList(transaction.accessList || [])];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$2(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys$1);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger$b.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger$b.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger$b.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode$2(raw);
  }
  const sig = splitSignature(signature2);
  let v2 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v2 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v2) {
      logger$b.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v2) {
    logger$b.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v2));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode$2(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger$b.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
  }
  return logger$b.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize2) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$b.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256$1(serialize2(tx));
    tx.from = recoverAddress(digest9, {
      r: tx.r,
      s: tx.s,
      recoveryParam: tx.v
    });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode$2(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$b.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$2(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$b.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$2(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$b.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256$1(encode$2(raw));
    try {
      tx.from = recoverAddress(digest9, {
        r: hexlify(tx.r),
        s: hexlify(tx.s),
        recoveryParam
      });
    } catch (error) {
    }
    tx.hash = keccak256$1(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse$9(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$b.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const lib_esm$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TransactionTypes() {
    return TransactionTypes;
  },
  computeAddress,
  recoverAddress,
  accessListify,
  serialize,
  parse: parse$9
}, Symbol.toStringTag, { value: "Module" }));
const version$b = "wordlists/5.7.0";
const logger$a = new Logger(version$b);
class Wordlist {
  constructor(locale) {
    logger$a.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist2.getWord(i);
      if (i !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index2) {
    loadWords(this);
    return wordlist[index2];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
};
const version$a = "hdnode/5.7.0";
const logger$9 = new Logger(version$a);
const N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat$2([data, hexDataSlice(sha256$2(sha256$2(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger$9.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
const _constructorGuard = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
    if (constructorGuard !== _constructorGuard) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256$2(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index2);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat$2([this.privateKey != null ? "0x0488ADE4" : "0x0488B21E", hexlify(this.depth), this.parentFingerprint, hexZeroPad(hexlify(this.index), 4), this.chainCode, this.privateKey != null ? concat$2(["0x00", this.privateKey]) : this.publicKey]));
  }
  neuter() {
    return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index2) {
    if (index2 > 4294967295) {
      throw new Error("invalid index - " + String(index2));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index2 & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify(this.publicKey));
    }
    for (let i = 24; i >= 0; i -= 8) {
      data[33 + (i >> 3)] = index2 >> 24 - i & 255;
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      if (component.match(/^[0-9]+'$/)) {
        const index2 = parseInt(component.substring(0, component.length - 1));
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index2);
      } else if (component.match(/^[0-9]+$/)) {
        const index2 = parseInt(component);
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index2);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes3 = Base58.decode(extendedKey);
    if (bytes3.length !== 82 || base58check(bytes3.slice(0, 78)) !== extendedKey) {
      logger$9.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes3[4];
    const parentFingerprint = hexlify(bytes3.slice(5, 9));
    const index2 = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes3.slice(13, 45));
    const key2 = bytes3.slice(45, 78);
    switch (hexlify(bytes3.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard, null, hexlify(key2), parentFingerprint, chainCode, index2, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
    }
    return logger$9.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger$9.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    if (index2 === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = arrayify(sha256$2(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum2 !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices2 = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices2[indices2.length - 1] <<= 8;
      indices2[indices2.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices2[indices2.length - 1] <<= remainingBits;
      indices2[indices2.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices2.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = arrayify(sha256$2(entropy))[0] & getUpperMask(checksumBits);
  indices2[indices2.length - 1] <<= checksumBits;
  indices2[indices2.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices2.map((index2) => wordlist2.getWord(index2)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index2) {
  if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
    logger$9.throwArgumentError("invalid account index", "index", index2);
  }
  return `m/44'/60'/${index2}'/0/0`;
}
const lib_esm$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPath,
  HDNode,
  mnemonicToSeed,
  mnemonicToEntropy,
  entropyToMnemonic,
  isValidMnemonic,
  getAccountPath
}, Symbol.toStringTag, { value: "Module" }));
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$6);
var aesJs = { exports: {} };
(function(module2, exports2) {
  (function(root) {
    function checkInt(value) {
      return parseInt(value) === value;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i = 0; i < arrayish.length; i++) {
        if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy2) {
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
        if (copy2) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error("Array contains invalid value: " + arg);
        }
        return new Uint8Array(arg);
      }
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error("unsupported array-like object");
    }
    function createArray(length) {
      return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
      function toBytes(text) {
        var result = [], i = 0;
        text = encodeURI(text);
        while (i < text.length) {
          var c2 = text.charCodeAt(i++);
          if (c2 === 37) {
            result.push(parseInt(text.substr(i, 2), 16));
            i += 2;
          } else {
            result.push(c2);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes3) {
        var result = [], i = 0;
        while (i < bytes3.length) {
          var c2 = bytes3[i];
          if (c2 < 128) {
            result.push(String.fromCharCode(c2));
            i++;
          } else if (c2 > 191 && c2 < 224) {
            result.push(String.fromCharCode((c2 & 31) << 6 | bytes3[i + 1] & 63));
            i += 2;
          } else {
            result.push(String.fromCharCode((c2 & 15) << 12 | (bytes3[i + 1] & 63) << 6 | bytes3[i + 2] & 63));
            i += 3;
          }
        }
        return result.join("");
      }
      return {
        toBytes,
        fromBytes
      };
    }();
    var convertHex = function() {
      function toBytes(text) {
        var result = [];
        for (var i = 0; i < text.length; i += 2) {
          result.push(parseInt(text.substr(i, 2), 16));
        }
        return result;
      }
      var Hex = "0123456789abcdef";
      function fromBytes(bytes3) {
        var result = [];
        for (var i = 0; i < bytes3.length; i++) {
          var v2 = bytes3[i];
          result.push(Hex[(v2 & 240) >> 4] + Hex[v2 & 15]);
        }
        return result.join("");
      }
      return {
        toBytes,
        fromBytes
      };
    }();
    var numberOfRounds = {
      16: 10,
      24: 12,
      32: 14
    };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes3) {
      var result = [];
      for (var i = 0; i < bytes3.length; i += 4) {
        result.push(bytes3[i] << 24 | bytes3[i + 1] << 16 | bytes3[i + 2] << 8 | bytes3[i + 3]);
      }
      return result;
    }
    var AES = function(key2) {
      if (!(this instanceof AES)) {
        throw Error("AES must be instanitated with `new`");
      }
      Object.defineProperty(this, "key", {
        value: coerceArray(key2, true)
      });
      this._prepare();
    };
    AES.prototype._prepare = function() {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      }
      this._Ke = [];
      this._Kd = [];
      for (var i = 0; i <= rounds; i++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      var tk = convertToInt32(this.key);
      var index2;
      for (var i = 0; i < KC; i++) {
        index2 = i >> 2;
        this._Ke[index2][i % 4] = tk[i];
        this._Kd[rounds - index2][i % 4] = tk[i];
      }
      var rconpointer = 0;
      var t2 = KC, tt;
      while (t2 < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        if (KC != 8) {
          for (var i = 1; i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        } else {
          for (var i = 1; i < KC / 2; i++) {
            tk[i] ^= tk[i - 1];
          }
          tt = tk[KC / 2 - 1];
          tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
          for (var i = KC / 2 + 1; i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        }
        var i = 0, r2, c2;
        while (i < KC && t2 < roundKeyCount) {
          r2 = t2 >> 2;
          c2 = t2 % 4;
          this._Ke[r2][c2] = tk[i];
          this._Kd[rounds - r2][c2] = tk[i++];
          t2++;
        }
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var c2 = 0; c2 < 4; c2++) {
          tt = this._Kd[r2][c2];
          this._Kd[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
        }
      }
    };
    AES.prototype.encrypt = function(plaintext) {
      if (plaintext.length != 16) {
        throw new Error("invalid plaintext size (must be 16 bytes)");
      }
      var rounds = this._Ke.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(plaintext);
      for (var i = 0; i < 4; i++) {
        t2[i] ^= this._Ke[0][i];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i = 0; i < 4; i++) {
          a2[i] = T1[t2[i] >> 24 & 255] ^ T2[t2[(i + 1) % 4] >> 16 & 255] ^ T3[t2[(i + 2) % 4] >> 8 & 255] ^ T4[t2[(i + 3) % 4] & 255] ^ this._Ke[r2][i];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Ke[rounds][i];
        result[4 * i] = (S2[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (S2[t2[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (S2[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (S2[t2[(i + 3) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      }
      var rounds = this._Kd.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(ciphertext);
      for (var i = 0; i < 4; i++) {
        t2[i] ^= this._Kd[0][i];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i = 0; i < 4; i++) {
          a2[i] = T5[t2[i] >> 24 & 255] ^ T6[t2[(i + 3) % 4] >> 16 & 255] ^ T7[t2[(i + 2) % 4] >> 8 & 255] ^ T8[t2[(i + 1) % 4] & 255] ^ this._Kd[r2][i];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Kd[rounds][i];
        result[4 * i] = (Si[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (Si[t2[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (Si[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (Si[t2[(i + 1) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    var ModeOfOperationECB = function(key2) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES(key2);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i);
      }
      return plaintext;
    };
    var ModeOfOperationCBC = function(key2, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        for (var j2 = 0; j2 < 16; j2++) {
          block[j2] ^= this._lastCipherblock[j2];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        for (var j2 = 0; j2 < 16; j2++) {
          plaintext[i + j2] = block[j2] ^ this._lastCipherblock[j2];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
      }
      return plaintext;
    };
    var ModeOfOperationCFB = function(key2, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 size)");
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i = 0; i < encrypted.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j2 = 0; j2 < this.segmentSize; j2++) {
          encrypted[i + j2] ^= xorSegment[j2];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i = 0; i < plaintext.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j2 = 0; j2 < this.segmentSize; j2++) {
          plaintext[i + j2] ^= xorSegment[j2];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return plaintext;
    };
    var ModeOfOperationOFB = function(key2, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    var Counter = function(initialValue) {
      if (!(this instanceof Counter)) {
        throw Error("Counter must be instanitated with `new`");
      }
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function(value) {
      if (typeof value !== "number" || parseInt(value) != value) {
        throw new Error("invalid counter value (must be an integer)");
      }
      for (var index2 = 15; index2 >= 0; --index2) {
        this._counter[index2] = value % 256;
        value = value >> 8;
      }
    };
    Counter.prototype.setBytes = function(bytes3) {
      bytes3 = coerceArray(bytes3, true);
      if (bytes3.length != 16) {
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      }
      this._counter = bytes3;
    };
    Counter.prototype.increment = function() {
      for (var i = 15; i >= 0; i--) {
        if (this._counter[i] === 255) {
          this._counter[i] = 0;
        } else {
          this._counter[i]++;
          break;
        }
      }
    };
    var ModeOfOperationCTR = function(key2, counter) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter instanceof Counter)) {
        counter = new Counter(counter);
      }
      this._counter = counter;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    function pkcs7pad(data) {
      data = coerceArray(data, true);
      var padder = 16 - data.length % 16;
      var result = createArray(data.length + padder);
      copyArray(data, result);
      for (var i = data.length; i < result.length; i++) {
        result[i] = padder;
      }
      return result;
    }
    function pkcs7strip(data) {
      data = coerceArray(data, true);
      if (data.length < 16) {
        throw new Error("PKCS#7 invalid length");
      }
      var padder = data[data.length - 1];
      if (padder > 16) {
        throw new Error("PKCS#7 padding byte out of range");
      }
      var length = data.length - padder;
      for (var i = 0; i < padder; i++) {
        if (data[length + i] !== padder) {
          throw new Error("PKCS#7 invalid padding byte");
        }
      }
      var result = createArray(length);
      copyArray(data, result, 0, 0, length);
      return result;
    }
    var aesjs = {
      AES,
      Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray,
        createArray,
        copyArray
      }
    };
    {
      module2.exports = aesjs;
    }
  })();
})(aesJs);
const aes = aesJs.exports;
const version$9 = "json-wallets/5.7.0";
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object2, path) {
  let currentChild = object2;
  const comps = path.toLowerCase().split("/");
  for (let i = 0; i < comps.length; i++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes3 = arrayify(randomBytes2);
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = hexlify(bytes3);
  return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
}
const logger$8 = new Logger(version$9);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
}
function decrypt$2(json2, password) {
  const data = JSON.parse(json2);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger$8.throwArgumentError("invalid encseed", "json", json2);
  }
  const key2 = arrayify(pbkdf2$1(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new aes.ModeOfOperation.cbc(key2, iv);
  const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256$1(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
function isCrowdsaleWallet(json2) {
  let data = null;
  try {
    data = JSON.parse(json2);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json2) {
  let data = null;
  try {
    data = JSON.parse(json2);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json2) {
  if (isCrowdsaleWallet(json2)) {
    try {
      return getAddress(JSON.parse(json2).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json2)) {
    try {
      return getAddress(JSON.parse(json2).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var scrypt$1 = { exports: {} };
(function(module2, exports2) {
  (function(root) {
    const MAX_VALUE = 2147483647;
    function SHA2562(m2) {
      const K2 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
      let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
      let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
      const w2 = new Uint32Array(64);
      function blocks(p3) {
        let off = 0, len = p3.length;
        while (len >= 64) {
          let a2 = h0, b2 = h1, c2 = h2, d2 = h3, e2 = h4, f2 = h5, g2 = h6, h8 = h7, u2, i2, j2, t1, t2;
          for (i2 = 0; i2 < 16; i2++) {
            j2 = off + i2 * 4;
            w2[i2] = (p3[j2] & 255) << 24 | (p3[j2 + 1] & 255) << 16 | (p3[j2 + 2] & 255) << 8 | p3[j2 + 3] & 255;
          }
          for (i2 = 16; i2 < 64; i2++) {
            u2 = w2[i2 - 2];
            t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
            u2 = w2[i2 - 15];
            t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
            w2[i2] = (t1 + w2[i2 - 7] | 0) + (t2 + w2[i2 - 16] | 0) | 0;
          }
          for (i2 = 0; i2 < 64; i2++) {
            t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h8 + (K2[i2] + w2[i2] | 0) | 0) | 0;
            t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
            h8 = g2;
            g2 = f2;
            f2 = e2;
            e2 = d2 + t1 | 0;
            d2 = c2;
            c2 = b2;
            b2 = a2;
            a2 = t1 + t2 | 0;
          }
          h0 = h0 + a2 | 0;
          h1 = h1 + b2 | 0;
          h2 = h2 + c2 | 0;
          h3 = h3 + d2 | 0;
          h4 = h4 + e2 | 0;
          h5 = h5 + f2 | 0;
          h6 = h6 + g2 | 0;
          h7 = h7 + h8 | 0;
          off += 64;
          len -= 64;
        }
      }
      blocks(m2);
      let i, bytesLeft = m2.length % 64, bitLenHi = m2.length / 536870912 | 0, bitLenLo = m2.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m2.slice(m2.length - bytesLeft, m2.length);
      p2.push(128);
      for (i = bytesLeft + 1; i < numZeros; i++) {
        p2.push(0);
      }
      p2.push(bitLenHi >>> 24 & 255);
      p2.push(bitLenHi >>> 16 & 255);
      p2.push(bitLenHi >>> 8 & 255);
      p2.push(bitLenHi >>> 0 & 255);
      p2.push(bitLenLo >>> 24 & 255);
      p2.push(bitLenLo >>> 16 & 255);
      p2.push(bitLenLo >>> 8 & 255);
      p2.push(bitLenLo >>> 0 & 255);
      blocks(p2);
      return [h0 >>> 24 & 255, h0 >>> 16 & 255, h0 >>> 8 & 255, h0 >>> 0 & 255, h1 >>> 24 & 255, h1 >>> 16 & 255, h1 >>> 8 & 255, h1 >>> 0 & 255, h2 >>> 24 & 255, h2 >>> 16 & 255, h2 >>> 8 & 255, h2 >>> 0 & 255, h3 >>> 24 & 255, h3 >>> 16 & 255, h3 >>> 8 & 255, h3 >>> 0 & 255, h4 >>> 24 & 255, h4 >>> 16 & 255, h4 >>> 8 & 255, h4 >>> 0 & 255, h5 >>> 24 & 255, h5 >>> 16 & 255, h5 >>> 8 & 255, h5 >>> 0 & 255, h6 >>> 24 & 255, h6 >>> 16 & 255, h6 >>> 8 & 255, h6 >>> 0 & 255, h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 >>> 0 & 255];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      password = password.length <= 64 ? password : SHA2562(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i;
      let dk = [];
      for (i = 0; i < 64; i++) {
        inner[i] = 54;
      }
      for (i = 0; i < password.length; i++) {
        inner[i] ^= password[i];
      }
      for (i = 0; i < salt.length; i++) {
        inner[64 + i] = salt[i];
      }
      for (i = innerLen - 4; i < innerLen; i++) {
        inner[i] = 0;
      }
      for (i = 0; i < 64; i++)
        outerKey[i] = 92;
      for (i = 0; i < password.length; i++)
        outerKey[i] ^= password[i];
      function incrementCounter() {
        for (let i2 = innerLen - 1; i2 >= innerLen - 4; i2--) {
          inner[i2]++;
          if (inner[i2] <= 255)
            return;
          inner[i2] = 0;
        }
      }
      while (dkLen >= 32) {
        incrementCounter();
        dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter();
        dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
      }
      return dk;
    }
    function blockmix_salsa8(BY, Yi, r2, x2, _X) {
      let i;
      arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
      for (i = 0; i < 2 * r2; i++) {
        blockxor(BY, i * 16, _X, 16);
        salsa20_8(_X, x2);
        arraycopy(_X, 0, BY, Yi + i * 16, 16);
      }
      for (i = 0; i < r2; i++) {
        arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
      }
      for (i = 0; i < r2; i++) {
        arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r2) * 16, 16);
      }
    }
    function R2(a2, b2) {
      return a2 << b2 | a2 >>> 32 - b2;
    }
    function salsa20_8(B2, x2) {
      arraycopy(B2, 0, x2, 0, 16);
      for (let i = 8; i > 0; i -= 2) {
        x2[4] ^= R2(x2[0] + x2[12], 7);
        x2[8] ^= R2(x2[4] + x2[0], 9);
        x2[12] ^= R2(x2[8] + x2[4], 13);
        x2[0] ^= R2(x2[12] + x2[8], 18);
        x2[9] ^= R2(x2[5] + x2[1], 7);
        x2[13] ^= R2(x2[9] + x2[5], 9);
        x2[1] ^= R2(x2[13] + x2[9], 13);
        x2[5] ^= R2(x2[1] + x2[13], 18);
        x2[14] ^= R2(x2[10] + x2[6], 7);
        x2[2] ^= R2(x2[14] + x2[10], 9);
        x2[6] ^= R2(x2[2] + x2[14], 13);
        x2[10] ^= R2(x2[6] + x2[2], 18);
        x2[3] ^= R2(x2[15] + x2[11], 7);
        x2[7] ^= R2(x2[3] + x2[15], 9);
        x2[11] ^= R2(x2[7] + x2[3], 13);
        x2[15] ^= R2(x2[11] + x2[7], 18);
        x2[1] ^= R2(x2[0] + x2[3], 7);
        x2[2] ^= R2(x2[1] + x2[0], 9);
        x2[3] ^= R2(x2[2] + x2[1], 13);
        x2[0] ^= R2(x2[3] + x2[2], 18);
        x2[6] ^= R2(x2[5] + x2[4], 7);
        x2[7] ^= R2(x2[6] + x2[5], 9);
        x2[4] ^= R2(x2[7] + x2[6], 13);
        x2[5] ^= R2(x2[4] + x2[7], 18);
        x2[11] ^= R2(x2[10] + x2[9], 7);
        x2[8] ^= R2(x2[11] + x2[10], 9);
        x2[9] ^= R2(x2[8] + x2[11], 13);
        x2[10] ^= R2(x2[9] + x2[8], 18);
        x2[12] ^= R2(x2[15] + x2[14], 7);
        x2[13] ^= R2(x2[12] + x2[15], 9);
        x2[14] ^= R2(x2[13] + x2[12], 13);
        x2[15] ^= R2(x2[14] + x2[13], 18);
      }
      for (let i = 0; i < 16; ++i) {
        B2[i] += x2[i];
      }
    }
    function blockxor(S2, Si, D2, len) {
      for (let i = 0; i < len; i++) {
        D2[i] ^= S2[Si + i];
      }
    }
    function arraycopy(src6, srcPos, dest, destPos, length) {
      while (length--) {
        dest[destPos++] = src6[srcPos++];
      }
    }
    function checkBufferish(o2) {
      if (!o2 || typeof o2.length !== "number") {
        return false;
      }
      for (let i = 0; i < o2.length; i++) {
        const v2 = o2[i];
        if (typeof v2 !== "number" || v2 % 1 || v2 < 0 || v2 >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value, name2) {
      if (typeof value !== "number" || value % 1) {
        throw new Error("invalid " + name2);
      }
      return value;
    }
    function _scrypt(password, salt, N2, r2, p2, dkLen, callback) {
      N2 = ensureInteger(N2, "N");
      r2 = ensureInteger(r2, "r");
      p2 = ensureInteger(p2, "p");
      dkLen = ensureInteger(dkLen, "dkLen");
      if (N2 === 0 || (N2 & N2 - 1) !== 0) {
        throw new Error("N must be power of 2");
      }
      if (N2 > MAX_VALUE / 128 / r2) {
        throw new Error("N too large");
      }
      if (r2 > MAX_VALUE / 128 / p2) {
        throw new Error("r too large");
      }
      if (!checkBufferish(password)) {
        throw new Error("password must be an array or buffer");
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error("salt must be an array or buffer");
      }
      salt = Array.prototype.slice.call(salt);
      let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p2 * 128 * r2);
      const B2 = new Uint32Array(p2 * 32 * r2);
      for (let i = 0; i < B2.length; i++) {
        const j2 = i * 4;
        B2[i] = (b2[j2 + 3] & 255) << 24 | (b2[j2 + 2] & 255) << 16 | (b2[j2 + 1] & 255) << 8 | (b2[j2 + 0] & 255) << 0;
      }
      const XY = new Uint32Array(64 * r2);
      const V2 = new Uint32Array(32 * r2 * N2);
      const Yi = 32 * r2;
      const x2 = new Uint32Array(16);
      const _X = new Uint32Array(16);
      const totalOps = p2 * N2 * 2;
      let currentOp = 0;
      let lastPercent10 = null;
      let stop = false;
      let state2 = 0;
      let i0 = 0, i1;
      let Bi;
      const limit = callback ? parseInt(1e3 / r2) : 4294967295;
      const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      const incrementalSMix = function() {
        if (stop) {
          return callback(new Error("cancelled"), currentOp / totalOps);
        }
        let steps;
        switch (state2) {
          case 0:
            Bi = i0 * 32 * r2;
            arraycopy(B2, Bi, XY, 0, Yi);
            state2 = 1;
            i1 = 0;
          case 1:
            steps = N2 - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0; i < steps; i++) {
              arraycopy(XY, 0, V2, (i1 + i) * Yi, Yi);
              blockmix_salsa8(XY, Yi, r2, x2, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N2) {
              break;
            }
            i1 = 0;
            state2 = 2;
          case 2:
            steps = N2 - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0; i < steps; i++) {
              const offset = (2 * r2 - 1) * 16;
              const j2 = XY[offset] & N2 - 1;
              blockxor(V2, j2 * Yi, XY, Yi);
              blockmix_salsa8(XY, Yi, r2, x2, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N2) {
              break;
            }
            arraycopy(XY, 0, B2, Bi, Yi);
            i0++;
            if (i0 < p2) {
              state2 = 0;
              break;
            }
            b2 = [];
            for (let i = 0; i < B2.length; i++) {
              b2.push(B2[i] >> 0 & 255);
              b2.push(B2[i] >> 8 & 255);
              b2.push(B2[i] >> 16 & 255);
              b2.push(B2[i] >> 24 & 255);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
            if (callback) {
              callback(null, 1, derivedKey);
            }
            return derivedKey;
        }
        if (callback) {
          nextTick(incrementalSMix);
        }
      };
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != void 0) {
            return derivedKey;
          }
        }
      }
      incrementalSMix();
    }
    const lib2 = {
      scrypt: function(password, salt, N2, r2, p2, dkLen, progressCallback) {
        return new Promise(function(resolve, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N2, r2, p2, dkLen, function(error, progress, key2) {
            if (error) {
              reject(error);
            } else if (key2) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve(new Uint8Array(key2));
            } else if (progressCallback && progress !== lastProgress) {
              lastProgress = progress;
              return progressCallback(progress);
            }
          });
        });
      },
      syncScrypt: function(password, salt, N2, r2, p2, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N2, r2, p2, dkLen));
      }
    };
    {
      module2.exports = lib2;
    }
  })();
})(scrypt$1);
const scrypt = scrypt$1.exports;
const version$8 = "random/5.7.0";
const logger$7 = new Logger(version$8);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto$1 || !crypto$1.getRandomValues) {
  logger$7.warn("WARNING: Missing strong random number source");
  crypto$1 = {
    getRandomValues: function(buffer2) {
      return logger$7.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger$7.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return arrayify(result);
}
function shuffled(array2) {
  array2 = array2.slice();
  for (let i = array2.length - 1; i > 0; i--) {
    const j2 = Math.floor(Math.random() * (i + 1));
    const tmp = array2[i];
    array2[i] = array2[j2];
    array2[j2] = tmp;
  }
  return array2;
}
const lib_esm$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomBytes,
  shuffled
}, Symbol.toStringTag, { value: "Module" }));
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$6 = new Logger(version$9);
function hasMnemonic$1(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256$1(concat$2([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger$6.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new aes.Counter(mnemonicIv);
    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc) {
  return arrayify(pbkdf2$1(passwordBytes, salt, count2, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count2, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name2, value) {
      return logger$6.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N2 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p2 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N2 || !r2 || !p2) {
        throwError2("kdf", kdf);
      }
      if ((N2 & N2 - 1) !== 0) {
        throwError2("N", N2);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N2, r2, p2, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count2 = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count2, dkLen, prfFunc);
    }
  }
  return logger$6.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json2, password) {
  const data = JSON.parse(json2);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt$1(json2, password, progressCallback) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const data = JSON.parse(json2);
    const key2 = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt$1(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic$1(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic$1(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N2 = 1 << 17, r2 = 8, p2 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p2 = options.scrypt.p;
    }
  }
  return scrypt.scrypt(passwordBytes, salt, N2, r2, p2, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256$1(concat$2([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N2,
          dklen: 32,
          p: p2,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new aes.Counter(mnemonicIv);
      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now = new Date();
      const timestamp2 = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp2 + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
function decryptJsonWallet(json2, password, progressCallback) {
  if (isCrowdsaleWallet(json2)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt$2(json2, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json2)) {
    return decrypt$1(json2, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json2, password) {
  if (isCrowdsaleWallet(json2)) {
    return decrypt$2(json2, password);
  }
  if (isKeystoreWallet(json2)) {
    return decryptSync(json2, password);
  }
  throw new Error("invalid JSON wallet");
}
const lib_esm$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decryptCrowdsale: decrypt$2,
  decryptKeystore: decrypt$1,
  decryptKeystoreSync: decryptSync,
  encryptKeystore: encrypt$1,
  isCrowdsaleWallet,
  isKeystoreWallet,
  getJsonWalletAddress,
  decryptJsonWallet,
  decryptJsonWalletSync
}, Symbol.toStringTag, { value: "Module" }));
const require$$7$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$4);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$h);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$k);
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$9);
const version$7 = "solidity/5.7.0";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$5 = new Logger(version$7);
function _pack(type2, value, isArray2) {
  switch (type2) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type2.match(regexNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    if (match[2] && String(size2) !== match[2] || size2 % 8 !== 0 || size2 === 0 || size2 > 256) {
      logger$5.throwArgumentError("invalid number type", "type", type2);
    }
    if (isArray2) {
      size2 = 256;
    }
    value = BigNumber.from(value).toTwos(size2);
    return zeroPad(value, size2 / 8);
  }
  match = type2.match(regexBytes);
  if (match) {
    const size2 = parseInt(match[1]);
    if (String(size2) !== match[1] || size2 === 0 || size2 > 32) {
      logger$5.throwArgumentError("invalid bytes type", "type", type2);
    }
    if (arrayify(value).byteLength !== size2) {
      logger$5.throwArgumentError(`invalid value for ${type2}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type2.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value.length));
    if (count2 != value.length) {
      logger$5.throwArgumentError(`invalid array length for ${type2}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat$2(result);
  }
  return logger$5.throwArgumentError("invalid type", "type", type2);
}
function pack(types2, values) {
  if (types2.length != values.length) {
    logger$5.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types2.forEach(function(type2, index2) {
    tight.push(_pack(type2, values[index2]));
  });
  return hexlify(concat$2(tight));
}
function keccak256(types2, values) {
  return keccak256$1(pack(types2, values));
}
function sha256$1(types2, values) {
  return sha256$2(pack(types2, values));
}
const lib_esm$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pack,
  keccak256,
  sha256: sha256$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$3);
const require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$5);
const require$$13 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$i);
const require$$14 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$g);
const require$$15 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$8);
const require$$16 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$e);
const require$$17 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$7);
const version$6 = "units/5.7.0";
const logger$4 = new Logger(version$6);
const names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger$4.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index2 = whole.length - 3;
      formatted.unshift(whole.substring(index2));
      whole = whole.substring(0, index2);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger$4.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
const lib_esm$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commify,
  formatUnits,
  parseUnits,
  formatEther,
  parseEther
}, Symbol.toStringTag, { value: "Module" }));
const require$$18 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$2);
const version$5 = "abstract-provider/5.7.0";
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$3 = new Logger(version$5);
class Provider {
  constructor() {
    logger$3.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$4(this, void 0, void 0, function* () {
      const {
        block,
        gasPrice
      } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return {
        lastBaseFeePerGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        gasPrice
      };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$4 = "abstract-signer/5.7.0";
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$2 = new Logger(version$4);
const allowedTransactionKeys = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"];
const forwardErrors = [Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED];
class Signer {
  constructor() {
    logger$2.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys.indexOf(key2) === -1) {
        logger$2.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([Promise.resolve(tx.from), this.getAddress()]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$2.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$3(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$2.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$2.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$2.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$2.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$2.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$2.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([Promise.resolve(tx.chainId), this.getChainId()]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$2.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger$2.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
const version$3 = "wallet/5.7.0";
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$1 = new Logger(version$3);
function isAccount(value) {
  return value != null && isHexString$2(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
class Wallet extends Signer {
  constructor(privateKey, provider) {
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger$1.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger$1.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger$1.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger$1.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger$1.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256$1(serialize(tx)));
      return serialize(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain2, types2, value) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types2, value, (name2) => {
        if (this.provider == null) {
          logger$1.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types2, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt$1(this, password, options, progressCallback);
  }
  static createRandom(options) {
    let entropy = randomBytes(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256$1(concat$2([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json2, password, progressCallback) {
    return decryptJsonWallet(json2, password, progressCallback).then((account) => {
      return new Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json2, password) {
    return new Wallet(decryptJsonWalletSync(json2, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain2, types2, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain2, types2, value), signature2);
}
const lib_esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Wallet,
  verifyMessage,
  verifyTypedData
}, Symbol.toStringTag, { value: "Module" }));
const require$$19 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1);
const version$2 = "web/5.7.1";
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$1(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger = new Logger(version$2);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type2) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type2 && (type2.split("/")[0] === "text" || type2.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = {
          key: key2,
          value: String(connection.headers[key2])
        };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, {
          argument: "url",
          url,
          user: connection.user,
          password: "[REDACTED]"
        });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$1(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "content-type": dataMatch[1] || "text/plain"
        },
        body: dataMatch[2] ? decode$1(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
      };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = {
        key: "Content-Length",
        value: String(body.length)
      };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return {
      promise,
      cancel
    };
  }();
  const runningFetch = function() {
    return __awaiter(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall = parseInt(retryAfter) * 1e3;
                } else {
                  stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json2, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json2 != null) {
    body = toUtf8Bytes(json2);
    const updated = typeof connection === "string" ? {
      url: connection
    } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = {
        "content-type": "application/json"
      };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func2, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done2 = false;
    const cancel = () => {
      if (done2) {
        return false;
      }
      done2 = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func2().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done2) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fetchData,
  fetchJson,
  poll
}, Symbol.toStringTag, { value: "Module" }));
const require$$20 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, {
      enumerable: true,
      get: function() {
        return m2[k2];
      }
    });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", {
      enumerable: true,
      value: v2
    });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.formatBytes32String = exports2.Utf8ErrorFuncs = exports2.toUtf8String = exports2.toUtf8CodePoints = exports2.toUtf8Bytes = exports2._toEscapedUtf8String = exports2.nameprep = exports2.hexDataSlice = exports2.hexDataLength = exports2.hexZeroPad = exports2.hexValue = exports2.hexStripZeros = exports2.hexConcat = exports2.isHexString = exports2.hexlify = exports2.base64 = exports2.base58 = exports2.TransactionDescription = exports2.LogDescription = exports2.Interface = exports2.SigningKey = exports2.HDNode = exports2.defaultPath = exports2.isBytesLike = exports2.isBytes = exports2.zeroPad = exports2.stripZeros = exports2.concat = exports2.arrayify = exports2.shallowCopy = exports2.resolveProperties = exports2.getStatic = exports2.defineReadOnly = exports2.deepCopy = exports2.checkProperties = exports2.poll = exports2.fetchJson = exports2._fetchData = exports2.RLP = exports2.Logger = exports2.checkResultErrors = exports2.FormatTypes = exports2.ParamType = exports2.FunctionFragment = exports2.EventFragment = exports2.ErrorFragment = exports2.ConstructorFragment = exports2.Fragment = exports2.defaultAbiCoder = exports2.AbiCoder = void 0;
  exports2.Indexed = exports2.Utf8ErrorReason = exports2.UnicodeNormalizationForm = exports2.SupportedAlgorithm = exports2.mnemonicToSeed = exports2.isValidMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.getAccountPath = exports2.verifyTypedData = exports2.verifyMessage = exports2.recoverPublicKey = exports2.computePublicKey = exports2.recoverAddress = exports2.computeAddress = exports2.getJsonWalletAddress = exports2.TransactionTypes = exports2.serializeTransaction = exports2.parseTransaction = exports2.accessListify = exports2.joinSignature = exports2.splitSignature = exports2.soliditySha256 = exports2.solidityKeccak256 = exports2.solidityPack = exports2.shuffled = exports2.randomBytes = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = exports2.keccak256 = exports2.computeHmac = exports2.commify = exports2.parseUnits = exports2.formatUnits = exports2.parseEther = exports2.formatEther = exports2.isAddress = exports2.getCreate2Address = exports2.getContractAddress = exports2.getIcapAddress = exports2.getAddress = exports2._TypedDataEncoder = exports2.id = exports2.isValidName = exports2.namehash = exports2.hashMessage = exports2.dnsEncode = exports2.parseBytes32String = void 0;
  var abi_1 = require$$0$2;
  Object.defineProperty(exports2, "AbiCoder", {
    enumerable: true,
    get: function() {
      return abi_1.AbiCoder;
    }
  });
  Object.defineProperty(exports2, "checkResultErrors", {
    enumerable: true,
    get: function() {
      return abi_1.checkResultErrors;
    }
  });
  Object.defineProperty(exports2, "ConstructorFragment", {
    enumerable: true,
    get: function() {
      return abi_1.ConstructorFragment;
    }
  });
  Object.defineProperty(exports2, "defaultAbiCoder", {
    enumerable: true,
    get: function() {
      return abi_1.defaultAbiCoder;
    }
  });
  Object.defineProperty(exports2, "ErrorFragment", {
    enumerable: true,
    get: function() {
      return abi_1.ErrorFragment;
    }
  });
  Object.defineProperty(exports2, "EventFragment", {
    enumerable: true,
    get: function() {
      return abi_1.EventFragment;
    }
  });
  Object.defineProperty(exports2, "FormatTypes", {
    enumerable: true,
    get: function() {
      return abi_1.FormatTypes;
    }
  });
  Object.defineProperty(exports2, "Fragment", {
    enumerable: true,
    get: function() {
      return abi_1.Fragment;
    }
  });
  Object.defineProperty(exports2, "FunctionFragment", {
    enumerable: true,
    get: function() {
      return abi_1.FunctionFragment;
    }
  });
  Object.defineProperty(exports2, "Indexed", {
    enumerable: true,
    get: function() {
      return abi_1.Indexed;
    }
  });
  Object.defineProperty(exports2, "Interface", {
    enumerable: true,
    get: function() {
      return abi_1.Interface;
    }
  });
  Object.defineProperty(exports2, "LogDescription", {
    enumerable: true,
    get: function() {
      return abi_1.LogDescription;
    }
  });
  Object.defineProperty(exports2, "ParamType", {
    enumerable: true,
    get: function() {
      return abi_1.ParamType;
    }
  });
  Object.defineProperty(exports2, "TransactionDescription", {
    enumerable: true,
    get: function() {
      return abi_1.TransactionDescription;
    }
  });
  var address_1 = require$$1$3;
  Object.defineProperty(exports2, "getAddress", {
    enumerable: true,
    get: function() {
      return address_1.getAddress;
    }
  });
  Object.defineProperty(exports2, "getCreate2Address", {
    enumerable: true,
    get: function() {
      return address_1.getCreate2Address;
    }
  });
  Object.defineProperty(exports2, "getContractAddress", {
    enumerable: true,
    get: function() {
      return address_1.getContractAddress;
    }
  });
  Object.defineProperty(exports2, "getIcapAddress", {
    enumerable: true,
    get: function() {
      return address_1.getIcapAddress;
    }
  });
  Object.defineProperty(exports2, "isAddress", {
    enumerable: true,
    get: function() {
      return address_1.isAddress;
    }
  });
  var base642 = __importStar2(require$$2$2);
  exports2.base64 = base642;
  var basex_1 = require$$3;
  Object.defineProperty(exports2, "base58", {
    enumerable: true,
    get: function() {
      return basex_1.Base58;
    }
  });
  var bytes_12 = require$$4;
  Object.defineProperty(exports2, "arrayify", {
    enumerable: true,
    get: function() {
      return bytes_12.arrayify;
    }
  });
  Object.defineProperty(exports2, "concat", {
    enumerable: true,
    get: function() {
      return bytes_12.concat;
    }
  });
  Object.defineProperty(exports2, "hexConcat", {
    enumerable: true,
    get: function() {
      return bytes_12.hexConcat;
    }
  });
  Object.defineProperty(exports2, "hexDataSlice", {
    enumerable: true,
    get: function() {
      return bytes_12.hexDataSlice;
    }
  });
  Object.defineProperty(exports2, "hexDataLength", {
    enumerable: true,
    get: function() {
      return bytes_12.hexDataLength;
    }
  });
  Object.defineProperty(exports2, "hexlify", {
    enumerable: true,
    get: function() {
      return bytes_12.hexlify;
    }
  });
  Object.defineProperty(exports2, "hexStripZeros", {
    enumerable: true,
    get: function() {
      return bytes_12.hexStripZeros;
    }
  });
  Object.defineProperty(exports2, "hexValue", {
    enumerable: true,
    get: function() {
      return bytes_12.hexValue;
    }
  });
  Object.defineProperty(exports2, "hexZeroPad", {
    enumerable: true,
    get: function() {
      return bytes_12.hexZeroPad;
    }
  });
  Object.defineProperty(exports2, "isBytes", {
    enumerable: true,
    get: function() {
      return bytes_12.isBytes;
    }
  });
  Object.defineProperty(exports2, "isBytesLike", {
    enumerable: true,
    get: function() {
      return bytes_12.isBytesLike;
    }
  });
  Object.defineProperty(exports2, "isHexString", {
    enumerable: true,
    get: function() {
      return bytes_12.isHexString;
    }
  });
  Object.defineProperty(exports2, "joinSignature", {
    enumerable: true,
    get: function() {
      return bytes_12.joinSignature;
    }
  });
  Object.defineProperty(exports2, "zeroPad", {
    enumerable: true,
    get: function() {
      return bytes_12.zeroPad;
    }
  });
  Object.defineProperty(exports2, "splitSignature", {
    enumerable: true,
    get: function() {
      return bytes_12.splitSignature;
    }
  });
  Object.defineProperty(exports2, "stripZeros", {
    enumerable: true,
    get: function() {
      return bytes_12.stripZeros;
    }
  });
  var hash_1 = require$$5;
  Object.defineProperty(exports2, "_TypedDataEncoder", {
    enumerable: true,
    get: function() {
      return hash_1._TypedDataEncoder;
    }
  });
  Object.defineProperty(exports2, "dnsEncode", {
    enumerable: true,
    get: function() {
      return hash_1.dnsEncode;
    }
  });
  Object.defineProperty(exports2, "hashMessage", {
    enumerable: true,
    get: function() {
      return hash_1.hashMessage;
    }
  });
  Object.defineProperty(exports2, "id", {
    enumerable: true,
    get: function() {
      return hash_1.id;
    }
  });
  Object.defineProperty(exports2, "isValidName", {
    enumerable: true,
    get: function() {
      return hash_1.isValidName;
    }
  });
  Object.defineProperty(exports2, "namehash", {
    enumerable: true,
    get: function() {
      return hash_1.namehash;
    }
  });
  var hdnode_1 = require$$6;
  Object.defineProperty(exports2, "defaultPath", {
    enumerable: true,
    get: function() {
      return hdnode_1.defaultPath;
    }
  });
  Object.defineProperty(exports2, "entropyToMnemonic", {
    enumerable: true,
    get: function() {
      return hdnode_1.entropyToMnemonic;
    }
  });
  Object.defineProperty(exports2, "getAccountPath", {
    enumerable: true,
    get: function() {
      return hdnode_1.getAccountPath;
    }
  });
  Object.defineProperty(exports2, "HDNode", {
    enumerable: true,
    get: function() {
      return hdnode_1.HDNode;
    }
  });
  Object.defineProperty(exports2, "isValidMnemonic", {
    enumerable: true,
    get: function() {
      return hdnode_1.isValidMnemonic;
    }
  });
  Object.defineProperty(exports2, "mnemonicToEntropy", {
    enumerable: true,
    get: function() {
      return hdnode_1.mnemonicToEntropy;
    }
  });
  Object.defineProperty(exports2, "mnemonicToSeed", {
    enumerable: true,
    get: function() {
      return hdnode_1.mnemonicToSeed;
    }
  });
  var json_wallets_1 = require$$7$1;
  Object.defineProperty(exports2, "getJsonWalletAddress", {
    enumerable: true,
    get: function() {
      return json_wallets_1.getJsonWalletAddress;
    }
  });
  var keccak256_1 = require$$8;
  Object.defineProperty(exports2, "keccak256", {
    enumerable: true,
    get: function() {
      return keccak256_1.keccak256;
    }
  });
  var logger_1 = require$$9;
  Object.defineProperty(exports2, "Logger", {
    enumerable: true,
    get: function() {
      return logger_1.Logger;
    }
  });
  var sha2_1 = require$$10;
  Object.defineProperty(exports2, "computeHmac", {
    enumerable: true,
    get: function() {
      return sha2_1.computeHmac;
    }
  });
  Object.defineProperty(exports2, "ripemd160", {
    enumerable: true,
    get: function() {
      return sha2_1.ripemd160;
    }
  });
  Object.defineProperty(exports2, "sha256", {
    enumerable: true,
    get: function() {
      return sha2_1.sha256;
    }
  });
  Object.defineProperty(exports2, "sha512", {
    enumerable: true,
    get: function() {
      return sha2_1.sha512;
    }
  });
  var solidity_1 = require$$11;
  Object.defineProperty(exports2, "solidityKeccak256", {
    enumerable: true,
    get: function() {
      return solidity_1.keccak256;
    }
  });
  Object.defineProperty(exports2, "solidityPack", {
    enumerable: true,
    get: function() {
      return solidity_1.pack;
    }
  });
  Object.defineProperty(exports2, "soliditySha256", {
    enumerable: true,
    get: function() {
      return solidity_1.sha256;
    }
  });
  var random_1 = require$$12;
  Object.defineProperty(exports2, "randomBytes", {
    enumerable: true,
    get: function() {
      return random_1.randomBytes;
    }
  });
  Object.defineProperty(exports2, "shuffled", {
    enumerable: true,
    get: function() {
      return random_1.shuffled;
    }
  });
  var properties_1 = require$$13;
  Object.defineProperty(exports2, "checkProperties", {
    enumerable: true,
    get: function() {
      return properties_1.checkProperties;
    }
  });
  Object.defineProperty(exports2, "deepCopy", {
    enumerable: true,
    get: function() {
      return properties_1.deepCopy;
    }
  });
  Object.defineProperty(exports2, "defineReadOnly", {
    enumerable: true,
    get: function() {
      return properties_1.defineReadOnly;
    }
  });
  Object.defineProperty(exports2, "getStatic", {
    enumerable: true,
    get: function() {
      return properties_1.getStatic;
    }
  });
  Object.defineProperty(exports2, "resolveProperties", {
    enumerable: true,
    get: function() {
      return properties_1.resolveProperties;
    }
  });
  Object.defineProperty(exports2, "shallowCopy", {
    enumerable: true,
    get: function() {
      return properties_1.shallowCopy;
    }
  });
  var RLP = __importStar2(require$$14);
  exports2.RLP = RLP;
  var signing_key_1 = require$$15;
  Object.defineProperty(exports2, "computePublicKey", {
    enumerable: true,
    get: function() {
      return signing_key_1.computePublicKey;
    }
  });
  Object.defineProperty(exports2, "recoverPublicKey", {
    enumerable: true,
    get: function() {
      return signing_key_1.recoverPublicKey;
    }
  });
  Object.defineProperty(exports2, "SigningKey", {
    enumerable: true,
    get: function() {
      return signing_key_1.SigningKey;
    }
  });
  var strings_1 = require$$16;
  Object.defineProperty(exports2, "formatBytes32String", {
    enumerable: true,
    get: function() {
      return strings_1.formatBytes32String;
    }
  });
  Object.defineProperty(exports2, "nameprep", {
    enumerable: true,
    get: function() {
      return strings_1.nameprep;
    }
  });
  Object.defineProperty(exports2, "parseBytes32String", {
    enumerable: true,
    get: function() {
      return strings_1.parseBytes32String;
    }
  });
  Object.defineProperty(exports2, "_toEscapedUtf8String", {
    enumerable: true,
    get: function() {
      return strings_1._toEscapedUtf8String;
    }
  });
  Object.defineProperty(exports2, "toUtf8Bytes", {
    enumerable: true,
    get: function() {
      return strings_1.toUtf8Bytes;
    }
  });
  Object.defineProperty(exports2, "toUtf8CodePoints", {
    enumerable: true,
    get: function() {
      return strings_1.toUtf8CodePoints;
    }
  });
  Object.defineProperty(exports2, "toUtf8String", {
    enumerable: true,
    get: function() {
      return strings_1.toUtf8String;
    }
  });
  Object.defineProperty(exports2, "Utf8ErrorFuncs", {
    enumerable: true,
    get: function() {
      return strings_1.Utf8ErrorFuncs;
    }
  });
  var transactions_1 = require$$17;
  Object.defineProperty(exports2, "accessListify", {
    enumerable: true,
    get: function() {
      return transactions_1.accessListify;
    }
  });
  Object.defineProperty(exports2, "computeAddress", {
    enumerable: true,
    get: function() {
      return transactions_1.computeAddress;
    }
  });
  Object.defineProperty(exports2, "parseTransaction", {
    enumerable: true,
    get: function() {
      return transactions_1.parse;
    }
  });
  Object.defineProperty(exports2, "recoverAddress", {
    enumerable: true,
    get: function() {
      return transactions_1.recoverAddress;
    }
  });
  Object.defineProperty(exports2, "serializeTransaction", {
    enumerable: true,
    get: function() {
      return transactions_1.serialize;
    }
  });
  Object.defineProperty(exports2, "TransactionTypes", {
    enumerable: true,
    get: function() {
      return transactions_1.TransactionTypes;
    }
  });
  var units_1 = require$$18;
  Object.defineProperty(exports2, "commify", {
    enumerable: true,
    get: function() {
      return units_1.commify;
    }
  });
  Object.defineProperty(exports2, "formatEther", {
    enumerable: true,
    get: function() {
      return units_1.formatEther;
    }
  });
  Object.defineProperty(exports2, "parseEther", {
    enumerable: true,
    get: function() {
      return units_1.parseEther;
    }
  });
  Object.defineProperty(exports2, "formatUnits", {
    enumerable: true,
    get: function() {
      return units_1.formatUnits;
    }
  });
  Object.defineProperty(exports2, "parseUnits", {
    enumerable: true,
    get: function() {
      return units_1.parseUnits;
    }
  });
  var wallet_1 = require$$19;
  Object.defineProperty(exports2, "verifyMessage", {
    enumerable: true,
    get: function() {
      return wallet_1.verifyMessage;
    }
  });
  Object.defineProperty(exports2, "verifyTypedData", {
    enumerable: true,
    get: function() {
      return wallet_1.verifyTypedData;
    }
  });
  var web_1 = require$$20;
  Object.defineProperty(exports2, "_fetchData", {
    enumerable: true,
    get: function() {
      return web_1._fetchData;
    }
  });
  Object.defineProperty(exports2, "fetchJson", {
    enumerable: true,
    get: function() {
      return web_1.fetchJson;
    }
  });
  Object.defineProperty(exports2, "poll", {
    enumerable: true,
    get: function() {
      return web_1.poll;
    }
  });
  var sha2_2 = require$$10;
  Object.defineProperty(exports2, "SupportedAlgorithm", {
    enumerable: true,
    get: function() {
      return sha2_2.SupportedAlgorithm;
    }
  });
  var strings_2 = require$$16;
  Object.defineProperty(exports2, "UnicodeNormalizationForm", {
    enumerable: true,
    get: function() {
      return strings_2.UnicodeNormalizationForm;
    }
  });
  Object.defineProperty(exports2, "Utf8ErrorReason", {
    enumerable: true,
    get: function() {
      return strings_2.Utf8ErrorReason;
    }
  });
})(utils$e);
function getInjectedName(ethereum) {
  var _a2, _b2, _c2;
  if (!ethereum)
    return "Injected";
  const getName = (provider) => {
    if (provider.isApexWallet)
      return "Apex Wallet";
    if (provider.isAvalanche)
      return "Core Wallet";
    if (provider.isBackpack)
      return "Backpack";
    if (provider.isBifrost)
      return "Bifrost Wallet";
    if (provider.isBitKeep)
      return "BitKeep";
    if (provider.isBitski)
      return "Bitski";
    if (provider.isBlockWallet)
      return "BlockWallet";
    if (provider.isBraveWallet)
      return "Brave Wallet";
    if (provider.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider.isDawn)
      return "Dawn Wallet";
    if (provider.isEnkrypt)
      return "Enkrypt";
    if (provider.isExodus)
      return "Exodus";
    if (provider.isFrame)
      return "Frame";
    if (provider.isFrontier)
      return "Frontier Wallet";
    if (provider.isGamestop)
      return "GameStop Wallet";
    if (provider.isHyperPay)
      return "HyperPay Wallet";
    if (provider.isImToken)
      return "ImToken";
    if (provider.isKuCoinWallet)
      return "KuCoin Wallet";
    if (provider.isMathWallet)
      return "MathWallet";
    if (provider.isOkxWallet || provider.isOKExWallet)
      return "OKX Wallet";
    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
      return "1inch Wallet";
    if (provider.isOpera)
      return "Opera";
    if (provider.isPhantom)
      return "Phantom";
    if (provider.isPortal)
      return "Ripio Portal";
    if (provider.isRabby)
      return "Rabby";
    if (provider.isRainbow)
      return "Rainbow";
    if (provider.isStatus)
      return "Status";
    if (provider.isTally)
      return "Taho";
    if (provider.isTokenPocket)
      return "TokenPocket";
    if (provider.isTokenary)
      return "Tokenary";
    if (provider.isTrust || provider.isTrustWallet)
      return "Trust Wallet";
    if (provider.isXDEFI)
      return "XDEFI Wallet";
    if (provider.isZerion)
      return "Zerion";
    if (provider.isMetaMask)
      return "MetaMask";
  };
  if ((_a2 = ethereum.providers) == null ? void 0 : _a2.length) {
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name2 = getName(provider);
      if (!name2) {
        name2 = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name2);
    }
    const names2 = [...nameSet];
    if (names2.length)
      return names2;
    return (_b2 = names2[0]) != null ? _b2 : "Injected";
  }
  return (_c2 = getName(ethereum)) != null ? _c2 : "Injected";
}
var _provider$2;
var InjectedConnector = class extends Connector {
  constructor({
    chains,
    options: options_
  } = {}) {
    const options = {
      shimDisconnect: true,
      getProvider: () => typeof window !== "undefined" ? window.ethereum : void 0,
      ...options_
    };
    super({
      chains,
      options
    });
    __publicField(this, "id", "injected");
    __publicField(this, "name");
    __publicField(this, "ready");
    __privateAdd(this, _provider$2, void 0);
    __publicField(this, "shimDisconnectKey", `${this.id}.shimDisconnect`);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: utils$e.getAddress(accounts[0])
        });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", {
        chain: {
          id: id2,
          unsupported
        }
      });
    });
    __publicField(this, "onDisconnect", async (error) => {
      var _a2;
      if (error.code === 1013) {
        const provider2 = await this.getProvider();
        if (provider2) {
          const isAuthorized = await this.getAccount();
          if (isAuthorized)
            return;
        }
      }
      this.emit("disconnect");
      if (this.options.shimDisconnect)
        (_a2 = getClient().storage) == null ? void 0 : _a2.removeItem(this.shimDisconnectKey);
    });
    const provider = options.getProvider();
    if (typeof options.name === "string")
      this.name = options.name;
    else if (provider) {
      const detectedName = getInjectedName(provider);
      if (options.name)
        this.name = options.name(detectedName);
      else {
        if (typeof detectedName === "string")
          this.name = detectedName;
        else
          this.name = detectedName[0];
      }
    } else
      this.name = "Injected";
    this.ready = !!provider;
  }
  async connect({
    chainId
  } = {}) {
    var _a2;
    try {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", {
        type: "connecting"
      });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = utils$e.getAddress(accounts[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain = await this.switchChain(chainId);
        id2 = chain.id;
        unsupported = this.isChainUnsupported(id2);
      }
      if (this.options.shimDisconnect)
        (_a2 = getClient().storage) == null ? void 0 : _a2.setItem(this.shimDisconnectKey, true);
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableError(error);
      throw error;
    }
  }
  async disconnect() {
    var _a2;
    const provider = await this.getProvider();
    if (!(provider == null ? void 0 : provider.removeListener))
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if (this.options.shimDisconnect)
      (_a2 = getClient().storage) == null ? void 0 : _a2.removeItem(this.shimDisconnectKey);
  }
  async getAccount() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return utils$e.getAddress(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({
      method: "eth_chainId"
    }).then(normalizeChainId);
  }
  async getProvider() {
    const provider = this.options.getProvider();
    if (provider)
      __privateSet(this, _provider$2, provider);
    return __privateGet(this, _provider$2);
  }
  async getSigner({
    chainId
  } = {}) {
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new ethers.providers.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    var _a2;
    try {
      if (this.options.shimDisconnect && !((_a2 = getClient().storage) == null ? void 0 : _a2.getItem(this.shimDisconnectKey)))
        return false;
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    var _a2, _b2, _c2, _d, _e;
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id2 = utils$e.hexValue(chainId);
    try {
      await Promise.all([provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id2
        }]
      }), new Promise((res) => this.on("change", ({
        chain
      }) => {
        if ((chain == null ? void 0 : chain.id) === chainId)
          res();
      }))]);
      return (_a2 = this.chains.find((x2) => x2.id === chainId)) != null ? _a2 : {
        id: chainId,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: {
          name: "Ether",
          decimals: 18,
          symbol: "ETH"
        },
        rpcUrls: {
          default: {
            http: [""]
          },
          public: {
            http: [""]
          }
        }
      };
    } catch (error) {
      const chain = this.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new ChainNotConfiguredError({
          chainId,
          connectorId: this.id
        });
      if (error.code === 4902 || ((_c2 = (_b2 = error == null ? void 0 : error.data) == null ? void 0 : _b2.originalError) == null ? void 0 : _c2.code) === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: id2,
              chainName: chain.name,
              nativeCurrency: chain.nativeCurrency,
              rpcUrls: [(_e = (_d = chain.rpcUrls.public) == null ? void 0 : _d.http[0]) != null ? _e : ""],
              blockExplorerUrls: this.getBlockExplorerUrls(chain)
            }]
          });
          const currentChainId = await this.getChainId();
          if (currentChainId !== chainId)
            throw new ProviderRpcError("User rejected switch after adding network.", {
              code: 4001
            });
          return chain;
        } catch (addError) {
          if (this.isUserRejectedRequestError(addError))
            throw new UserRejectedRequestError(addError);
          throw new AddChainError();
        }
      }
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
};
_provider$2 = /* @__PURE__ */ new WeakMap();
function normalizeChainId(chainId) {
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
function getClient() {
  {
    throw new Error("No wagmi client found. Ensure you have set up a client: https://wagmi.sh/react/client");
  }
}
var RpcError = class extends Error {
  constructor(message, options) {
    const {
      cause,
      code: code2,
      data
    } = options;
    if (!Number.isInteger(code2))
      throw new Error('"code" must be an integer.');
    if (!message || typeof message !== "string")
      throw new Error('"message" must be a nonempty string.');
    super(message);
    this.cause = cause;
    this.code = code2;
    this.data = data;
  }
};
var ProviderRpcError = class extends RpcError {
  constructor(message, options) {
    const {
      cause,
      code: code2,
      data
    } = options;
    if (!(Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(message, {
      cause,
      code: code2,
      data
    });
  }
};
var AddChainError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "AddChainError";
    this.message = "Error adding chain";
  }
};
var ChainNotConfiguredError = class extends Error {
  constructor({
    chainId,
    connectorId
  }) {
    super(`Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`);
    this.name = "ChainNotConfigured";
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorNotFoundError";
    this.message = "Connector not found";
  }
};
var ResourceUnavailableError = class extends RpcError {
  constructor(cause) {
    super("Resource unavailable", {
      cause,
      code: -32002
    });
    this.name = "ResourceUnavailable";
  }
};
var SwitchChainError = class extends ProviderRpcError {
  constructor(cause) {
    super("Error switching chain", {
      cause,
      code: 4902
    });
    this.name = "SwitchChainError";
  }
};
var UserRejectedRequestError = class extends ProviderRpcError {
  constructor(cause) {
    super("User rejected request", {
      cause,
      code: 4001
    });
    this.name = "UserRejectedRequestError";
  }
};
var switchChainAllowedRegex = /(imtoken|metamask|rainbow|trust wallet|uniswap wallet|ledger)/i;
var _provider$1, _switchChain, switchChain_fn;
var WalletConnectLegacyConnector = class extends Connector {
  constructor(config2) {
    super(config2);
    __privateAdd(this, _switchChain);
    __publicField(this, "id", "walletConnectLegacy");
    __publicField(this, "name", "WalletConnectLegacy");
    __publicField(this, "ready", true);
    __privateAdd(this, _provider$1, void 0);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: utils$e.getAddress(accounts[0])
        });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", {
        chain: {
          id: id2,
          unsupported
        }
      });
    });
    __publicField(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect({
    chainId
  } = {}) {
    var _a2, _b2, _c2;
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const lastUsedChainId = getClient().lastUsedChainId;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
      }
      const provider = await this.getProvider({
        chainId: targetChainId,
        create: true
      });
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      setTimeout(() => this.emit("message", {
        type: "connecting"
      }), 0);
      const accounts = await provider.enable();
      const account = utils$e.getAddress(accounts[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      const walletName = (_c2 = (_b2 = (_a2 = provider.connector) == null ? void 0 : _a2.peerMeta) == null ? void 0 : _b2.name) != null ? _c2 : "";
      if (switchChainAllowedRegex.test(walletName))
        this.switchChain = __privateMethod(this, _switchChain, switchChain_fn);
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider: new ethers.providers.Web3Provider(provider)
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError(error);
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.disconnect();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = provider.accounts;
    return utils$e.getAddress(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  async getProvider({
    chainId,
    create: create4
  } = {}) {
    var _a2, _b2;
    if (!__privateGet(this, _provider$1) || chainId || create4) {
      const rpc = !((_a2 = this.options) == null ? void 0 : _a2.infuraId) ? this.chains.reduce((rpc2, chain) => ({
        ...rpc2,
        [chain.id]: chain.rpcUrls.default.http[0]
      }), {}) : {};
      const WalletConnectProvider2 = (await Promise.resolve($$25)).default;
      __privateSet(this, _provider$1, new WalletConnectProvider2({
        ...this.options,
        chainId,
        rpc: {
          ...rpc,
          ...(_b2 = this.options) == null ? void 0 : _b2.rpc
        }
      }));
      __privateGet(this, _provider$1).http = await __privateGet(this, _provider$1).setHttpProvider(chainId);
    }
    return __privateGet(this, _provider$1);
  }
  async getSigner({
    chainId
  } = {}) {
    const [provider, account] = await Promise.all([this.getProvider({
      chainId
    }), this.getAccount()]);
    return new ethers.providers.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
};
_provider$1 = /* @__PURE__ */ new WeakMap();
_switchChain = /* @__PURE__ */ new WeakSet();
switchChain_fn = async function(chainId) {
  var _a2;
  const provider = await this.getProvider();
  const id2 = utils$e.hexValue(chainId);
  try {
    await Promise.race([provider.request({
      method: "wallet_switchEthereumChain",
      params: [{
        chainId: id2
      }]
    }), new Promise((res) => this.on("change", ({
      chain
    }) => {
      if ((chain == null ? void 0 : chain.id) === chainId)
        res(chainId);
    }))]);
    return (_a2 = this.chains.find((x2) => x2.id === chainId)) != null ? _a2 : {
      id: chainId,
      name: `Chain ${id2}`,
      network: `${id2}`,
      nativeCurrency: {
        name: "Ether",
        decimals: 18,
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: [""]
        },
        public: {
          http: [""]
        }
      }
    };
  } catch (error) {
    const message = typeof error === "string" ? error : error == null ? void 0 : error.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError(error);
    throw new SwitchChainError(error);
  }
};
var dist$5 = {};
var CoinbaseWalletSDK$1 = {};
var walletLogo$1 = {};
Object.defineProperty(walletLogo$1, "__esModule", {
  value: true
});
walletLogo$1.walletLogo = void 0;
const walletLogo = (type2, width) => {
  let height;
  switch (type2) {
    case "standard":
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    case "circle":
      height = width;
      return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
    case "text":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogo":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    case "textLight":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogoLight":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    default:
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
  }
};
walletLogo$1.walletLogo = walletLogo;
var ScopedLocalStorage$1 = {};
Object.defineProperty(ScopedLocalStorage$1, "__esModule", {
  value: true
});
ScopedLocalStorage$1.ScopedLocalStorage = void 0;
class ScopedLocalStorage {
  constructor(scope) {
    this.scope = scope;
  }
  setItem(key2, value) {
    localStorage.setItem(this.scopedKey(key2), value);
  }
  getItem(key2) {
    return localStorage.getItem(this.scopedKey(key2));
  }
  removeItem(key2) {
    localStorage.removeItem(this.scopedKey(key2));
  }
  clear() {
    const prefix = this.scopedKey("");
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key2 = localStorage.key(i);
      if (typeof key2 === "string" && key2.startsWith(prefix)) {
        keysToRemove.push(key2);
      }
    }
    keysToRemove.forEach((key2) => localStorage.removeItem(key2));
  }
  scopedKey(key2) {
    return `${this.scope}:${key2}`;
  }
}
ScopedLocalStorage$1.ScopedLocalStorage = ScopedLocalStorage;
var CoinbaseWalletProvider$1 = {};
var safeEventEmitter = {};
Object.defineProperty(safeEventEmitter, "__esModule", {
  value: true
});
const events_1 = events.exports;
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(() => {
      throw err;
    });
  }
}
function arrayClone(arr2) {
  const n2 = arr2.length;
  const copy2 = new Array(n2);
  for (let i = 0; i < n2; i += 1) {
    copy2[i] = arr2[i];
  }
  return copy2;
}
class SafeEventEmitter$2 extends events_1.EventEmitter {
  emit(type2, ...args) {
    let doError = type2 === "error";
    const events2 = this._events;
    if (events2 !== void 0) {
      doError = doError && events2.error === void 0;
    } else if (!doError) {
      return false;
    }
    if (doError) {
      let er;
      if (args.length > 0) {
        [er] = args;
      }
      if (er instanceof Error) {
        throw er;
      }
      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
      err.context = er;
      throw err;
    }
    const handler = events2[type2];
    if (handler === void 0) {
      return false;
    }
    if (typeof handler === "function") {
      safeApply(handler, this, args);
    } else {
      const len = handler.length;
      const listeners2 = arrayClone(handler);
      for (let i = 0; i < len; i += 1) {
        safeApply(listeners2[i], this, args);
      }
    }
    return true;
  }
}
safeEventEmitter.default = SafeEventEmitter$2;
var DiagnosticLogger = {};
Object.defineProperty(DiagnosticLogger, "__esModule", {
  value: true
});
DiagnosticLogger.EVENTS = void 0;
DiagnosticLogger.EVENTS = {
  STARTED_CONNECTING: "walletlink_sdk.started.connecting",
  CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
  DISCONNECTED: "walletlink_sdk.disconnected",
  METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
  LINKED: "walletlink_sdk.linked",
  FAILURE: "walletlink_sdk.generic_failure",
  SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
  ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
  SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
  UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
  SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
  GENERAL_ERROR: "walletlink_sdk.general_error",
  WEB3_REQUEST: "walletlink_sdk.web3.request",
  WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
  WEB3_RESPONSE: "walletlink_sdk.web3.response",
  UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
};
var errors$1 = {};
var dist$4 = {};
var classes = {};
var fastSafeStringify = stringify$2;
stringify$2.default = stringify$2;
stringify$2.stable = deterministicStringify;
stringify$2.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr = [];
var replacerStack = [];
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify$2(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  decirc(obj, "", 0, [], void 0, 0, options);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_2) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace2, val, k2, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k2);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k2, {
        value: replace2
      });
      arr.push([parent, k2, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k2, replace2]);
    }
  } else {
    parent[k2] = replace2;
    arr.push([parent, k2, val]);
  }
}
function decirc(val, k2, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key2 = keys[i];
        decirc(val[key2], key2, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function compareFunction(a2, b2) {
  if (a2 < b2) {
    return -1;
  }
  if (a2 > b2) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_2) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k2, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_2) {
      return;
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys.length; i++) {
        var key2 = keys[i];
        deterministicDecirc(val[key2], key2, i, stack, val, depth, options);
        tmp[key2] = val[key2];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k2, val]);
        parent[k2] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k2, v2) {
    return v2;
  };
  return function(key2, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key2 && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key2, val);
  };
}
Object.defineProperty(classes, "__esModule", {
  value: true
});
classes.EthereumProviderError = classes.EthereumRpcError = void 0;
const fast_safe_stringify_1 = fastSafeStringify;
class EthereumRpcError extends Error {
  constructor(code2, message, data) {
    if (!Number.isInteger(code2)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code2;
    if (data !== void 0) {
      this.data = data;
    }
  }
  serialize() {
    const serialized = {
      code: this.code,
      message: this.message
    };
    if (this.data !== void 0) {
      serialized.data = this.data;
    }
    if (this.stack) {
      serialized.stack = this.stack;
    }
    return serialized;
  }
  toString() {
    return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
  }
}
classes.EthereumRpcError = EthereumRpcError;
class EthereumProviderError extends EthereumRpcError {
  constructor(code2, message, data) {
    if (!isValidEthProviderCode(code2)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code2, message, data);
  }
}
classes.EthereumProviderError = EthereumProviderError;
function isValidEthProviderCode(code2) {
  return Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999;
}
function stringifyReplacer(_2, value) {
  if (value === "[Circular]") {
    return void 0;
  }
  return value;
}
var utils$3 = {};
var errorConstants = {};
Object.defineProperty(errorConstants, "__esModule", {
  value: true
});
errorConstants.errorValues = errorConstants.errorCodes = void 0;
errorConstants.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
errorConstants.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.serializeError = exports2.isValidCode = exports2.getMessageFromCode = exports2.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const error_constants_12 = errorConstants;
  const classes_12 = classes;
  const FALLBACK_ERROR_CODE = error_constants_12.errorCodes.rpc.internal;
  const FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
  const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
  };
  exports2.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function getMessageFromCode(code2, fallbackMessage = FALLBACK_MESSAGE) {
    if (Number.isInteger(code2)) {
      const codeString = code2.toString();
      if (hasKey(error_constants_12.errorValues, codeString)) {
        return error_constants_12.errorValues[codeString].message;
      }
      if (isJsonRpcServerError(code2)) {
        return exports2.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
    }
    return fallbackMessage;
  }
  exports2.getMessageFromCode = getMessageFromCode;
  function isValidCode(code2) {
    if (!Number.isInteger(code2)) {
      return false;
    }
    const codeString = code2.toString();
    if (error_constants_12.errorValues[codeString]) {
      return true;
    }
    if (isJsonRpcServerError(code2)) {
      return true;
    }
    return false;
  }
  exports2.isValidCode = isValidCode;
  function serializeError(error, {
    fallbackError = FALLBACK_ERROR,
    shouldIncludeStack = false
  } = {}) {
    var _a2, _b2;
    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
      throw new Error("Must provide fallback error with integer number code and string message.");
    }
    if (error instanceof classes_12.EthereumRpcError) {
      return error.serialize();
    }
    const serialized = {};
    if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
      const _error = error;
      serialized.code = _error.code;
      if (_error.message && typeof _error.message === "string") {
        serialized.message = _error.message;
        if (hasKey(_error, "data")) {
          serialized.data = _error.data;
        }
      } else {
        serialized.message = getMessageFromCode(serialized.code);
        serialized.data = {
          originalError: assignOriginalError(error)
        };
      }
    } else {
      serialized.code = fallbackError.code;
      const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
      serialized.message = message && typeof message === "string" ? message : fallbackError.message;
      serialized.data = {
        originalError: assignOriginalError(error)
      };
    }
    const stack = (_b2 = error) === null || _b2 === void 0 ? void 0 : _b2.stack;
    if (shouldIncludeStack && error && stack && typeof stack === "string") {
      serialized.stack = stack;
    }
    return serialized;
  }
  exports2.serializeError = serializeError;
  function isJsonRpcServerError(code2) {
    return code2 >= -32099 && code2 <= -32e3;
  }
  function assignOriginalError(error) {
    if (error && typeof error === "object" && !Array.isArray(error)) {
      return Object.assign({}, error);
    }
    return error;
  }
  function hasKey(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
})(utils$3);
var errors = {};
Object.defineProperty(errors, "__esModule", {
  value: true
});
errors.ethErrors = void 0;
const classes_1 = classes;
const utils_1 = utils$3;
const error_constants_1 = errorConstants;
errors.ethErrors = {
  rpc: {
    parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
    invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
    invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
    methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
    internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
    server: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const {
        code: code2
      } = opts;
      if (!Number.isInteger(code2) || code2 > -32005 || code2 < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code2, opts);
    },
    invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
    resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
    resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
    transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
    methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
    limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    userRejectedRequest: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
    },
    unauthorized: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
    },
    unsupportedMethod: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
    },
    disconnected: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
    },
    chainDisconnected: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
    },
    custom: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const {
        code: code2,
        message,
        data
      } = opts;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new classes_1.EthereumProviderError(code2, message, data);
    }
  }
};
function getEthJsonRpcError(code2, arg) {
  const [message, data] = parseOpts(arg);
  return new classes_1.EthereumRpcError(code2, message || utils_1.getMessageFromCode(code2), data);
}
function getEthProviderError(code2, arg) {
  const [message, data] = parseOpts(arg);
  return new classes_1.EthereumProviderError(code2, message || utils_1.getMessageFromCode(code2), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const {
        message,
        data
      } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.getMessageFromCode = exports2.serializeError = exports2.EthereumProviderError = exports2.EthereumRpcError = exports2.ethErrors = exports2.errorCodes = void 0;
  const classes_12 = classes;
  Object.defineProperty(exports2, "EthereumRpcError", {
    enumerable: true,
    get: function() {
      return classes_12.EthereumRpcError;
    }
  });
  Object.defineProperty(exports2, "EthereumProviderError", {
    enumerable: true,
    get: function() {
      return classes_12.EthereumProviderError;
    }
  });
  const utils_12 = utils$3;
  Object.defineProperty(exports2, "serializeError", {
    enumerable: true,
    get: function() {
      return utils_12.serializeError;
    }
  });
  Object.defineProperty(exports2, "getMessageFromCode", {
    enumerable: true,
    get: function() {
      return utils_12.getMessageFromCode;
    }
  });
  const errors_12 = errors;
  Object.defineProperty(exports2, "ethErrors", {
    enumerable: true,
    get: function() {
      return errors_12.ethErrors;
    }
  });
  const error_constants_12 = errorConstants;
  Object.defineProperty(exports2, "errorCodes", {
    enumerable: true,
    get: function() {
      return error_constants_12.errorCodes;
    }
  });
})(dist$4);
var Web3Response = {};
var Web3Method = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.Web3Method = void 0;
  (function(Web3Method2) {
    Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
    Web3Method2["signEthereumMessage"] = "signEthereumMessage";
    Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
    Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
    Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
    Web3Method2["scanQRCode"] = "scanQRCode";
    Web3Method2["generic"] = "generic";
    Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
    Web3Method2["addEthereumChain"] = "addEthereumChain";
    Web3Method2["switchEthereumChain"] = "switchEthereumChain";
    Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
    Web3Method2["watchAsset"] = "watchAsset";
    Web3Method2["selectProvider"] = "selectProvider";
  })(exports2.Web3Method || (exports2.Web3Method = {}));
})(Web3Method);
Object.defineProperty(Web3Response, "__esModule", {
  value: true
});
Web3Response.EthereumAddressFromSignedMessageResponse = Web3Response.SubmitEthereumTransactionResponse = Web3Response.SignEthereumTransactionResponse = Web3Response.SignEthereumMessageResponse = Web3Response.isRequestEthereumAccountsResponse = Web3Response.SelectProviderResponse = Web3Response.WatchAssetReponse = Web3Response.RequestEthereumAccountsResponse = Web3Response.SwitchEthereumChainResponse = Web3Response.AddEthereumChainResponse = Web3Response.isErrorResponse = void 0;
const Web3Method_1$2 = Web3Method;
function isErrorResponse(response) {
  var _a2, _b2;
  return ((_a2 = response) === null || _a2 === void 0 ? void 0 : _a2.method) !== void 0 && ((_b2 = response) === null || _b2 === void 0 ? void 0 : _b2.errorMessage) !== void 0;
}
Web3Response.isErrorResponse = isErrorResponse;
function AddEthereumChainResponse(addResponse) {
  return {
    method: Web3Method_1$2.Web3Method.addEthereumChain,
    result: addResponse
  };
}
Web3Response.AddEthereumChainResponse = AddEthereumChainResponse;
function SwitchEthereumChainResponse(switchResponse) {
  return {
    method: Web3Method_1$2.Web3Method.switchEthereumChain,
    result: switchResponse
  };
}
Web3Response.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
function RequestEthereumAccountsResponse(addresses) {
  return {
    method: Web3Method_1$2.Web3Method.requestEthereumAccounts,
    result: addresses
  };
}
Web3Response.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
function WatchAssetReponse(success) {
  return {
    method: Web3Method_1$2.Web3Method.watchAsset,
    result: success
  };
}
Web3Response.WatchAssetReponse = WatchAssetReponse;
function SelectProviderResponse(selectedProviderKey) {
  return {
    method: Web3Method_1$2.Web3Method.selectProvider,
    result: selectedProviderKey
  };
}
Web3Response.SelectProviderResponse = SelectProviderResponse;
function isRequestEthereumAccountsResponse(res) {
  return res && res.method === Web3Method_1$2.Web3Method.requestEthereumAccounts;
}
Web3Response.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
function SignEthereumMessageResponse(signature2) {
  return {
    method: Web3Method_1$2.Web3Method.signEthereumMessage,
    result: signature2
  };
}
Web3Response.SignEthereumMessageResponse = SignEthereumMessageResponse;
function SignEthereumTransactionResponse(signedData) {
  return {
    method: Web3Method_1$2.Web3Method.signEthereumTransaction,
    result: signedData
  };
}
Web3Response.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
function SubmitEthereumTransactionResponse(txHash) {
  return {
    method: Web3Method_1$2.Web3Method.submitEthereumTransaction,
    result: txHash
  };
}
Web3Response.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
function EthereumAddressFromSignedMessageResponse(address) {
  return {
    method: Web3Method_1$2.Web3Method.ethereumAddressFromSignedMessage,
    result: address
  };
}
Web3Response.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
var version$1 = {};
Object.defineProperty(version$1, "__esModule", {
  value: true
});
version$1.LIB_VERSION = void 0;
version$1.LIB_VERSION = "3.7.1";
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.getErrorCode = exports2.serializeError = exports2.standardErrors = exports2.standardErrorMessage = exports2.standardErrorCodes = void 0;
  const eth_rpc_errors_12 = dist$4;
  const Web3Response_12 = Web3Response;
  const version_12 = version$1;
  exports2.standardErrorCodes = Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.errorCodes), {
    provider: Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.errorCodes.provider), {
      unsupportedChain: 4902
    }))
  }));
  function standardErrorMessage(code2) {
    return code2 !== void 0 ? (0, eth_rpc_errors_12.getMessageFromCode)(code2) : "Unknown error";
  }
  exports2.standardErrorMessage = standardErrorMessage;
  exports2.standardErrors = Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.ethErrors), {
    provider: Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_12.ethErrors.provider), {
      unsupportedChain: (chainId = "") => eth_rpc_errors_12.ethErrors.provider.custom({
        code: exports2.standardErrorCodes.provider.unsupportedChain,
        message: `Unrecognized chain ID ${chainId}. Try adding the chain using wallet_addEthereumChain first.`
      })
    }))
  }));
  function serializeError(error, requestOrMethod) {
    const serialized = (0, eth_rpc_errors_12.serializeError)(getErrorObject(error), {
      shouldIncludeStack: true
    });
    const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    docUrl.searchParams.set("version", version_12.LIB_VERSION);
    docUrl.searchParams.set("code", serialized.code.toString());
    const method = getMethod(serialized.data, requestOrMethod);
    if (method) {
      docUrl.searchParams.set("method", method);
    }
    docUrl.searchParams.set("message", serialized.message);
    return Object.assign(Object.assign({}, serialized), {
      docUrl: docUrl.href
    });
  }
  exports2.serializeError = serializeError;
  function getErrorObject(error) {
    if (typeof error === "string") {
      return {
        message: error,
        code: exports2.standardErrorCodes.rpc.internal
      };
    } else if ((0, Web3Response_12.isErrorResponse)(error)) {
      return Object.assign(Object.assign({}, error), {
        message: error.errorMessage,
        code: error.errorCode,
        data: {
          method: error.method,
          result: error.result
        }
      });
    } else {
      return error;
    }
  }
  function getMethod(serializedData, request) {
    var _a2;
    const methodInData = (_a2 = serializedData) === null || _a2 === void 0 ? void 0 : _a2.method;
    if (methodInData) {
      return methodInData;
    }
    if (request === void 0) {
      return void 0;
    } else if (typeof request === "string") {
      return request;
    } else if (!Array.isArray(request)) {
      return request.method;
    } else if (request.length > 0) {
      return request[0].method;
    } else {
      return void 0;
    }
  }
  function getErrorCode(error) {
    var _a2;
    if (typeof error === "number") {
      return error;
    } else if (isErrorWithCode(error)) {
      return (_a2 = error.code) !== null && _a2 !== void 0 ? _a2 : error.errorCode;
    }
    return void 0;
  }
  exports2.getErrorCode = getErrorCode;
  function isErrorWithCode(error) {
    return typeof error === "object" && error !== null && (typeof error.code === "number" || typeof error.errorCode === "number");
  }
})(errors$1);
var Session$1 = {};
var sha_js = { exports: {} };
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module2, exports2) {
  var buffer2 = buffer$1;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src6, dst) {
    for (var key2 in src6) {
      dst[key2] = src6[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size2, fill, encoding) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size2);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size2);
  };
})(safeBuffer, safeBuffer.exports);
var Buffer$7 = safeBuffer.exports.Buffer;
function Hash$6(blockSize, finalSize) {
  this._block = Buffer$7.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash$6.prototype.update = function(data, enc) {
  if (typeof data === "string") {
    enc = enc || "utf8";
    data = Buffer$7.from(data, enc);
  }
  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;
  for (var offset = 0; offset < length; ) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);
    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block);
    }
  }
  this._len += length;
  return this;
};
Hash$6.prototype.digest = function(enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 128;
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;
  if (bits <= 4294967295) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);
  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash2 = this._hash();
  return enc ? hash2.toString(enc) : hash2;
};
Hash$6.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash = Hash$6;
var inherits$5 = inherits_browser$1.exports;
var Hash$5 = hash;
var Buffer$6 = safeBuffer.exports.Buffer;
var K$3 = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
var W$5 = new Array(80);
function Sha() {
  this.init();
  this._w = W$5;
  Hash$5.call(this, 64, 56);
}
inherits$5(Sha, Hash$5);
Sha.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl5$1(num) {
  return num << 5 | num >>> 27;
}
function rotl30$1(num) {
  return num << 30 | num >>> 2;
}
function ft$1(s2, b2, c2, d2) {
  if (s2 === 0)
    return b2 & c2 | ~b2 & d2;
  if (s2 === 2)
    return b2 & c2 | b2 & d2 | c2 & d2;
  return b2 ^ c2 ^ d2;
}
Sha.prototype._update = function(M2) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e2 = this._e | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M2.readInt32BE(i * 4);
  for (; i < 80; ++i)
    W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
  for (var j2 = 0; j2 < 80; ++j2) {
    var s2 = ~~(j2 / 20);
    var t2 = rotl5$1(a2) + ft$1(s2, b2, c2, d2) + e2 + W2[j2] + K$3[s2] | 0;
    e2 = d2;
    d2 = c2;
    c2 = rotl30$1(b2);
    b2 = a2;
    a2 = t2;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e2 + this._e | 0;
};
Sha.prototype._hash = function() {
  var H2 = Buffer$6.allocUnsafe(20);
  H2.writeInt32BE(this._a | 0, 0);
  H2.writeInt32BE(this._b | 0, 4);
  H2.writeInt32BE(this._c | 0, 8);
  H2.writeInt32BE(this._d | 0, 12);
  H2.writeInt32BE(this._e | 0, 16);
  return H2;
};
var sha = Sha;
var inherits$4 = inherits_browser$1.exports;
var Hash$4 = hash;
var Buffer$5 = safeBuffer.exports.Buffer;
var K$2 = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
var W$4 = new Array(80);
function Sha1() {
  this.init();
  this._w = W$4;
  Hash$4.call(this, 64, 56);
}
inherits$4(Sha1, Hash$4);
Sha1.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s2, b2, c2, d2) {
  if (s2 === 0)
    return b2 & c2 | ~b2 & d2;
  if (s2 === 2)
    return b2 & c2 | b2 & d2 | c2 & d2;
  return b2 ^ c2 ^ d2;
}
Sha1.prototype._update = function(M2) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e2 = this._e | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M2.readInt32BE(i * 4);
  for (; i < 80; ++i)
    W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
  for (var j2 = 0; j2 < 80; ++j2) {
    var s2 = ~~(j2 / 20);
    var t2 = rotl5(a2) + ft(s2, b2, c2, d2) + e2 + W2[j2] + K$2[s2] | 0;
    e2 = d2;
    d2 = c2;
    c2 = rotl30(b2);
    b2 = a2;
    a2 = t2;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e2 + this._e | 0;
};
Sha1.prototype._hash = function() {
  var H2 = Buffer$5.allocUnsafe(20);
  H2.writeInt32BE(this._a | 0, 0);
  H2.writeInt32BE(this._b | 0, 4);
  H2.writeInt32BE(this._c | 0, 8);
  H2.writeInt32BE(this._d | 0, 12);
  H2.writeInt32BE(this._e | 0, 16);
  return H2;
};
var sha1 = Sha1;
var inherits$3 = inherits_browser$1.exports;
var Hash$3 = hash;
var Buffer$4 = safeBuffer.exports.Buffer;
var K$1 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
var W$3 = new Array(64);
function Sha256$1() {
  this.init();
  this._w = W$3;
  Hash$3.call(this, 64, 56);
}
inherits$3(Sha256$1, Hash$3);
Sha256$1.prototype.init = function() {
  this._a = 1779033703;
  this._b = 3144134277;
  this._c = 1013904242;
  this._d = 2773480762;
  this._e = 1359893119;
  this._f = 2600822924;
  this._g = 528734635;
  this._h = 1541459225;
  return this;
};
function ch(x2, y2, z2) {
  return z2 ^ x2 & (y2 ^ z2);
}
function maj$1(x2, y2, z2) {
  return x2 & y2 | z2 & (x2 | y2);
}
function sigma0$1(x2) {
  return (x2 >>> 2 | x2 << 30) ^ (x2 >>> 13 | x2 << 19) ^ (x2 >>> 22 | x2 << 10);
}
function sigma1$1(x2) {
  return (x2 >>> 6 | x2 << 26) ^ (x2 >>> 11 | x2 << 21) ^ (x2 >>> 25 | x2 << 7);
}
function gamma0(x2) {
  return (x2 >>> 7 | x2 << 25) ^ (x2 >>> 18 | x2 << 14) ^ x2 >>> 3;
}
function gamma1(x2) {
  return (x2 >>> 17 | x2 << 15) ^ (x2 >>> 19 | x2 << 13) ^ x2 >>> 10;
}
Sha256$1.prototype._update = function(M2) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e2 = this._e | 0;
  var f2 = this._f | 0;
  var g2 = this._g | 0;
  var h2 = this._h | 0;
  for (var i = 0; i < 16; ++i)
    W2[i] = M2.readInt32BE(i * 4);
  for (; i < 64; ++i)
    W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
  for (var j2 = 0; j2 < 64; ++j2) {
    var T1 = h2 + sigma1$1(e2) + ch(e2, f2, g2) + K$1[j2] + W2[j2] | 0;
    var T2 = sigma0$1(a2) + maj$1(a2, b2, c2) | 0;
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = d2 + T1 | 0;
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = T1 + T2 | 0;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e2 + this._e | 0;
  this._f = f2 + this._f | 0;
  this._g = g2 + this._g | 0;
  this._h = h2 + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var H2 = Buffer$4.allocUnsafe(32);
  H2.writeInt32BE(this._a, 0);
  H2.writeInt32BE(this._b, 4);
  H2.writeInt32BE(this._c, 8);
  H2.writeInt32BE(this._d, 12);
  H2.writeInt32BE(this._e, 16);
  H2.writeInt32BE(this._f, 20);
  H2.writeInt32BE(this._g, 24);
  H2.writeInt32BE(this._h, 28);
  return H2;
};
var sha256 = Sha256$1;
var inherits$2 = inherits_browser$1.exports;
var Sha256 = sha256;
var Hash$2 = hash;
var Buffer$3 = safeBuffer.exports.Buffer;
var W$2 = new Array(64);
function Sha224() {
  this.init();
  this._w = W$2;
  Hash$2.call(this, 64, 56);
}
inherits$2(Sha224, Sha256);
Sha224.prototype.init = function() {
  this._a = 3238371032;
  this._b = 914150663;
  this._c = 812702999;
  this._d = 4144912697;
  this._e = 4290775857;
  this._f = 1750603025;
  this._g = 1694076839;
  this._h = 3204075428;
  return this;
};
Sha224.prototype._hash = function() {
  var H2 = Buffer$3.allocUnsafe(28);
  H2.writeInt32BE(this._a, 0);
  H2.writeInt32BE(this._b, 4);
  H2.writeInt32BE(this._c, 8);
  H2.writeInt32BE(this._d, 12);
  H2.writeInt32BE(this._e, 16);
  H2.writeInt32BE(this._f, 20);
  H2.writeInt32BE(this._g, 24);
  return H2;
};
var sha224 = Sha224;
var inherits$1 = inherits_browser$1.exports;
var Hash$1 = hash;
var Buffer$2 = safeBuffer.exports.Buffer;
var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
var W$1 = new Array(160);
function Sha512() {
  this.init();
  this._w = W$1;
  Hash$1.call(this, 128, 112);
}
inherits$1(Sha512, Hash$1);
Sha512.prototype.init = function() {
  this._ah = 1779033703;
  this._bh = 3144134277;
  this._ch = 1013904242;
  this._dh = 2773480762;
  this._eh = 1359893119;
  this._fh = 2600822924;
  this._gh = 528734635;
  this._hh = 1541459225;
  this._al = 4089235720;
  this._bl = 2227873595;
  this._cl = 4271175723;
  this._dl = 1595750129;
  this._el = 2917565137;
  this._fl = 725511199;
  this._gl = 4215389547;
  this._hl = 327033209;
  return this;
};
function Ch(x2, y2, z2) {
  return z2 ^ x2 & (y2 ^ z2);
}
function maj(x2, y2, z2) {
  return x2 & y2 | z2 & (x2 | y2);
}
function sigma0(x2, xl) {
  return (x2 >>> 28 | xl << 4) ^ (xl >>> 2 | x2 << 30) ^ (xl >>> 7 | x2 << 25);
}
function sigma1(x2, xl) {
  return (x2 >>> 14 | xl << 18) ^ (x2 >>> 18 | xl << 14) ^ (xl >>> 9 | x2 << 23);
}
function Gamma0(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ x2 >>> 7;
}
function Gamma0l(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ (x2 >>> 7 | xl << 25);
}
function Gamma1(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ x2 >>> 6;
}
function Gamma1l(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ (x2 >>> 6 | xl << 26);
}
function getCarry(a2, b2) {
  return a2 >>> 0 < b2 >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M2) {
  var W2 = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch2 = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;
  for (var i = 0; i < 32; i += 2) {
    W2[i] = M2.readInt32BE(i * 4);
    W2[i + 1] = M2.readInt32BE(i * 4 + 4);
  }
  for (; i < 160; i += 2) {
    var xh = W2[i - 15 * 2];
    var xl = W2[i - 15 * 2 + 1];
    var gamma02 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W2[i - 2 * 2];
    xl = W2[i - 2 * 2 + 1];
    var gamma12 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);
    var Wi7h = W2[i - 7 * 2];
    var Wi7l = W2[i - 7 * 2 + 1];
    var Wi16h = W2[i - 16 * 2];
    var Wi16l = W2[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma02 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma12 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W2[i] = Wih;
    W2[i + 1] = Wil;
  }
  for (var j2 = 0; j2 < 160; j2 += 2) {
    Wih = W2[j2];
    Wil = W2[j2 + 1];
    var majh = maj(ah, bh, ch2);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);
    var Kih = K[j2];
    var Kil = K[j2 + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }
  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch2 + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function() {
  var H2 = Buffer$2.allocUnsafe(64);
  function writeInt64BE(h2, l2, offset) {
    H2.writeInt32BE(h2, offset);
    H2.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H2;
};
var sha512 = Sha512;
var inherits = inherits_browser$1.exports;
var SHA512 = sha512;
var Hash = hash;
var Buffer$1 = safeBuffer.exports.Buffer;
var W = new Array(160);
function Sha384() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function() {
  this._ah = 3418070365;
  this._bh = 1654270250;
  this._ch = 2438529370;
  this._dh = 355462360;
  this._eh = 1731405415;
  this._fh = 2394180231;
  this._gh = 3675008525;
  this._hh = 1203062813;
  this._al = 3238371032;
  this._bl = 914150663;
  this._cl = 812702999;
  this._dl = 4144912697;
  this._el = 4290775857;
  this._fl = 1750603025;
  this._gl = 1694076839;
  this._hl = 3204075428;
  return this;
};
Sha384.prototype._hash = function() {
  var H2 = Buffer$1.allocUnsafe(48);
  function writeInt64BE(h2, l2, offset) {
    H2.writeInt32BE(h2, offset);
    H2.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H2;
};
var sha384 = Sha384;
var exports$1 = sha_js.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports$1[algorithm];
  if (!Algorithm)
    throw new Error(algorithm + " is not supported (we accept pull requests)");
  return new Algorithm();
};
exports$1.sha = sha;
exports$1.sha1 = sha1;
exports$1.sha224 = sha224;
exports$1.sha256 = sha256;
exports$1.sha384 = sha384;
exports$1.sha512 = sha512;
var util$3 = {};
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return {
    __proto__: test
  }.foo === test.foo && !({
    __proto__: null
  } instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$2 = functionBind;
var src = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e2) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var hasProto2 = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto2 ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto(getProto(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn2 = doEval2("%AsyncGeneratorFunction%");
    if (fn2) {
      value = fn2.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = functionBind;
var hasOwn$1 = src;
var $concat$1 = bind$1.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind$1.call(Function.call, String.prototype.replace);
var $strSlice = bind$1.call(Function.call, String.prototype.slice);
var $exec = bind$1.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string2) {
  var first2 = $strSlice(string2, 0, 1);
  var last2 = $strSlice(string2, -1);
  if (first2 === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string2, rePropName, function(match, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first2 = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || last2 === '"' || last2 === "'" || last2 === "`") && first2 !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", {
        value: 1
      });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func2 = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func2, "length");
      if (desc.configurable) {
        $defineProperty(func2, "length", {
          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
      }
    }
    return func2;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", {
      value: applyBind
    });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var inspectCustom = require$$3$1.custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$5(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect5(value, from2, noIndent) {
    if (from2) {
      seen = $arrSlice.call(seen);
      seen.push(from2);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function") {
    var name2 = nameOf(obj);
    var keys = arrObjKeys(obj, inspect5);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$5(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect5);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect5);
    if ("cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect5(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
      return obj[inspectSymbol]();
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key2) {
      mapParts.push(inspect5(key2, obj, true) + " => " + inspect5(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect5(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect5(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect5(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect5(String(obj)));
  }
  if (!isDate$1(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect5);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace.call(String(s2), /"/g, "&quot;");
}
function isArray$5(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate$1(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
  return key2 in this;
};
function has$3(obj, key2) {
  return hasOwn.call(obj, key2);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x2) {
      return i;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s2) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c2) {
  var n2 = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect5) {
  var isArr = isArray$5(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$3(obj, i) ? inspect5(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key2 in obj) {
    if (!has$3(obj, key2)) {
      continue;
    }
    if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key2)) {
      xs.push(inspect5(key2, obj) + ": " + inspect5(obj[key2], obj));
    } else {
      xs.push(key2 + ": " + inspect5(obj[key2], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs.push("[" + inspect5(syms[j2]) + "]: " + inspect5(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect4 = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key2) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key2) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key2) {
  var node = listGetNode(objects, key2);
  return node && node.value;
};
var listSet = function(objects, key2, value) {
  var node = listGetNode(objects, key2);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      key: key2,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key2) {
  return !!listGetNode(objects, key2);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key2) {
      if (!channel.has(key2)) {
        throw new $TypeError("Side channel does not contain " + inspect4(key2));
      }
    },
    get: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key2);
        }
      } else {
        if ($o) {
          return listGet($o, key2);
        }
      }
    },
    has: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key2);
        }
      } else {
        if ($o) {
          return listHas($o, key2);
        }
      }
      return false;
    },
    set: function(key2, value) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key2, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      } else {
        if (!$o) {
          $o = {
            key: {},
            next: null
          };
        }
        listSet($o, key2, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$4 = Array.isArray;
var hexTable = function() {
  var array2 = [];
  for (var i = 0; i < 256; ++i) {
    array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array2;
}();
var compactQueue = function compactQueue2(queue2) {
  while (queue2.length > 1) {
    var item = queue2.pop();
    var obj = item.obj[item.prop];
    if (isArray$4(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== "undefined") {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge$2 = function merge(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$4(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$4(target) && !isArray$4(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$4(target) && isArray$4(source)) {
    source.forEach(function(item, i) {
      if (has$2.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key2) {
    var value = source[key2];
    if (has$2.call(acc, key2)) {
      acc[key2] = merge(acc[key2], value, options);
    } else {
      acc[key2] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign$1 = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key2) {
    acc[key2] = source[key2];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode4 = function encode5(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string2 = str;
  if (typeof str === "symbol") {
    string2 = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string2 = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string2.length; ++i) {
    var c2 = string2.charCodeAt(i);
    if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
      out += string2.charAt(i);
      continue;
    }
    if (c2 < 128) {
      out = out + hexTable[c2];
      continue;
    }
    if (c2 < 2048) {
      out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
      continue;
    }
    if (c2 < 55296 || c2 >= 57344) {
      out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
      continue;
    }
    i += 1;
    c2 = 65536 + ((c2 & 1023) << 10 | string2.charCodeAt(i) & 1023);
    out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue2 = [{
    obj: {
      o: value
    },
    prop: "o"
  }];
  var refs = [];
  for (var i = 0; i < queue2.length; ++i) {
    var item = queue2[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j2 = 0; j2 < keys.length; ++j2) {
      var key2 = keys[j2];
      var val = obj[key2];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue2.push({
          obj,
          prop: key2
        });
        refs.push(val);
      }
    }
  }
  compactQueue(queue2);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a2, b2) {
  return [].concat(a2, b2);
};
var maybeMap = function maybeMap2(val, fn2) {
  if (isArray$4(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn2(val[i]));
    }
    return mapped;
  }
  return fn2(val);
};
var utils$2 = {
  arrayToObject,
  assign: assign$1,
  combine,
  compact,
  decode,
  encode: encode4,
  isBuffer,
  isRegExp,
  maybeMap,
  merge: merge$2
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key2) {
    return prefix + "[" + key2 + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$3 = Array.isArray;
var split = String.prototype.split;
var push$1 = Array.prototype.push;
var pushToArray = function(arr2, valueOrArray) {
  push$1.apply(arr2, isArray$3(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object2, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter2, sort2, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object2;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$3(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format2);
      if (generateArrayPrefix === "comma" && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ",");
        var valuesJoined = "";
        for (var i = 0; i < valuesArray.length; ++i) {
          valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults$1.encoder, charset, "value", format2));
        }
        return [formatter(keyValue) + "=" + valuesJoined];
      }
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$3(obj)) {
    objKeys = [{
      value: obj.length > 0 ? obj.join(",") || null : void 0
    }];
  } else if (isArray$3(filter2)) {
    objKeys = filter2;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort2 ? keys.sort(sort2) : keys;
  }
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key2 = objKeys[j2];
    var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key2) : prefix : prefix + (allowDots ? "." + key2 : "[" + key2 + "]");
    sideChannel2.set(object2, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter2, sort2, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter2 = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$3(opts.filter)) {
    filter2 = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: filter2,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object2, opts) {
  var obj = object2;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (isArray$3(options.filter)) {
    filter2 = options.filter;
    objKeys = filter2;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key2 = objKeys[i];
    if (options.skipNulls && obj[key2] === null) {
      continue;
    }
    pushToArray(keys, stringify$1(obj[key2], key2, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel2));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key2, val;
    if (pos === -1) {
      key2 = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key2 = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, "value");
      });
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$2(val) ? [val] : val;
    }
    if (has.call(obj, key2)) {
      obj[key2] = utils.combine(obj[key2], val);
    } else {
      obj[key2] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];
    if (root === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = {
          0: leaf
        };
      } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && options.parseArrays && index2 <= options.arrayLimit) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key2);
  var parent = segment ? key2.slice(0, segment.index) : key2;
  var keys = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key2)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push("[" + key2.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$8 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys = Object.keys(tempObj);
  for (var i = 0; i < keys.length; ++i) {
    var key2 = keys[i];
    var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse$7 = parse$8;
var formats = formats$3;
var lib$1 = {
  formats,
  parse: parse$7,
  stringify: stringify2
};
var types$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ProviderType = exports2.RegExpString = exports2.IntNumber = exports2.BigIntString = exports2.AddressString = exports2.HexString = exports2.OpaqueType = void 0;
  function OpaqueType() {
    return (value) => value;
  }
  exports2.OpaqueType = OpaqueType;
  exports2.HexString = OpaqueType();
  exports2.AddressString = OpaqueType();
  exports2.BigIntString = OpaqueType();
  function IntNumber(num) {
    return Math.floor(num);
  }
  exports2.IntNumber = IntNumber;
  exports2.RegExpString = OpaqueType();
  (function(ProviderType) {
    ProviderType["CoinbaseWallet"] = "CoinbaseWallet";
    ProviderType["MetaMask"] = "MetaMask";
    ProviderType["Unselected"] = "";
  })(exports2.ProviderType || (exports2.ProviderType = {}));
})(types$2);
var __importDefault$d = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(util$3, "__esModule", {
  value: true
});
util$3.isInIFrame = util$3.createQrUrl = util$3.getFavicon = util$3.range = util$3.isBigNumber = util$3.ensureParsedJSONObject = util$3.ensureBN = util$3.ensureRegExpString = util$3.ensureIntNumber = util$3.ensureBuffer = util$3.ensureAddressString = util$3.ensureEvenLengthHexString = util$3.ensureHexString = util$3.isHexString = util$3.prepend0x = util$3.strip0x = util$3.has0xPrefix = util$3.hexStringFromIntNumber = util$3.intNumberFromHexString = util$3.bigIntStringFromBN = util$3.hexStringFromBuffer = util$3.hexStringToUint8Array = util$3.uint8ArrayToHex = util$3.randomBytesHex = void 0;
const bn_js_1$1 = __importDefault$d(bn.exports);
const qs_1 = lib$1;
const errors_1$3 = errors$1;
const types_1$3 = types$2;
const INT_STRING_REGEX = /^[0-9]*$/;
const HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
function randomBytesHex(length) {
  return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
}
util$3.randomBytesHex = randomBytesHex;
function uint8ArrayToHex(value) {
  return [...value].map((b2) => b2.toString(16).padStart(2, "0")).join("");
}
util$3.uint8ArrayToHex = uint8ArrayToHex;
function hexStringToUint8Array(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte2) => parseInt(byte2, 16)));
}
util$3.hexStringToUint8Array = hexStringToUint8Array;
function hexStringFromBuffer(buf, includePrefix = false) {
  const hex2 = buf.toString("hex");
  return (0, types_1$3.HexString)(includePrefix ? "0x" + hex2 : hex2);
}
util$3.hexStringFromBuffer = hexStringFromBuffer;
function bigIntStringFromBN(bn2) {
  return (0, types_1$3.BigIntString)(bn2.toString(10));
}
util$3.bigIntStringFromBN = bigIntStringFromBN;
function intNumberFromHexString(hex2) {
  return (0, types_1$3.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(hex2, false), 16).toNumber());
}
util$3.intNumberFromHexString = intNumberFromHexString;
function hexStringFromIntNumber(num) {
  return (0, types_1$3.HexString)("0x" + new bn_js_1$1.default(num).toString(16));
}
util$3.hexStringFromIntNumber = hexStringFromIntNumber;
function has0xPrefix(str) {
  return str.startsWith("0x") || str.startsWith("0X");
}
util$3.has0xPrefix = has0xPrefix;
function strip0x(hex2) {
  if (has0xPrefix(hex2)) {
    return hex2.slice(2);
  }
  return hex2;
}
util$3.strip0x = strip0x;
function prepend0x(hex2) {
  if (has0xPrefix(hex2)) {
    return "0x" + hex2.slice(2);
  }
  return "0x" + hex2;
}
util$3.prepend0x = prepend0x;
function isHexString$1(hex2) {
  if (typeof hex2 !== "string") {
    return false;
  }
  const s2 = strip0x(hex2).toLowerCase();
  return HEXADECIMAL_STRING_REGEX.test(s2);
}
util$3.isHexString = isHexString$1;
function ensureHexString(hex2, includePrefix = false) {
  if (typeof hex2 === "string") {
    const s2 = strip0x(hex2).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX.test(s2)) {
      return (0, types_1$3.HexString)(includePrefix ? "0x" + s2 : s2);
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`"${String(hex2)}" is not a hexadecimal string`);
}
util$3.ensureHexString = ensureHexString;
function ensureEvenLengthHexString(hex2, includePrefix = false) {
  let h2 = ensureHexString(hex2, false);
  if (h2.length % 2 === 1) {
    h2 = (0, types_1$3.HexString)("0" + h2);
  }
  return includePrefix ? (0, types_1$3.HexString)("0x" + h2) : h2;
}
util$3.ensureEvenLengthHexString = ensureEvenLengthHexString;
function ensureAddressString(str) {
  if (typeof str === "string") {
    const s2 = strip0x(str).toLowerCase();
    if (isHexString$1(s2) && s2.length === 40) {
      return (0, types_1$3.AddressString)(prepend0x(s2));
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
}
util$3.ensureAddressString = ensureAddressString;
function ensureBuffer(str) {
  if (Buffer.isBuffer(str)) {
    return str;
  }
  if (typeof str === "string") {
    if (isHexString$1(str)) {
      const s2 = ensureEvenLengthHexString(str, false);
      return Buffer.from(s2, "hex");
    } else {
      return Buffer.from(str, "utf8");
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);
}
util$3.ensureBuffer = ensureBuffer;
function ensureIntNumber(num) {
  if (typeof num === "number" && Number.isInteger(num)) {
    return (0, types_1$3.IntNumber)(num);
  }
  if (typeof num === "string") {
    if (INT_STRING_REGEX.test(num)) {
      return (0, types_1$3.IntNumber)(Number(num));
    }
    if (isHexString$1(num)) {
      return (0, types_1$3.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);
}
util$3.ensureIntNumber = ensureIntNumber;
function ensureRegExpString(regExp) {
  if (regExp instanceof RegExp) {
    return (0, types_1$3.RegExpString)(regExp.toString());
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(regExp)}`);
}
util$3.ensureRegExpString = ensureRegExpString;
function ensureBN(val) {
  if (val !== null && (bn_js_1$1.default.isBN(val) || isBigNumber(val))) {
    return new bn_js_1$1.default(val.toString(10), 10);
  }
  if (typeof val === "number") {
    return new bn_js_1$1.default(ensureIntNumber(val));
  }
  if (typeof val === "string") {
    if (INT_STRING_REGEX.test(val)) {
      return new bn_js_1$1.default(val, 10);
    }
    if (isHexString$1(val)) {
      return new bn_js_1$1.default(ensureEvenLengthHexString(val, false), 16);
    }
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);
}
util$3.ensureBN = ensureBN;
function ensureParsedJSONObject(val) {
  if (typeof val === "string") {
    return JSON.parse(val);
  }
  if (typeof val === "object") {
    return val;
  }
  throw errors_1$3.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
}
util$3.ensureParsedJSONObject = ensureParsedJSONObject;
function isBigNumber(val) {
  if (val == null || typeof val.constructor !== "function") {
    return false;
  }
  const {
    constructor
  } = val;
  return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
}
util$3.isBigNumber = isBigNumber;
function range$2(start, stop) {
  return Array.from({
    length: stop - start
  }, (_2, i) => start + i);
}
util$3.range = range$2;
function getFavicon() {
  const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
  const {
    protocol,
    host
  } = document.location;
  const href = el ? el.getAttribute("href") : null;
  if (!href || href.startsWith("javascript:")) {
    return null;
  }
  if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
    return href;
  }
  if (href.startsWith("//")) {
    return protocol + href;
  }
  return `${protocol}//${host}${href}`;
}
util$3.getFavicon = getFavicon;
function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version2, chainId) {
  const sessionIdKey = isParentConnection ? "parent-id" : "id";
  const query2 = (0, qs_1.stringify)({
    [sessionIdKey]: sessionId,
    secret: sessionSecret,
    server: serverUrl,
    v: version2,
    chainId
  });
  const qrUrl = `${serverUrl}/#/link?${query2}`;
  return qrUrl;
}
util$3.createQrUrl = createQrUrl;
function isInIFrame() {
  try {
    return window.frameElement !== null;
  } catch (e2) {
    return false;
  }
}
util$3.isInIFrame = isInIFrame;
Object.defineProperty(Session$1, "__esModule", {
  value: true
});
Session$1.Session = void 0;
const sha_js_1 = sha_js.exports;
const util_1$7 = util$3;
const STORAGE_KEY_SESSION_ID = "session:id";
const STORAGE_KEY_SESSION_SECRET = "session:secret";
const STORAGE_KEY_SESSION_LINKED = "session:linked";
class Session {
  constructor(storage, id2, secret, linked) {
    this._storage = storage;
    this._id = id2 || (0, util_1$7.randomBytesHex)(16);
    this._secret = secret || (0, util_1$7.randomBytesHex)(32);
    this._key = new sha_js_1.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex");
    this._linked = !!linked;
  }
  static load(storage) {
    const id2 = storage.getItem(STORAGE_KEY_SESSION_ID);
    const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
    const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
    if (id2 && secret) {
      return new Session(storage, id2, secret, linked === "1");
    }
    return null;
  }
  static hash(sessionId) {
    return new sha_js_1.sha256().update(sessionId).digest("hex");
  }
  get id() {
    return this._id;
  }
  get secret() {
    return this._secret;
  }
  get key() {
    return this._key;
  }
  get linked() {
    return this._linked;
  }
  set linked(val) {
    this._linked = val;
    this.persistLinked();
  }
  save() {
    this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
    this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
    this.persistLinked();
    return this;
  }
  persistLinked() {
    this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
  }
}
Session$1.Session = Session;
var WalletSDKRelayAbstract$1 = {};
Object.defineProperty(WalletSDKRelayAbstract$1, "__esModule", {
  value: true
});
WalletSDKRelayAbstract$1.WalletSDKRelayAbstract = WalletSDKRelayAbstract$1.APP_VERSION_KEY = WalletSDKRelayAbstract$1.LOCAL_STORAGE_ADDRESSES_KEY = WalletSDKRelayAbstract$1.WALLET_USER_NAME_KEY = void 0;
const errors_1$2 = errors$1;
WalletSDKRelayAbstract$1.WALLET_USER_NAME_KEY = "walletUsername";
WalletSDKRelayAbstract$1.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
WalletSDKRelayAbstract$1.APP_VERSION_KEY = "AppVersion";
class WalletSDKRelayAbstract {
  async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
    if (!jsonRpcUrl)
      throw new Error("Error: No jsonRpcUrl provided");
    return window.fetch(jsonRpcUrl, {
      method: "POST",
      body: JSON.stringify(request),
      mode: "cors",
      headers: {
        "Content-Type": "application/json"
      }
    }).then((res) => res.json()).then((json2) => {
      if (!json2) {
        throw errors_1$2.standardErrors.rpc.parse({});
      }
      const response = json2;
      const {
        error
      } = response;
      if (error) {
        throw (0, errors_1$2.serializeError)(error, request.method);
      }
      return response;
    });
  }
}
WalletSDKRelayAbstract$1.WalletSDKRelayAbstract = WalletSDKRelayAbstract;
var readableBrowser = { exports: {} };
var streamBrowser = events.exports.EventEmitter;
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys2(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
        _defineProperty2(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = buffer$1, Buffer2 = _require.Buffer;
  var _require2 = require$$3$1, inspect5 = _require2.inspect;
  var custom = inspect5 && inspect5.custom || "inspect";
  function copyBuffer(src6, target, offset) {
    Buffer2.prototype.copy.call(src6, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push2(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift2(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0)
          return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next)
          ret += s2 + p2.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n2) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n2 >>> 0);
        var p2 = this.head;
        var i = 0;
        while (p2) {
          copyBuffer(p2.data, ret, i);
          i += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n2, hasStrings) {
        var ret;
        if (n2 < this.head.data.length) {
          ret = this.head.data.slice(0, n2);
          this.head.data = this.head.data.slice(n2);
        } else if (n2 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first2() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n2) {
        var p2 = this.head;
        var c2 = 1;
        var ret = p2.data;
        n2 -= ret.length;
        while (p2 = p2.next) {
          var str = p2.data;
          var nb = n2 > str.length ? str.length : n2;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n2);
          n2 -= nb;
          if (n2 === 0) {
            if (nb === str.length) {
              ++c2;
              if (p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n2) {
        var ret = Buffer2.allocUnsafe(n2);
        var p2 = this.head;
        var c2 = 1;
        p2.data.copy(ret);
        n2 -= p2.data.length;
        while (p2 = p2.next) {
          var buf = p2.data;
          var nb = n2 > buf.length ? buf.length : n2;
          buf.copy(ret, ret.length - n2, 0, nb);
          n2 -= nb;
          if (n2 === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect5(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return buffer_list;
}
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy(stream, err) {
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream.destroy(err);
  else
    stream.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code2, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code2;
  codes[code2] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
  return 'The value "' + value + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith(name2, " argument")) {
    msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type2 = includes(name2, ".") ? "property" : "argument";
    msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
};
var browser$1 = deprecate;
function deprecate(fn2, msg) {
  if (config$1("noDeprecation")) {
    return fn2;
  }
  var warned = false;
  function deprecated2() {
    if (!warned) {
      if (config$1("throwDeprecation")) {
        throw new Error(msg);
      } else if (config$1("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn2.apply(this, arguments);
  }
  return deprecated2;
}
function config$1(name2) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_2) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: browser$1
  };
  var Stream = streamBrowser;
  var Buffer2 = buffer$1.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  inherits_browser$1.exports(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2))
          return true;
        if (this !== Writable)
          return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy2(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy2(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last2 = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last2) {
        last2.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
    else if (writev)
      stream._writev(chunk, state2.onwrite);
    else
      stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy2(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy2(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK2();
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state2.bufferedRequestCount;
      var buffer2 = new Array(l2);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count2 = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count2] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count2 += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy2(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish2(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key2 in obj)
      keys2.push(key2);
    return keys2;
  };
  _stream_duplex = Duplex2;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  inherits_browser$1.exports(Duplex2, Readable);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys.length; v2++) {
      var method = keys[v2];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex2(options) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = safeBuffer.exports.Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r2;
    var i;
    if (this.lastNeed) {
      r2 = this.fillLast(buf);
      if (r2 === void 0)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r2 ? r2 + this.text(buf, i) : this.text(buf, i);
    return r2 || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte2) {
    if (byte2 <= 127)
      return 0;
    else if (byte2 >> 5 === 6)
      return 2;
    else if (byte2 >> 4 === 14)
      return 3;
    else if (byte2 >> 3 === 30)
      return 4;
    return byte2 >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j2 = buf.length - 1;
    if (j2 < i)
      return 0;
    var nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j2 < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j2 < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p2) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p2 = this.lastTotal - this.lastNeed;
    var r2 = utf8CheckExtraBytes(this, buf);
    if (r2 !== void 0)
      return r2;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p2, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p2, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r2 + "\uFFFD";
    return r2;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r2 = buf.toString("utf16le", i);
      if (r2) {
        var c2 = r2.charCodeAt(r2.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r2.slice(0, -1);
        }
      }
      return r2;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r2 + this.lastChar.toString("utf16le", 0, end);
    }
    return r2;
  }
  function base64Text(buf, i) {
    var n2 = (buf.length - i) % 3;
    if (n2 === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n2;
    this.lastTotal = 3;
    if (n2 === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n2);
  }
  function base64End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r2;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$3() {
}
function isRequest$1(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function eos$1(stream, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream, null, opts);
  if (!opts)
    opts = {};
  callback = once$1(callback || noop$3);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream.writable)
      onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend2() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream);
  };
  var onerror = function onerror2(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest2() {
    stream.req.on("finish", onfinish);
  };
  if (isRequest$1(stream)) {
    stream.on("complete", onfinish);
    stream.on("abort", onclose);
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !stream._writableState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (opts.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  return function() {
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty2(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty2(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty2(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator2[kStream].read();
        if (data) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator2[kLastResolve] = resolve;
          iterator2[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        if (reject !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject(err);
        }
        iterator2[kError] = err;
        return;
      }
      var resolve = iterator2[kLastResolve];
      if (resolve !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex2;
  Readable.ReadableState = ReadableState;
  events.exports.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = streamBrowser;
  var Buffer2 = buffer$1.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$3$1;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from2;
  inherits_browser$1.exports(Readable, Stream);
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn2) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn2);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn2);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn2);
    else
      emitter._events[event] = [fn2, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex2;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy2(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream, state2, chunk, false);
            else
              maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p2 = this._readableState.buffer.head;
    var content2 = "";
    while (p2 !== null) {
      content2 += decoder.write(p2.data);
      p2 = p2.next;
    }
    this._readableState.buffer.clear();
    if (content2 !== "")
      this._readableState.buffer.push(content2);
    this._readableState.length = content2.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n2) {
    if (n2 >= MAX_HWM) {
      n2 = MAX_HWM;
    } else {
      n2--;
      n2 |= n2 >>> 1;
      n2 |= n2 >>> 2;
      n2 |= n2 >>> 4;
      n2 |= n2 >>> 8;
      n2 |= n2 >>> 16;
      n2++;
    }
    return n2;
  }
  function howMuchToRead(n2, state2) {
    if (n2 <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n2 !== n2) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n2 > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n2);
    if (n2 <= state2.length)
      return n2;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n2) {
    debug2("read", n2);
    n2 = parseInt(n2, 10);
    var state2 = this._readableState;
    var nOrig = n2;
    if (n2 !== 0)
      state2.emittedReadable = false;
    if (n2 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n2 = howMuchToRead(n2, state2);
    if (n2 === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n2 < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n2 = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n2 > 0)
      ret = fromList(n2, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n2 = 0;
    } else {
      state2.length -= n2;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n2 && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug2("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug2("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n2) {
    errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src6 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      process.nextTick(endFn);
    else
      src6.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src6) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src6);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src6.removeListener("end", onend);
      src6.removeListener("end", unpipe);
      src6.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src6.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src6.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy2(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src6.unpipe(dest);
    }
    dest.emit("pipe", src6);
    if (!state2.flowing) {
      debug2("pipe resume");
      src6.resume();
    }
    return dest;
  };
  function pipeOnDrain(src6) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src6._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src6, "data")) {
        state2.flowing = true;
        flow(src6);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn2) {
    var res = Stream.prototype.on.call(this, ev, fn2);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn2) {
    var res = Stream.prototype.removeListener.call(this, ev, fn2);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
      stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
    }
    this._read = function(n3) {
      debug2("wrapped _read", n3);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n2, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n2 || n2 >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n2, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf2(xs, x2) {
    for (var i = 0, l2 = xs.length; i < l2; i++) {
      if (xs[i] === x2)
        return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$3;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require_stream_duplex();
inherits_browser$1.exports(Transform$3, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$3(options) {
  if (!(this instanceof Transform$3))
    return new Transform$3(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform$3.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$3.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$3.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$3.prototype._read = function(n2) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$3.prototype._destroy = function(err, cb) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er)
    return stream.emit("error", er);
  if (data != null)
    stream.push(data);
  if (stream._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
var _stream_passthrough = PassThrough;
var Transform$2 = _stream_transform;
inherits_browser$1.exports(PassThrough, Transform$2);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform$2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once2(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$2(err) {
  if (err)
    throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
  callback = once2(callback);
  var closed = false;
  stream.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream))
      return stream.abort();
    if (typeof stream.destroy === "function")
      return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn2) {
  fn2();
}
function pipe$1(from2, to) {
  return from2.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop$2;
  if (typeof streams[streams.length - 1] !== "function")
    return noop$2;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams.map(function(stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function(err) {
      if (!error)
        error = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe$1);
}
var pipeline_1 = pipeline;
(function(module2, exports2) {
  exports2 = module2.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = _stream_transform;
  exports2.PassThrough = _stream_passthrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
const {
  Transform: Transform$1
} = readableBrowser.exports;
var keccak$2 = (KeccakState) => class Keccak2 extends Transform$1 {
  constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._hashBitLength = hashBitLength;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  }
  _flush(callback) {
    let error = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }
    callback(error);
  }
  update(data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Digest already called");
    if (!Buffer.isBuffer(data))
      data = Buffer.from(data, encoding);
    this._state.absorb(data);
    return this;
  }
  digest(encoding) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    if (this._delimitedSuffix)
      this._state.absorbLastFewBits(this._delimitedSuffix);
    let digest9 = this._state.squeeze(this._hashBitLength / 8);
    if (encoding !== void 0)
      digest9 = digest9.toString(encoding);
    this._resetState();
    return digest9;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone = new Keccak2(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    this._state.copy(clone._state);
    clone._finalized = this._finalized;
    return clone;
  }
};
const {
  Transform
} = readableBrowser.exports;
var shake = (KeccakState) => class Shake extends Transform {
  constructor(rate, capacity, delimitedSuffix, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  }
  _flush() {
  }
  _read(size2) {
    this.push(this.squeeze(size2));
  }
  update(data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Squeeze already called");
    if (!Buffer.isBuffer(data))
      data = Buffer.from(data, encoding);
    this._state.absorb(data);
    return this;
  }
  squeeze(dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true;
      this._state.absorbLastFewBits(this._delimitedSuffix);
    }
    let data = this._state.squeeze(dataByteLength);
    if (encoding !== void 0)
      data = data.toString(encoding);
    return data;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
    this._state.copy(clone._state);
    clone._finalized = this._finalized;
    return clone;
  }
};
const createKeccak = keccak$2;
const createShake = shake;
var api = function(KeccakState) {
  const Keccak2 = createKeccak(KeccakState);
  const Shake = createShake(KeccakState);
  return function(algorithm, options) {
    const hash2 = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
    switch (hash2) {
      case "keccak224":
        return new Keccak2(1152, 448, null, 224, options);
      case "keccak256":
        return new Keccak2(1088, 512, null, 256, options);
      case "keccak384":
        return new Keccak2(832, 768, null, 384, options);
      case "keccak512":
        return new Keccak2(576, 1024, null, 512, options);
      case "sha3-224":
        return new Keccak2(1152, 448, 6, 224, options);
      case "sha3-256":
        return new Keccak2(1088, 512, 6, 256, options);
      case "sha3-384":
        return new Keccak2(832, 768, 6, 384, options);
      case "sha3-512":
        return new Keccak2(576, 1024, 6, 512, options);
      case "shake128":
        return new Shake(1344, 256, 31, options);
      case "shake256":
        return new Shake(1088, 512, 31, options);
      default:
        throw new Error("Invald algorithm: " + algorithm);
    }
  };
};
var keccakStateUnroll = {};
const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
keccakStateUnroll.p1600 = function(s2) {
  for (let round = 0; round < 24; ++round) {
    const lo0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
    const hi0 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
    const lo1 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
    const hi1 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
    const lo2 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
    const hi2 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
    const lo3 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
    const hi3 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
    const lo4 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
    const hi4 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
    const t1slo0 = s2[0] ^ lo;
    const t1shi0 = s2[1] ^ hi;
    const t1slo5 = s2[10] ^ lo;
    const t1shi5 = s2[11] ^ hi;
    const t1slo10 = s2[20] ^ lo;
    const t1shi10 = s2[21] ^ hi;
    const t1slo15 = s2[30] ^ lo;
    const t1shi15 = s2[31] ^ hi;
    const t1slo20 = s2[40] ^ lo;
    const t1shi20 = s2[41] ^ hi;
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
    const t1slo1 = s2[2] ^ lo;
    const t1shi1 = s2[3] ^ hi;
    const t1slo6 = s2[12] ^ lo;
    const t1shi6 = s2[13] ^ hi;
    const t1slo11 = s2[22] ^ lo;
    const t1shi11 = s2[23] ^ hi;
    const t1slo16 = s2[32] ^ lo;
    const t1shi16 = s2[33] ^ hi;
    const t1slo21 = s2[42] ^ lo;
    const t1shi21 = s2[43] ^ hi;
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
    const t1slo2 = s2[4] ^ lo;
    const t1shi2 = s2[5] ^ hi;
    const t1slo7 = s2[14] ^ lo;
    const t1shi7 = s2[15] ^ hi;
    const t1slo12 = s2[24] ^ lo;
    const t1shi12 = s2[25] ^ hi;
    const t1slo17 = s2[34] ^ lo;
    const t1shi17 = s2[35] ^ hi;
    const t1slo22 = s2[44] ^ lo;
    const t1shi22 = s2[45] ^ hi;
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
    const t1slo3 = s2[6] ^ lo;
    const t1shi3 = s2[7] ^ hi;
    const t1slo8 = s2[16] ^ lo;
    const t1shi8 = s2[17] ^ hi;
    const t1slo13 = s2[26] ^ lo;
    const t1shi13 = s2[27] ^ hi;
    const t1slo18 = s2[36] ^ lo;
    const t1shi18 = s2[37] ^ hi;
    const t1slo23 = s2[46] ^ lo;
    const t1shi23 = s2[47] ^ hi;
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
    const t1slo4 = s2[8] ^ lo;
    const t1shi4 = s2[9] ^ hi;
    const t1slo9 = s2[18] ^ lo;
    const t1shi9 = s2[19] ^ hi;
    const t1slo14 = s2[28] ^ lo;
    const t1shi14 = s2[29] ^ hi;
    const t1slo19 = s2[38] ^ lo;
    const t1shi19 = s2[39] ^ hi;
    const t1slo24 = s2[48] ^ lo;
    const t1shi24 = s2[49] ^ hi;
    const t2slo0 = t1slo0;
    const t2shi0 = t1shi0;
    const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
    const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
    const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
    const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
    const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
    const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
    const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
    const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
    const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
    const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
    const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
    const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
    const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
    const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
    const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
    const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
    const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
    const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
    const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
    const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
    const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
    const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
    const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
    const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
    const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
    const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
    const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
    const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
    const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
    const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
    const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
    const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
    const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
    const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
    const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
    const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
    const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
    const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
    const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
    const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
    const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
    const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
    const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
    const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
    const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
    const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
    const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
    const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
    s2[0] = t2slo0 ^ ~t2slo1 & t2slo2;
    s2[1] = t2shi0 ^ ~t2shi1 & t2shi2;
    s2[10] = t2slo5 ^ ~t2slo6 & t2slo7;
    s2[11] = t2shi5 ^ ~t2shi6 & t2shi7;
    s2[20] = t2slo10 ^ ~t2slo11 & t2slo12;
    s2[21] = t2shi10 ^ ~t2shi11 & t2shi12;
    s2[30] = t2slo15 ^ ~t2slo16 & t2slo17;
    s2[31] = t2shi15 ^ ~t2shi16 & t2shi17;
    s2[40] = t2slo20 ^ ~t2slo21 & t2slo22;
    s2[41] = t2shi20 ^ ~t2shi21 & t2shi22;
    s2[2] = t2slo1 ^ ~t2slo2 & t2slo3;
    s2[3] = t2shi1 ^ ~t2shi2 & t2shi3;
    s2[12] = t2slo6 ^ ~t2slo7 & t2slo8;
    s2[13] = t2shi6 ^ ~t2shi7 & t2shi8;
    s2[22] = t2slo11 ^ ~t2slo12 & t2slo13;
    s2[23] = t2shi11 ^ ~t2shi12 & t2shi13;
    s2[32] = t2slo16 ^ ~t2slo17 & t2slo18;
    s2[33] = t2shi16 ^ ~t2shi17 & t2shi18;
    s2[42] = t2slo21 ^ ~t2slo22 & t2slo23;
    s2[43] = t2shi21 ^ ~t2shi22 & t2shi23;
    s2[4] = t2slo2 ^ ~t2slo3 & t2slo4;
    s2[5] = t2shi2 ^ ~t2shi3 & t2shi4;
    s2[14] = t2slo7 ^ ~t2slo8 & t2slo9;
    s2[15] = t2shi7 ^ ~t2shi8 & t2shi9;
    s2[24] = t2slo12 ^ ~t2slo13 & t2slo14;
    s2[25] = t2shi12 ^ ~t2shi13 & t2shi14;
    s2[34] = t2slo17 ^ ~t2slo18 & t2slo19;
    s2[35] = t2shi17 ^ ~t2shi18 & t2shi19;
    s2[44] = t2slo22 ^ ~t2slo23 & t2slo24;
    s2[45] = t2shi22 ^ ~t2shi23 & t2shi24;
    s2[6] = t2slo3 ^ ~t2slo4 & t2slo0;
    s2[7] = t2shi3 ^ ~t2shi4 & t2shi0;
    s2[16] = t2slo8 ^ ~t2slo9 & t2slo5;
    s2[17] = t2shi8 ^ ~t2shi9 & t2shi5;
    s2[26] = t2slo13 ^ ~t2slo14 & t2slo10;
    s2[27] = t2shi13 ^ ~t2shi14 & t2shi10;
    s2[36] = t2slo18 ^ ~t2slo19 & t2slo15;
    s2[37] = t2shi18 ^ ~t2shi19 & t2shi15;
    s2[46] = t2slo23 ^ ~t2slo24 & t2slo20;
    s2[47] = t2shi23 ^ ~t2shi24 & t2shi20;
    s2[8] = t2slo4 ^ ~t2slo0 & t2slo1;
    s2[9] = t2shi4 ^ ~t2shi0 & t2shi1;
    s2[18] = t2slo9 ^ ~t2slo5 & t2slo6;
    s2[19] = t2shi9 ^ ~t2shi5 & t2shi6;
    s2[28] = t2slo14 ^ ~t2slo10 & t2slo11;
    s2[29] = t2shi14 ^ ~t2shi10 & t2shi11;
    s2[38] = t2slo19 ^ ~t2slo15 & t2slo16;
    s2[39] = t2shi19 ^ ~t2shi15 & t2shi16;
    s2[48] = t2slo24 ^ ~t2slo20 & t2slo21;
    s2[49] = t2shi24 ^ ~t2shi20 & t2shi21;
    s2[0] ^= P1600_ROUND_CONSTANTS[round * 2];
    s2[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
  }
};
const keccakState = keccakStateUnroll;
function Keccak() {
  this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.blockSize = null;
  this.count = 0;
  this.squeezing = false;
}
Keccak.prototype.initialize = function(rate, capacity) {
  for (let i = 0; i < 50; ++i)
    this.state[i] = 0;
  this.blockSize = rate / 8;
  this.count = 0;
  this.squeezing = false;
};
Keccak.prototype.absorb = function(data) {
  for (let i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << 8 * (this.count % 4);
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
};
Keccak.prototype.absorbLastFewBits = function(bits) {
  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
  if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
    keccakState.p1600(this.state);
  this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
  keccakState.p1600(this.state);
  this.count = 0;
  this.squeezing = true;
};
Keccak.prototype.squeeze = function(length) {
  if (!this.squeezing)
    this.absorbLastFewBits(1);
  const output = Buffer.alloc(length);
  for (let i = 0; i < length; ++i) {
    output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
  return output;
};
Keccak.prototype.copy = function(dest) {
  for (let i = 0; i < 50; ++i)
    dest.state[i] = this.state[i];
  dest.blockSize = this.blockSize;
  dest.count = this.count;
  dest.squeezing = this.squeezing;
};
var keccak$1 = Keccak;
var js = api(keccak$1);
const createKeccakHash = js;
const BN$1 = bn.exports;
function zeros(bytes3) {
  return Buffer.allocUnsafe(bytes3).fill(0);
}
function setLength(msg, length, right) {
  const buf = zeros(length);
  msg = toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
}
function setLengthRight(msg, length) {
  return setLength(msg, length, true);
}
function toBuffer(v2) {
  if (!Buffer.isBuffer(v2)) {
    if (Array.isArray(v2)) {
      v2 = Buffer.from(v2);
    } else if (typeof v2 === "string") {
      if (isHexString(v2)) {
        v2 = Buffer.from(padToEven(stripHexPrefix(v2)), "hex");
      } else {
        v2 = Buffer.from(v2);
      }
    } else if (typeof v2 === "number") {
      v2 = intToBuffer(v2);
    } else if (v2 === null || v2 === void 0) {
      v2 = Buffer.allocUnsafe(0);
    } else if (BN$1.isBN(v2)) {
      v2 = v2.toArrayLike(Buffer);
    } else if (v2.toArray) {
      v2 = Buffer.from(v2.toArray());
    } else {
      throw new Error("invalid type");
    }
  }
  return v2;
}
function bufferToHex(buf) {
  buf = toBuffer(buf);
  return "0x" + buf.toString("hex");
}
function keccak(a2, bits) {
  a2 = toBuffer(a2);
  if (!bits)
    bits = 256;
  return createKeccakHash("keccak" + bits).update(a2).digest();
}
function padToEven(str) {
  return str.length % 2 ? "0" + str : str;
}
function isHexString(str) {
  return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
}
function stripHexPrefix(str) {
  if (typeof str === "string" && str.startsWith("0x")) {
    return str.slice(2);
  }
  return str;
}
var util$2 = {
  zeros,
  setLength,
  setLengthRight,
  isHexString,
  stripHexPrefix,
  toBuffer,
  bufferToHex,
  keccak
};
const util$1 = util$2;
const BN = bn.exports;
function elementaryName(name2) {
  if (name2.startsWith("int[")) {
    return "int256" + name2.slice(3);
  } else if (name2 === "int") {
    return "int256";
  } else if (name2.startsWith("uint[")) {
    return "uint256" + name2.slice(4);
  } else if (name2 === "uint") {
    return "uint256";
  } else if (name2.startsWith("fixed[")) {
    return "fixed128x128" + name2.slice(5);
  } else if (name2 === "fixed") {
    return "fixed128x128";
  } else if (name2.startsWith("ufixed[")) {
    return "ufixed128x128" + name2.slice(6);
  } else if (name2 === "ufixed") {
    return "ufixed128x128";
  }
  return name2;
}
function parseTypeN(type2) {
  return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
}
function parseTypeNxM(type2) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
}
function parseTypeArray(type2) {
  var tmp = type2.match(/(.*)\[(.*?)\]$/);
  if (tmp) {
    return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
  }
  return null;
}
function parseNumber(arg) {
  var type2 = typeof arg;
  if (type2 === "string") {
    if (util$1.isHexString(arg)) {
      return new BN(util$1.stripHexPrefix(arg), 16);
    } else {
      return new BN(arg, 10);
    }
  } else if (type2 === "number") {
    return new BN(arg);
  } else if (arg.toArray) {
    return arg;
  } else {
    throw new Error("Argument is not a number");
  }
}
function encodeSingle(type2, arg) {
  var size2, num, ret, i;
  if (type2 === "address") {
    return encodeSingle("uint160", parseNumber(arg));
  } else if (type2 === "bool") {
    return encodeSingle("uint8", arg ? 1 : 0);
  } else if (type2 === "string") {
    return encodeSingle("bytes", new Buffer(arg, "utf8"));
  } else if (isArray$1(type2)) {
    if (typeof arg.length === "undefined") {
      throw new Error("Not an array?");
    }
    size2 = parseTypeArray(type2);
    if (size2 !== "dynamic" && size2 !== 0 && arg.length > size2) {
      throw new Error("Elements exceed array size: " + size2);
    }
    ret = [];
    type2 = type2.slice(0, type2.lastIndexOf("["));
    if (typeof arg === "string") {
      arg = JSON.parse(arg);
    }
    for (i in arg) {
      ret.push(encodeSingle(type2, arg[i]));
    }
    if (size2 === "dynamic") {
      var length = encodeSingle("uint256", arg.length);
      ret.unshift(length);
    }
    return Buffer.concat(ret);
  } else if (type2 === "bytes") {
    arg = new Buffer(arg);
    ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
    if (arg.length % 32 !== 0) {
      ret = Buffer.concat([ret, util$1.zeros(32 - arg.length % 32)]);
    }
    return ret;
  } else if (type2.startsWith("bytes")) {
    size2 = parseTypeN(type2);
    if (size2 < 1 || size2 > 32) {
      throw new Error("Invalid bytes<N> width: " + size2);
    }
    return util$1.setLengthRight(arg, 32);
  } else if (type2.startsWith("uint")) {
    size2 = parseTypeN(type2);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid uint<N> width: " + size2);
    }
    num = parseNumber(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
    }
    if (num < 0) {
      throw new Error("Supplied uint is negative");
    }
    return num.toArrayLike(Buffer, "be", 32);
  } else if (type2.startsWith("int")) {
    size2 = parseTypeN(type2);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid int<N> width: " + size2);
    }
    num = parseNumber(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
    }
    return num.toTwos(256).toArrayLike(Buffer, "be", 32);
  } else if (type2.startsWith("ufixed")) {
    size2 = parseTypeNxM(type2);
    num = parseNumber(arg);
    if (num < 0) {
      throw new Error("Supplied ufixed is negative");
    }
    return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size2[1]))));
  } else if (type2.startsWith("fixed")) {
    size2 = parseTypeNxM(type2);
    return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size2[1]))));
  }
  throw new Error("Unsupported or invalid type: " + type2);
}
function isDynamic(type2) {
  return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
}
function isArray$1(type2) {
  return type2.lastIndexOf("]") === type2.length - 1;
}
function rawEncode(types2, values) {
  var output = [];
  var data = [];
  var headLength = 32 * types2.length;
  for (var i in types2) {
    var type2 = elementaryName(types2[i]);
    var value = values[i];
    var cur = encodeSingle(type2, value);
    if (isDynamic(type2)) {
      output.push(encodeSingle("uint256", headLength));
      data.push(cur);
      headLength += cur.length;
    } else {
      output.push(cur);
    }
  }
  return Buffer.concat(output.concat(data));
}
function solidityPack(types2, values) {
  if (types2.length !== values.length) {
    throw new Error("Number of types are not matching the values");
  }
  var size2, num;
  var ret = [];
  for (var i = 0; i < types2.length; i++) {
    var type2 = elementaryName(types2[i]);
    var value = values[i];
    if (type2 === "bytes") {
      ret.push(value);
    } else if (type2 === "string") {
      ret.push(new Buffer(value, "utf8"));
    } else if (type2 === "bool") {
      ret.push(new Buffer(value ? "01" : "00", "hex"));
    } else if (type2 === "address") {
      ret.push(util$1.setLength(value, 20));
    } else if (type2.startsWith("bytes")) {
      size2 = parseTypeN(type2);
      if (size2 < 1 || size2 > 32) {
        throw new Error("Invalid bytes<N> width: " + size2);
      }
      ret.push(util$1.setLengthRight(value, size2));
    } else if (type2.startsWith("uint")) {
      size2 = parseTypeN(type2);
      if (size2 % 8 || size2 < 8 || size2 > 256) {
        throw new Error("Invalid uint<N> width: " + size2);
      }
      num = parseNumber(value);
      if (num.bitLength() > size2) {
        throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
      }
      ret.push(num.toArrayLike(Buffer, "be", size2 / 8));
    } else if (type2.startsWith("int")) {
      size2 = parseTypeN(type2);
      if (size2 % 8 || size2 < 8 || size2 > 256) {
        throw new Error("Invalid int<N> width: " + size2);
      }
      num = parseNumber(value);
      if (num.bitLength() > size2) {
        throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
      }
      ret.push(num.toTwos(size2).toArrayLike(Buffer, "be", size2 / 8));
    } else {
      throw new Error("Unsupported or invalid type: " + type2);
    }
  }
  return Buffer.concat(ret);
}
function soliditySHA3(types2, values) {
  return util$1.keccak(solidityPack(types2, values));
}
var abi$1 = {
  rawEncode,
  solidityPack,
  soliditySHA3
};
const util = util$2;
const abi = abi$1;
const TYPED_MESSAGE_SCHEMA = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            type: {
              type: "string"
            }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: {
      type: "string"
    },
    domain: {
      type: "object"
    },
    message: {
      type: "object"
    }
  },
  required: ["types", "primaryType", "domain", "message"]
};
const TypedDataUtils = {
  encodeData(primaryType, data, types2, useV4 = true) {
    const encodedTypes = ["bytes32"];
    const encodedValues = [this.hashType(primaryType, types2)];
    if (useV4) {
      const encodeField = (name2, type2, value) => {
        if (types2[type2] !== void 0) {
          return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type2, value, types2, useV4))];
        }
        if (value === void 0)
          throw new Error(`missing value for field ${name2} of type ${type2}`);
        if (type2 === "bytes") {
          return ["bytes32", util.keccak(value)];
        }
        if (type2 === "string") {
          if (typeof value === "string") {
            value = Buffer.from(value, "utf8");
          }
          return ["bytes32", util.keccak(value)];
        }
        if (type2.lastIndexOf("]") === type2.length - 1) {
          const parsedType = type2.slice(0, type2.lastIndexOf("["));
          const typeValuePairs = value.map((item) => encodeField(name2, parsedType, item));
          return ["bytes32", util.keccak(abi.rawEncode(typeValuePairs.map(([type3]) => type3), typeValuePairs.map(([, value2]) => value2)))];
        }
        return [type2, value];
      };
      for (const field of types2[primaryType]) {
        const [type2, value] = encodeField(field.name, field.type, data[field.name]);
        encodedTypes.push(type2);
        encodedValues.push(value);
      }
    } else {
      for (const field of types2[primaryType]) {
        let value = data[field.name];
        if (value !== void 0) {
          if (field.type === "bytes") {
            encodedTypes.push("bytes32");
            value = util.keccak(value);
            encodedValues.push(value);
          } else if (field.type === "string") {
            encodedTypes.push("bytes32");
            if (typeof value === "string") {
              value = Buffer.from(value, "utf8");
            }
            value = util.keccak(value);
            encodedValues.push(value);
          } else if (types2[field.type] !== void 0) {
            encodedTypes.push("bytes32");
            value = util.keccak(this.encodeData(field.type, value, types2, useV4));
            encodedValues.push(value);
          } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
            throw new Error("Arrays currently unimplemented in encodeData");
          } else {
            encodedTypes.push(field.type);
            encodedValues.push(value);
          }
        }
      }
    }
    return abi.rawEncode(encodedTypes, encodedValues);
  },
  encodeType(primaryType, types2) {
    let result = "";
    let deps = this.findTypeDependencies(primaryType, types2).filter((dep) => dep !== primaryType);
    deps = [primaryType].concat(deps.sort());
    for (const type2 of deps) {
      const children = types2[type2];
      if (!children) {
        throw new Error("No type definition specified: " + type2);
      }
      result += type2 + "(" + types2[type2].map(({
        name: name2,
        type: type3
      }) => type3 + " " + name2).join(",") + ")";
    }
    return result;
  },
  findTypeDependencies(primaryType, types2, results = []) {
    primaryType = primaryType.match(/^\w*/)[0];
    if (results.includes(primaryType) || types2[primaryType] === void 0) {
      return results;
    }
    results.push(primaryType);
    for (const field of types2[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types2, results)) {
        !results.includes(dep) && results.push(dep);
      }
    }
    return results;
  },
  hashStruct(primaryType, data, types2, useV4 = true) {
    return util.keccak(this.encodeData(primaryType, data, types2, useV4));
  },
  hashType(primaryType, types2) {
    return util.keccak(this.encodeType(primaryType, types2));
  },
  sanitizeData(data) {
    const sanitizedData = {};
    for (const key2 in TYPED_MESSAGE_SCHEMA.properties) {
      data[key2] && (sanitizedData[key2] = data[key2]);
    }
    if (sanitizedData.types) {
      sanitizedData.types = Object.assign({
        EIP712Domain: []
      }, sanitizedData.types);
    }
    return sanitizedData;
  },
  hash(typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData);
    const parts = [Buffer.from("1901", "hex")];
    parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
    if (sanitizedData.primaryType !== "EIP712Domain") {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
    }
    return util.keccak(Buffer.concat(parts));
  }
};
var ethEip712Util = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,
  hashForSignTypedDataLegacy: function(msgParams) {
    return typedSignatureHashLegacy(msgParams.data);
  },
  hashForSignTypedData_v3: function(msgParams) {
    return TypedDataUtils.hash(msgParams.data, false);
  },
  hashForSignTypedData_v4: function(msgParams) {
    return TypedDataUtils.hash(msgParams.data);
  }
};
function typedSignatureHashLegacy(typedData) {
  const error = new Error("Expect argument to be non-empty array");
  if (typeof typedData !== "object" || !typedData.length)
    throw error;
  const data = typedData.map(function(e2) {
    return e2.type === "bytes" ? util.toBuffer(e2.value) : e2.value;
  });
  const types2 = typedData.map(function(e2) {
    return e2.type;
  });
  const schema = typedData.map(function(e2) {
    if (!e2.name)
      throw error;
    return e2.type + " " + e2.name;
  });
  return abi.soliditySHA3(["bytes32", "bytes32"], [abi.soliditySHA3(new Array(typedData.length).fill("string"), schema), abi.soliditySHA3(types2, data)]);
}
var FilterPolyfill$1 = {};
Object.defineProperty(FilterPolyfill$1, "__esModule", {
  value: true
});
FilterPolyfill$1.filterFromParam = FilterPolyfill$1.FilterPolyfill = void 0;
const types_1$2 = types$2;
const util_1$6 = util$3;
const TIMEOUT = 5 * 60 * 1e3;
const JSONRPC_TEMPLATE = {
  jsonrpc: "2.0",
  id: 0
};
class FilterPolyfill {
  constructor(provider) {
    this.logFilters = /* @__PURE__ */ new Map();
    this.blockFilters = /* @__PURE__ */ new Set();
    this.pendingTransactionFilters = /* @__PURE__ */ new Set();
    this.cursors = /* @__PURE__ */ new Map();
    this.timeouts = /* @__PURE__ */ new Map();
    this.nextFilterId = (0, types_1$2.IntNumber)(1);
    this.provider = provider;
  }
  async newFilter(param) {
    const filter2 = filterFromParam(param);
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, filter2.fromBlock);
    console.log(`Installing new log filter(${id2}):`, filter2, "initial cursor position:", cursor);
    this.logFilters.set(id2, filter2);
    this.setFilterTimeout(id2);
    return (0, util_1$6.hexStringFromIntNumber)(id2);
  }
  async newBlockFilter() {
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, "latest");
    console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
    this.blockFilters.add(id2);
    this.setFilterTimeout(id2);
    return (0, util_1$6.hexStringFromIntNumber)(id2);
  }
  async newPendingTransactionFilter() {
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, "latest");
    console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
    this.pendingTransactionFilters.add(id2);
    this.setFilterTimeout(id2);
    return (0, util_1$6.hexStringFromIntNumber)(id2);
  }
  uninstallFilter(filterId) {
    const id2 = (0, util_1$6.intNumberFromHexString)(filterId);
    console.log(`Uninstalling filter (${id2})`);
    this.deleteFilter(id2);
    return true;
  }
  getFilterChanges(filterId) {
    const id2 = (0, util_1$6.intNumberFromHexString)(filterId);
    if (this.timeouts.has(id2)) {
      this.setFilterTimeout(id2);
    }
    if (this.logFilters.has(id2)) {
      return this.getLogFilterChanges(id2);
    } else if (this.blockFilters.has(id2)) {
      return this.getBlockFilterChanges(id2);
    } else if (this.pendingTransactionFilters.has(id2)) {
      return this.getPendingTransactionFilterChanges(id2);
    }
    return Promise.resolve(filterNotFoundError());
  }
  async getFilterLogs(filterId) {
    const id2 = (0, util_1$6.intNumberFromHexString)(filterId);
    const filter2 = this.logFilters.get(id2);
    if (!filter2) {
      return filterNotFoundError();
    }
    return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
      method: "eth_getLogs",
      params: [paramFromFilter(filter2)]
    }));
  }
  makeFilterId() {
    return (0, types_1$2.IntNumber)(++this.nextFilterId);
  }
  sendAsyncPromise(request) {
    return new Promise((resolve, reject) => {
      this.provider.sendAsync(request, (err, response) => {
        if (err) {
          return reject(err);
        }
        if (Array.isArray(response) || response == null) {
          return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
        }
        resolve(response);
      });
    });
  }
  deleteFilter(id2) {
    console.log(`Deleting filter (${id2})`);
    this.logFilters.delete(id2);
    this.blockFilters.delete(id2);
    this.pendingTransactionFilters.delete(id2);
    this.cursors.delete(id2);
    this.timeouts.delete(id2);
  }
  async getLogFilterChanges(id2) {
    const filter2 = this.logFilters.get(id2);
    const cursorPosition = this.cursors.get(id2);
    if (!cursorPosition || !filter2) {
      return filterNotFoundError();
    }
    const currentBlockHeight = await this.getCurrentBlockHeight();
    const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
    if (cursorPosition > currentBlockHeight) {
      return emptyResult();
    }
    if (cursorPosition > filter2.toBlock) {
      return emptyResult();
    }
    console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id2}`);
    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
      method: "eth_getLogs",
      params: [paramFromFilter(Object.assign(Object.assign({}, filter2), {
        fromBlock: cursorPosition,
        toBlock
      }))]
    }));
    if (Array.isArray(response.result)) {
      const blocks = response.result.map((log4) => (0, util_1$6.intNumberFromHexString)(log4.blockNumber || "0x0"));
      const highestBlock = Math.max(...blocks);
      if (highestBlock && highestBlock > cursorPosition) {
        const newCursorPosition = (0, types_1$2.IntNumber)(highestBlock + 1);
        console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id2, newCursorPosition);
      }
    }
    return response;
  }
  async getBlockFilterChanges(id2) {
    const cursorPosition = this.cursors.get(id2);
    if (!cursorPosition) {
      return filterNotFoundError();
    }
    const currentBlockHeight = await this.getCurrentBlockHeight();
    if (cursorPosition > currentBlockHeight) {
      return emptyResult();
    }
    console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id2})`);
    const blocks = (await Promise.all(
      (0, util_1$6.range)(cursorPosition, currentBlockHeight + 1).map((i) => this.getBlockHashByNumber((0, types_1$2.IntNumber)(i)))
    )).filter((hash2) => !!hash2);
    const newCursorPosition = (0, types_1$2.IntNumber)(cursorPosition + blocks.length);
    console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
    this.cursors.set(id2, newCursorPosition);
    return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
      result: blocks
    });
  }
  async getPendingTransactionFilterChanges(_id) {
    return Promise.resolve(emptyResult());
  }
  async setInitialCursorPosition(id2, startBlock) {
    const currentBlockHeight = await this.getCurrentBlockHeight();
    const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
    this.cursors.set(id2, initialCursorPosition);
    return initialCursorPosition;
  }
  setFilterTimeout(id2) {
    const existing = this.timeouts.get(id2);
    if (existing) {
      window.clearTimeout(existing);
    }
    const timeout2 = window.setTimeout(() => {
      console.log(`Filter (${id2}) timed out`);
      this.deleteFilter(id2);
    }, TIMEOUT);
    this.timeouts.set(id2, timeout2);
  }
  async getCurrentBlockHeight() {
    const {
      result
    } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
      method: "eth_blockNumber",
      params: []
    }));
    return (0, util_1$6.intNumberFromHexString)((0, util_1$6.ensureHexString)(result));
  }
  async getBlockHashByNumber(blockNumber) {
    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
      method: "eth_getBlockByNumber",
      params: [(0, util_1$6.hexStringFromIntNumber)(blockNumber), false]
    }));
    if (response.result && typeof response.result.hash === "string") {
      return (0, util_1$6.ensureHexString)(response.result.hash);
    }
    return null;
  }
}
FilterPolyfill$1.FilterPolyfill = FilterPolyfill;
function filterFromParam(param) {
  return {
    fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
    toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
    addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
    topics: param.topics || []
  };
}
FilterPolyfill$1.filterFromParam = filterFromParam;
function paramFromFilter(filter2) {
  const param = {
    fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
    toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
    topics: filter2.topics
  };
  if (filter2.addresses !== null) {
    param.address = filter2.addresses;
  }
  return param;
}
function intBlockHeightFromHexBlockHeight(value) {
  if (value === void 0 || value === "latest" || value === "pending") {
    return "latest";
  } else if (value === "earliest") {
    return (0, types_1$2.IntNumber)(0);
  } else if ((0, util_1$6.isHexString)(value)) {
    return (0, util_1$6.intNumberFromHexString)(value);
  }
  throw new Error(`Invalid block option: ${String(value)}`);
}
function hexBlockHeightFromIntBlockHeight(value) {
  if (value === "latest") {
    return value;
  }
  return (0, util_1$6.hexStringFromIntNumber)(value);
}
function filterNotFoundError() {
  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
    error: {
      code: -32e3,
      message: "filter not found"
    }
  });
}
function emptyResult() {
  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {
    result: []
  });
}
var JSONRPC = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.JSONRPCMethod = void 0;
  (function(JSONRPCMethod) {
    JSONRPCMethod["eth_accounts"] = "eth_accounts";
    JSONRPCMethod["eth_coinbase"] = "eth_coinbase";
    JSONRPCMethod["net_version"] = "net_version";
    JSONRPCMethod["eth_chainId"] = "eth_chainId";
    JSONRPCMethod["eth_uninstallFilter"] = "eth_uninstallFilter";
    JSONRPCMethod["eth_requestAccounts"] = "eth_requestAccounts";
    JSONRPCMethod["eth_sign"] = "eth_sign";
    JSONRPCMethod["eth_ecRecover"] = "eth_ecRecover";
    JSONRPCMethod["personal_sign"] = "personal_sign";
    JSONRPCMethod["personal_ecRecover"] = "personal_ecRecover";
    JSONRPCMethod["eth_signTransaction"] = "eth_signTransaction";
    JSONRPCMethod["eth_sendRawTransaction"] = "eth_sendRawTransaction";
    JSONRPCMethod["eth_sendTransaction"] = "eth_sendTransaction";
    JSONRPCMethod["eth_signTypedData_v1"] = "eth_signTypedData_v1";
    JSONRPCMethod["eth_signTypedData_v2"] = "eth_signTypedData_v2";
    JSONRPCMethod["eth_signTypedData_v3"] = "eth_signTypedData_v3";
    JSONRPCMethod["eth_signTypedData_v4"] = "eth_signTypedData_v4";
    JSONRPCMethod["eth_signTypedData"] = "eth_signTypedData";
    JSONRPCMethod["cbWallet_arbitrary"] = "walletlink_arbitrary";
    JSONRPCMethod["wallet_addEthereumChain"] = "wallet_addEthereumChain";
    JSONRPCMethod["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
    JSONRPCMethod["wallet_watchAsset"] = "wallet_watchAsset";
    JSONRPCMethod["eth_subscribe"] = "eth_subscribe";
    JSONRPCMethod["eth_unsubscribe"] = "eth_unsubscribe";
    JSONRPCMethod["eth_newFilter"] = "eth_newFilter";
    JSONRPCMethod["eth_newBlockFilter"] = "eth_newBlockFilter";
    JSONRPCMethod["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
    JSONRPCMethod["eth_getFilterChanges"] = "eth_getFilterChanges";
    JSONRPCMethod["eth_getFilterLogs"] = "eth_getFilterLogs";
  })(exports2.JSONRPCMethod || (exports2.JSONRPCMethod = {}));
})(JSONRPC);
var SubscriptionManager$1 = {};
var dist$3 = {};
var PollingBlockTracker$1 = {};
var jsonRpcRandomId = IdIterator;
function IdIterator(opts) {
  opts = opts || {};
  var max2 = opts.max || Number.MAX_SAFE_INTEGER;
  var idCounter2 = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
  return function createRandomId2() {
    idCounter2 = idCounter2 % max2;
    return idCounter2++;
  };
}
const processFn$1 = (fn2, opts) => function() {
  const P2 = opts.promiseModule;
  const args = new Array(arguments.length);
  for (let i = 0; i < arguments.length; i++) {
    args[i] = arguments[i];
  }
  return new P2((resolve, reject) => {
    if (opts.errorFirst) {
      args.push(function(err, result) {
        if (opts.multiArgs) {
          const results = new Array(arguments.length - 1);
          for (let i = 1; i < arguments.length; i++) {
            results[i - 1] = arguments[i];
          }
          if (err) {
            results.unshift(err);
            reject(results);
          } else {
            resolve(results);
          }
        } else if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    } else {
      args.push(function(result) {
        if (opts.multiArgs) {
          const results = new Array(arguments.length - 1);
          for (let i = 0; i < arguments.length; i++) {
            results[i] = arguments[i];
          }
          resolve(results);
        } else {
          resolve(result);
        }
      });
    }
    fn2.apply(this, args);
  });
};
var pify$2 = (obj, opts) => {
  opts = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise
  }, opts);
  const filter2 = (key2) => {
    const match = (pattern2) => typeof pattern2 === "string" ? key2 === pattern2 : pattern2.test(key2);
    return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
  };
  let ret;
  if (typeof obj === "function") {
    ret = function() {
      if (opts.excludeMain) {
        return obj.apply(this, arguments);
      }
      return processFn$1(obj, opts).apply(this, arguments);
    };
  } else {
    ret = Object.create(Object.getPrototypeOf(obj));
  }
  for (const key2 in obj) {
    const x2 = obj[key2];
    ret[key2] = typeof x2 === "function" && filter2(key2) ? processFn$1(x2, opts) : x2;
  }
  return ret;
};
var BaseBlockTracker$1 = {};
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(BaseBlockTracker$1, "__esModule", {
  value: true
});
BaseBlockTracker$1.BaseBlockTracker = void 0;
const safe_event_emitter_1$2 = __importDefault$c(safeEventEmitter);
const sec$1 = 1e3;
const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
const blockTrackerEvents = ["sync", "latest"];
class BaseBlockTracker extends safe_event_emitter_1$2.default {
  constructor(opts) {
    super();
    this._blockResetDuration = opts.blockResetDuration || 20 * sec$1;
    this._currentBlock = null;
    this._isRunning = false;
    this._onNewListener = this._onNewListener.bind(this);
    this._onRemoveListener = this._onRemoveListener.bind(this);
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
    this._setupInternalEvents();
  }
  async destroy() {
    this._cancelBlockResetTimeout();
    await this._maybeEnd();
    super.removeAllListeners();
  }
  isRunning() {
    return this._isRunning;
  }
  getCurrentBlock() {
    return this._currentBlock;
  }
  async getLatestBlock() {
    if (this._currentBlock) {
      return this._currentBlock;
    }
    const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
    return latestBlock;
  }
  removeAllListeners(eventName) {
    if (eventName) {
      super.removeAllListeners(eventName);
    } else {
      super.removeAllListeners();
    }
    this._setupInternalEvents();
    this._onRemoveListener();
    return this;
  }
  _setupInternalEvents() {
    this.removeListener("newListener", this._onNewListener);
    this.removeListener("removeListener", this._onRemoveListener);
    this.on("newListener", this._onNewListener);
    this.on("removeListener", this._onRemoveListener);
  }
  _onNewListener(eventName) {
    if (blockTrackerEvents.includes(eventName)) {
      this._maybeStart();
    }
  }
  _onRemoveListener() {
    if (this._getBlockTrackerEventCount() > 0) {
      return;
    }
    this._maybeEnd();
  }
  async _maybeStart() {
    if (this._isRunning) {
      return;
    }
    this._isRunning = true;
    this._cancelBlockResetTimeout();
    await this._start();
    this.emit("_started");
  }
  async _maybeEnd() {
    if (!this._isRunning) {
      return;
    }
    this._isRunning = false;
    this._setupBlockResetTimeout();
    await this._end();
    this.emit("_ended");
  }
  _getBlockTrackerEventCount() {
    return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
  }
  _newPotentialLatest(newBlock) {
    const currentBlock = this._currentBlock;
    if (currentBlock && hexToInt$4(newBlock) <= hexToInt$4(currentBlock)) {
      return;
    }
    this._setCurrentBlock(newBlock);
  }
  _setCurrentBlock(newBlock) {
    const oldBlock = this._currentBlock;
    this._currentBlock = newBlock;
    this.emit("latest", newBlock);
    this.emit("sync", {
      oldBlock,
      newBlock
    });
  }
  _setupBlockResetTimeout() {
    this._cancelBlockResetTimeout();
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref();
    }
  }
  _cancelBlockResetTimeout() {
    if (this._blockResetTimeout) {
      clearTimeout(this._blockResetTimeout);
    }
  }
  _resetCurrentBlock() {
    this._currentBlock = null;
  }
}
BaseBlockTracker$1.BaseBlockTracker = BaseBlockTracker;
function hexToInt$4(hexInt) {
  return Number.parseInt(hexInt, 16);
}
var loggingUtils = {};
var dist$2 = {};
var assert$2 = {};
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation != null ? explanation : msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached != null ? cached : cached = [failure, ...failures()];
    };
  }
}
function isIterable$1(x2) {
  return isObject$1(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject$1(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isPlainObject(x2) {
  if (Object.prototype.toString.call(x2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(x2);
  return prototype === null || prototype === Object.prototype;
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done: done2, value } = input.next();
  return done2 ? void 0 : value;
}
function toFailure(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct2, value) {
  if (!isIterable$1(result)) {
    result = [result];
  }
  for (const r2 of result) {
    const failure = toFailure(r2, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct2, options = {}) {
  const { path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path, branch };
  if (coerce2) {
    value = struct2.coercer(value, ctx);
    if (mask2 && struct2.type !== "type" && isObject$1(struct2.schema) && isObject$1(value) && !Array.isArray(value)) {
      for (const key2 in value) {
        if (struct2.schema[key2] === void 0) {
          delete value[key2];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct2.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k2, v2, s2] of struct2.entries(value, ctx)) {
    const ts = run(v2, s2, {
      path: k2 === void 0 ? path : [...path, k2],
      branch: k2 === void 0 ? branch : [...branch, v2],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t2 of ts) {
      if (t2[0]) {
        status = t2[0].refinement != null ? "not_refined" : "not_valid";
        yield [t2[0], void 0];
      } else if (coerce2) {
        v2 = t2[1];
        if (k2 === void 0) {
          value = v2;
        } else if (value instanceof Map) {
          value.set(k2, v2);
        } else if (value instanceof Set) {
          value.add(v2);
        } else if (isObject$1(value)) {
          if (v2 !== void 0 || k2 in value)
            value[k2] = v2;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
class Struct {
  constructor(props) {
    const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
    } } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value, message) {
    return assert$1(value, this, message);
  }
  create(value, message) {
    return create3(value, this, message);
  }
  is(value) {
    return is(value, this);
  }
  mask(value, message) {
    return mask(value, this, message);
  }
  validate(value, options = {}) {
    return validate5(value, this, options);
  }
}
function assert$1(value, struct2, message) {
  const result = validate5(value, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create3(value, struct2, message) {
  const result = validate5(value, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct2, message) {
  const result = validate5(value, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct2) {
  const result = validate5(value, struct2);
  return !result[0];
}
function validate5(value, struct2, options = {}) {
  const tuples = run(value, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t2 of tuples) {
        if (t2[0]) {
          yield t2[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v2 = tuple2[1];
    return [void 0, v2];
  }
}
function assign(...Structs) {
  const isType = Structs[0].type === "type";
  const schemas = Structs.map((s2) => s2.schema);
  const schema = Object.assign({}, ...schemas);
  return isType ? type(schema) : object(schema);
}
function define(name2, validator) {
  return new Struct({ type: name2, schema: null, validator });
}
function deprecated(struct2, log4) {
  return new Struct({
    ...struct2,
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx),
    validator(value, ctx) {
      if (value === void 0) {
        return true;
      } else {
        log4(value, ctx);
        return struct2.validator(value, ctx);
      }
    }
  });
}
function dynamic(fn2) {
  return new Struct({
    type: "dynamic",
    schema: null,
    *entries(value, ctx) {
      const struct2 = fn2(value, ctx);
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.refiner(value, ctx);
    }
  });
}
function lazy(fn2) {
  let struct2;
  return new Struct({
    type: "lazy",
    schema: null,
    *entries(value, ctx) {
      struct2 != null ? struct2 : struct2 = fn2();
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      struct2 != null ? struct2 : struct2 = fn2();
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      struct2 != null ? struct2 : struct2 = fn2();
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      struct2 != null ? struct2 : struct2 = fn2();
      return struct2.refiner(value, ctx);
    }
  });
}
function omit(struct2, keys) {
  const { schema } = struct2;
  const subschema = { ...schema };
  for (const key2 of keys) {
    delete subschema[key2];
  }
  switch (struct2.type) {
    case "type":
      return type(subschema);
    default:
      return object(subschema);
  }
}
function partial(struct2) {
  const schema = struct2 instanceof Struct ? { ...struct2.schema } : { ...struct2 };
  for (const key2 in schema) {
    schema[key2] = optional(schema[key2]);
  }
  return object(schema);
}
function pick(struct2, keys) {
  const { schema } = struct2;
  const subschema = {};
  for (const key2 of keys) {
    subschema[key2] = schema[key2];
  }
  return object(subschema);
}
function struct(name2, validator) {
  console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
  return define(name2, validator);
}
function any() {
  return define("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v2] of value.entries()) {
          yield [i, v2, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function bigint() {
  return define("bigint", (value) => {
    return typeof value === "bigint";
  });
}
function boolean() {
  return define("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function date() {
  return define("date", (value) => {
    return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
  });
}
function enums(values) {
  const schema = {};
  const description2 = values.map((v2) => print(v2)).join();
  for (const key2 of values) {
    schema[key2] = key2;
  }
  return new Struct({
    type: "enums",
    schema,
    validator(value) {
      return values.includes(value) || `Expected one of \`${description2}\`, but received: ${print(value)}`;
    }
  });
}
function func() {
  return define("func", (value) => {
    return typeof value === "function" || `Expected a function, but received: ${print(value)}`;
  });
}
function instance(Class) {
  return define("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function integer() {
  return define("integer", (value) => {
    return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
  });
}
function intersection(Structs) {
  return new Struct({
    type: "intersection",
    schema: null,
    *entries(value, ctx) {
      for (const S2 of Structs) {
        yield* S2.entries(value, ctx);
      }
    },
    *validator(value, ctx) {
      for (const S2 of Structs) {
        yield* S2.validator(value, ctx);
      }
    },
    *refiner(value, ctx) {
      for (const S2 of Structs) {
        yield* S2.refiner(value, ctx);
      }
    }
  });
}
function literal(constant) {
  const description2 = print(constant);
  const t2 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description2}\`, but received: ${print(value)}`;
    }
  });
}
function map$1(Key, Value) {
  return new Struct({
    type: "map",
    schema: null,
    *entries(value) {
      if (Key && Value && value instanceof Map) {
        for (const [k2, v2] of value.entries()) {
          yield [k2, k2, Key];
          yield [k2, v2, Value];
        }
      }
    },
    coercer(value) {
      return value instanceof Map ? new Map(value) : value;
    },
    validator(value) {
      return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
    }
  });
}
function never$1() {
  return define("never", () => false);
}
function nullable(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  });
}
function number$1() {
  return define("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never$1();
  return new Struct({
    type: "object",
    schema: schema ? schema : null,
    *entries(value) {
      if (schema && isObject$1(value)) {
        const unknowns = new Set(Object.keys(value));
        for (const key2 of knowns) {
          unknowns.delete(key2);
          yield [key2, value[key2], schema[key2]];
        }
        for (const key2 of unknowns) {
          yield [key2, value[key2], Never];
        }
      }
    },
    validator(value) {
      return isObject$1(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject$1(value) ? { ...value } : value;
    }
  });
}
function optional(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject$1(value)) {
        for (const k2 in value) {
          const v2 = value[k2];
          yield [k2, k2, Key];
          yield [k2, v2, Value];
        }
      }
    },
    validator(value) {
      return isObject$1(value) || `Expected an object, but received: ${print(value)}`;
    }
  });
}
function regexp() {
  return define("regexp", (value) => {
    return value instanceof RegExp;
  });
}
function set(Element) {
  return new Struct({
    type: "set",
    schema: null,
    *entries(value) {
      if (Element && value instanceof Set) {
        for (const v2 of value) {
          yield [v2, v2, Element];
        }
      }
    },
    coercer(value) {
      return value instanceof Set ? new Set(value) : value;
    },
    validator(value) {
      return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
    }
  });
}
function string() {
  return define("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never$1();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i = 0; i < length; i++) {
          yield [i, value[i], Structs[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject$1(value)) {
        for (const k2 of keys) {
          yield [k2, value[k2], schema[k2]];
        }
      }
    },
    validator(value) {
      return isObject$1(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject$1(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description2 = Structs.map((s2) => s2.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run(value, S2, ctx);
        const [first2] = tuples;
        if (!first2[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description2}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce$2(struct2, condition, coercer) {
  return new Struct({
    ...struct2,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  });
}
function defaulted(struct2, fallback, options = {}) {
  return coerce$2(struct2, unknown(), (x2) => {
    const f2 = typeof fallback === "function" ? fallback() : fallback;
    if (x2 === void 0) {
      return f2;
    }
    if (!options.strict && isPlainObject(x2) && isPlainObject(f2)) {
      const ret = { ...x2 };
      let changed = false;
      for (const key2 in f2) {
        if (ret[key2] === void 0) {
          ret[key2] = f2[key2];
          changed = true;
        }
      }
      if (changed) {
        return ret;
      }
    }
    return x2;
  });
}
function trimmed(struct2) {
  return coerce$2(struct2, string(), (x2) => x2.trim());
}
function empty$2(struct2) {
  return refine(struct2, "empty", (value) => {
    const size2 = getSize(value);
    return size2 === 0 || `Expected an empty ${struct2.type} but received one with a size of \`${size2}\``;
  });
}
function getSize(value) {
  if (value instanceof Map || value instanceof Set) {
    return value.size;
  } else {
    return value.length;
  }
}
function max$1(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "max", (value) => {
    return exclusive ? value < threshold : value <= threshold || `Expected a ${struct2.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function min$1(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "min", (value) => {
    return exclusive ? value > threshold : value >= threshold || `Expected a ${struct2.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function nonempty(struct2) {
  return refine(struct2, "nonempty", (value) => {
    const size2 = getSize(value);
    return size2 > 0 || `Expected a nonempty ${struct2.type} but received an empty one`;
  });
}
function pattern(struct2, regexp2) {
  return refine(struct2, "pattern", (value) => {
    return regexp2.test(value) || `Expected a ${struct2.type} matching \`/${regexp2.source}/\` but received "${value}"`;
  });
}
function size(struct2, min2, max2 = min2) {
  const expected = `Expected a ${struct2.type}`;
  const of2 = min2 === max2 ? `of \`${min2}\`` : `between \`${min2}\` and \`${max2}\``;
  return refine(struct2, "size", (value) => {
    if (typeof value === "number" || value instanceof Date) {
      return min2 <= value && value <= max2 || `${expected} ${of2} but received \`${value}\``;
    } else if (value instanceof Map || value instanceof Set) {
      const { size: size2 } = value;
      return min2 <= size2 && size2 <= max2 || `${expected} with a size ${of2} but received one with a size of \`${size2}\``;
    } else {
      const { length } = value;
      return min2 <= length && length <= max2 || `${expected} with a length ${of2} but received one with a length of \`${length}\``;
    }
  });
}
function refine(struct2, name2, refiner) {
  return new Struct({
    ...struct2,
    *refiner(value, ctx) {
      yield* struct2.refiner(value, ctx);
      const result = refiner(value, ctx);
      const failures = toFailures(result, ctx, struct2, value);
      for (const failure of failures) {
        yield { ...failure, refinement: name2 };
      }
    }
  });
}
const dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct,
  StructError,
  any,
  array,
  assert: assert$1,
  assign,
  bigint,
  boolean,
  coerce: coerce$2,
  create: create3,
  date,
  defaulted,
  define,
  deprecated,
  dynamic,
  empty: empty$2,
  enums,
  func,
  instance,
  integer,
  intersection,
  is,
  lazy,
  literal,
  map: map$1,
  mask,
  max: max$1,
  min: min$1,
  never: never$1,
  nonempty,
  nullable,
  number: number$1,
  object,
  omit,
  optional,
  partial,
  pattern,
  pick,
  record,
  refine,
  regexp,
  set,
  size,
  string,
  struct,
  trimmed,
  tuple,
  type,
  union,
  unknown,
  validate: validate5
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
Object.defineProperty(assert$2, "__esModule", {
  value: true
});
assert$2.assertExhaustive = assert$2.assertStruct = assert$2.assert = assert$2.AssertionError = void 0;
const superstruct_1$3 = require$$1$2;
function isErrorWithMessage(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
function isConstructable(fn2) {
  var _a2, _b2;
  return Boolean(typeof ((_b2 = (_a2 = fn2 === null || fn2 === void 0 ? void 0 : fn2.prototype) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b2 === void 0 ? void 0 : _b2.name) === "string");
}
function getErrorMessage(error) {
  const message = isErrorWithMessage(error) ? error.message : String(error);
  if (message.endsWith(".")) {
    return message.slice(0, -1);
  }
  return message;
}
function getError(ErrorWrapper, message) {
  if (isConstructable(ErrorWrapper)) {
    return new ErrorWrapper({
      message
    });
  }
  return ErrorWrapper({
    message
  });
}
class AssertionError extends Error {
  constructor(options) {
    super(options.message);
    this.code = "ERR_ASSERTION";
  }
}
assert$2.AssertionError = AssertionError;
function assert(value, message = "Assertion failed.", ErrorWrapper = AssertionError) {
  if (!value) {
    if (message instanceof Error) {
      throw message;
    }
    throw getError(ErrorWrapper, message);
  }
}
assert$2.assert = assert;
function assertStruct(value, struct2, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError) {
  try {
    (0, superstruct_1$3.assert)(value, struct2);
  } catch (error) {
    throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
  }
}
assert$2.assertStruct = assertStruct;
function assertExhaustive(_object) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
assert$2.assertExhaustive = assertExhaustive;
var base64$1 = {};
Object.defineProperty(base64$1, "__esModule", {
  value: true
});
base64$1.base64 = void 0;
const superstruct_1$2 = require$$1$2;
const assert_1$3 = assert$2;
const base64 = (struct2, options = {}) => {
  var _a2, _b2;
  const paddingRequired = (_a2 = options.paddingRequired) !== null && _a2 !== void 0 ? _a2 : false;
  const characterSet = (_b2 = options.characterSet) !== null && _b2 !== void 0 ? _b2 : "base64";
  let letters;
  if (characterSet === "base64") {
    letters = String.raw`[A-Za-z0-9+\/]`;
  } else {
    (0, assert_1$3.assert)(characterSet === "base64url");
    letters = String.raw`[-_A-Za-z0-9]`;
  }
  let re2;
  if (paddingRequired) {
    re2 = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, "u");
  } else {
    re2 = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, "u");
  }
  return (0, superstruct_1$2.pattern)(struct2, re2);
};
base64$1.base64 = base64;
var bytes = {};
var hex = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.remove0x = exports2.add0x = exports2.assertIsStrictHexString = exports2.assertIsHexString = exports2.isStrictHexString = exports2.isHexString = exports2.StrictHexStruct = exports2.HexStruct = void 0;
  const superstruct_12 = require$$1$2;
  const assert_12 = assert$2;
  exports2.HexStruct = (0, superstruct_12.pattern)((0, superstruct_12.string)(), /^(?:0x)?[0-9a-f]+$/iu);
  exports2.StrictHexStruct = (0, superstruct_12.pattern)((0, superstruct_12.string)(), /^0x[0-9a-f]+$/iu);
  function isHexString2(value) {
    return (0, superstruct_12.is)(value, exports2.HexStruct);
  }
  exports2.isHexString = isHexString2;
  function isStrictHexString(value) {
    return (0, superstruct_12.is)(value, exports2.StrictHexStruct);
  }
  exports2.isStrictHexString = isStrictHexString;
  function assertIsHexString(value) {
    (0, assert_12.assert)(isHexString2(value), "Value must be a hexadecimal string.");
  }
  exports2.assertIsHexString = assertIsHexString;
  function assertIsStrictHexString(value) {
    (0, assert_12.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
  }
  exports2.assertIsStrictHexString = assertIsStrictHexString;
  function add0x(hexadecimal) {
    if (hexadecimal.startsWith("0x")) {
      return hexadecimal;
    }
    if (hexadecimal.startsWith("0X")) {
      return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
  }
  exports2.add0x = add0x;
  function remove0x(hexadecimal) {
    if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
      return hexadecimal.substring(2);
    }
    return hexadecimal;
  }
  exports2.remove0x = remove0x;
})(hex);
Object.defineProperty(bytes, "__esModule", {
  value: true
});
bytes.createDataView = bytes.concatBytes = bytes.valueToBytes = bytes.stringToBytes = bytes.numberToBytes = bytes.signedBigIntToBytes = bytes.bigIntToBytes = bytes.hexToBytes = bytes.bytesToString = bytes.bytesToNumber = bytes.bytesToSignedBigInt = bytes.bytesToBigInt = bytes.bytesToHex = bytes.assertIsBytes = bytes.isBytes = void 0;
const assert_1$2 = assert$2;
const hex_1$2 = hex;
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
function getPrecomputedHexValuesBuilder() {
  const lookupTable = [];
  return () => {
    if (lookupTable.length === 0) {
      for (let i = 0; i < 256; i++) {
        lookupTable.push(i.toString(16).padStart(2, "0"));
      }
    }
    return lookupTable;
  };
}
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
function isBytes(value) {
  return value instanceof Uint8Array;
}
bytes.isBytes = isBytes;
function assertIsBytes(value) {
  (0, assert_1$2.assert)(isBytes(value), "Value must be a Uint8Array.");
}
bytes.assertIsBytes = assertIsBytes;
function bytesToHex(bytes3) {
  assertIsBytes(bytes3);
  if (bytes3.length === 0) {
    return "0x";
  }
  const lookupTable = getPrecomputedHexValues();
  const hexadecimal = new Array(bytes3.length);
  for (let i = 0; i < bytes3.length; i++) {
    hexadecimal[i] = lookupTable[bytes3[i]];
  }
  return (0, hex_1$2.add0x)(hexadecimal.join(""));
}
bytes.bytesToHex = bytesToHex;
function bytesToBigInt(bytes3) {
  assertIsBytes(bytes3);
  const hexadecimal = bytesToHex(bytes3);
  return BigInt(hexadecimal);
}
bytes.bytesToBigInt = bytesToBigInt;
function bytesToSignedBigInt(bytes3) {
  assertIsBytes(bytes3);
  let value = BigInt(0);
  for (const byte2 of bytes3) {
    value = (value << BigInt(8)) + BigInt(byte2);
  }
  return BigInt.asIntN(bytes3.length * 8, value);
}
bytes.bytesToSignedBigInt = bytesToSignedBigInt;
function bytesToNumber(bytes3) {
  assertIsBytes(bytes3);
  const bigint2 = bytesToBigInt(bytes3);
  (0, assert_1$2.assert)(bigint2 <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead.");
  return Number(bigint2);
}
bytes.bytesToNumber = bytesToNumber;
function bytesToString(bytes3) {
  assertIsBytes(bytes3);
  return new TextDecoder().decode(bytes3);
}
bytes.bytesToString = bytesToString;
function hexToBytes(value) {
  var _a2;
  if (((_a2 = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a2 === void 0 ? void 0 : _a2.call(value)) === "0x") {
    return new Uint8Array();
  }
  (0, hex_1$2.assertIsHexString)(value);
  const strippedValue = (0, hex_1$2.remove0x)(value).toLowerCase();
  const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
  const bytes3 = new Uint8Array(normalizedValue.length / 2);
  for (let i = 0; i < bytes3.length; i++) {
    const c1 = normalizedValue.charCodeAt(i * 2);
    const c2 = normalizedValue.charCodeAt(i * 2 + 1);
    const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    bytes3[i] = n1 * 16 + n2;
  }
  return bytes3;
}
bytes.hexToBytes = hexToBytes;
function bigIntToBytes(value) {
  (0, assert_1$2.assert)(typeof value === "bigint", "Value must be a bigint.");
  (0, assert_1$2.assert)(value >= BigInt(0), "Value must be a non-negative bigint.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
bytes.bigIntToBytes = bigIntToBytes;
function bigIntFits(value, bytes3) {
  (0, assert_1$2.assert)(bytes3 > 0);
  const mask2 = value >> BigInt(31);
  return !((~value & mask2) + (value & ~mask2) >> BigInt(bytes3 * 8 + ~0));
}
function signedBigIntToBytes(value, byteLength2) {
  (0, assert_1$2.assert)(typeof value === "bigint", "Value must be a bigint.");
  (0, assert_1$2.assert)(typeof byteLength2 === "number", "Byte length must be a number.");
  (0, assert_1$2.assert)(byteLength2 > 0, "Byte length must be greater than 0.");
  (0, assert_1$2.assert)(bigIntFits(value, byteLength2), "Byte length is too small to represent the given value.");
  let numberValue = value;
  const bytes3 = new Uint8Array(byteLength2);
  for (let i = 0; i < bytes3.length; i++) {
    bytes3[i] = Number(BigInt.asUintN(8, numberValue));
    numberValue >>= BigInt(8);
  }
  return bytes3.reverse();
}
bytes.signedBigIntToBytes = signedBigIntToBytes;
function numberToBytes(value) {
  (0, assert_1$2.assert)(typeof value === "number", "Value must be a number.");
  (0, assert_1$2.assert)(value >= 0, "Value must be a non-negative number.");
  (0, assert_1$2.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const hexadecimal = value.toString(16);
  return hexToBytes(hexadecimal);
}
bytes.numberToBytes = numberToBytes;
function stringToBytes(value) {
  (0, assert_1$2.assert)(typeof value === "string", "Value must be a string.");
  return new TextEncoder().encode(value);
}
bytes.stringToBytes = stringToBytes;
function valueToBytes(value) {
  if (typeof value === "bigint") {
    return bigIntToBytes(value);
  }
  if (typeof value === "number") {
    return numberToBytes(value);
  }
  if (typeof value === "string") {
    if (value.startsWith("0x")) {
      return hexToBytes(value);
    }
    return stringToBytes(value);
  }
  if (isBytes(value)) {
    return value;
  }
  throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
bytes.valueToBytes = valueToBytes;
function concatBytes(values) {
  const normalizedValues = new Array(values.length);
  let byteLength2 = 0;
  for (let i = 0; i < values.length; i++) {
    const value = valueToBytes(values[i]);
    normalizedValues[i] = value;
    byteLength2 += value.length;
  }
  const bytes3 = new Uint8Array(byteLength2);
  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
    bytes3.set(normalizedValues[i], offset);
    offset += normalizedValues[i].length;
  }
  return bytes3;
}
bytes.concatBytes = concatBytes;
function createDataView(bytes3) {
  if (typeof Buffer !== "undefined" && bytes3 instanceof Buffer) {
    const buffer2 = bytes3.buffer.slice(bytes3.byteOffset, bytes3.byteOffset + bytes3.byteLength);
    return new DataView(buffer2);
  }
  return new DataView(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
}
bytes.createDataView = createDataView;
var checksum = {};
Object.defineProperty(checksum, "__esModule", {
  value: true
});
checksum.ChecksumStruct = void 0;
const superstruct_1$1 = require$$1$2;
const base64_1 = base64$1;
checksum.ChecksumStruct = (0, superstruct_1$1.size)((0, base64_1.base64)((0, superstruct_1$1.string)(), {
  paddingRequired: true
}), 44, 44);
var coercers = {};
Object.defineProperty(coercers, "__esModule", {
  value: true
});
coercers.createHex = coercers.createBytes = coercers.createBigInt = coercers.createNumber = void 0;
const superstruct_1 = require$$1$2;
const assert_1$1 = assert$2;
const bytes_1 = bytes;
const hex_1$1 = hex;
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1$1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
(0, superstruct_1.union)([hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1$1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
function createNumber(value) {
  try {
    const result = (0, superstruct_1.create)(value, NumberCoercer);
    (0, assert_1$1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
    return result;
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a number-like value, got "${value}".`);
    }
    throw error;
  }
}
coercers.createNumber = createNumber;
function createBigInt(value) {
  try {
    return (0, superstruct_1.create)(value, BigIntCoercer);
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
    }
    throw error;
  }
}
coercers.createBigInt = createBigInt;
function createBytes(value) {
  if (typeof value === "string" && value.toLowerCase() === "0x") {
    return new Uint8Array();
  }
  try {
    return (0, superstruct_1.create)(value, BytesCoercer);
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
    }
    throw error;
  }
}
coercers.createBytes = createBytes;
function createHex(value) {
  if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
    return "0x";
  }
  try {
    return (0, superstruct_1.create)(value, HexCoercer);
  } catch (error) {
    if (error instanceof superstruct_1.StructError) {
      throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
    }
    throw error;
  }
}
coercers.createHex = createHex;
var collections = {};
var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state2, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state2.set(receiver, value), value;
};
var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state2, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(collections, "__esModule", {
  value: true
});
collections.FrozenSet = collections.FrozenMap = void 0;
class FrozenMap {
  constructor(entries) {
    _FrozenMap_map.set(this, void 0);
    __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
    Object.freeze(this);
  }
  get size() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
  }
  [(_FrozenMap_map = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
  }
  entries() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
  }
  forEach(callbackfn, thisArg) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key2, _map) => callbackfn.call(thisArg, value, key2, this));
  }
  get(key2) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key2);
  }
  has(key2) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key2);
  }
  keys() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
  }
  values() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key2, value]) => `${String(key2)} => ${String(value)}`).join(", ")} ` : ""}}`;
  }
}
collections.FrozenMap = FrozenMap;
class FrozenSet {
  constructor(values) {
    _FrozenSet_set.set(this, void 0);
    __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
    Object.freeze(this);
  }
  get size() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
  }
  [(_FrozenSet_set = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
  }
  entries() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
  }
  forEach(callbackfn, thisArg) {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
  }
  has(value) {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
  }
  keys() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
  }
  values() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
  }
}
collections.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
var json = {};
var misc = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.calculateNumberSize = exports2.calculateStringSize = exports2.isASCII = exports2.isPlainObject = exports2.ESCAPE_CHARACTERS_REGEXP = exports2.JsonSize = exports2.hasProperty = exports2.isObject = exports2.isNullOrUndefined = exports2.isNonEmptyArray = void 0;
  function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
  }
  exports2.isNonEmptyArray = isNonEmptyArray;
  function isNullOrUndefined(value) {
    return value === null || value === void 0;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isObject2(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
  }
  exports2.isObject = isObject2;
  const hasProperty = (objectToCheck, name2) => Object.hasOwnProperty.call(objectToCheck, name2);
  exports2.hasProperty = hasProperty;
  (function(JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    JsonSize[JsonSize["Date"] = 24] = "Date";
  })(exports2.JsonSize || (exports2.JsonSize = {}));
  exports2.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function isPlainObject2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    try {
      let proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    } catch (_2) {
      return false;
    }
  }
  exports2.isPlainObject = isPlainObject2;
  function isASCII(character) {
    return character.charCodeAt(0) <= 127;
  }
  exports2.isASCII = isASCII;
  function calculateStringSize(value) {
    var _a2;
    const size2 = value.split("").reduce((total, character) => {
      if (isASCII(character)) {
        return total + 1;
      }
      return total + 2;
    }, 0);
    return size2 + ((_a2 = value.match(exports2.ESCAPE_CHARACTERS_REGEXP)) !== null && _a2 !== void 0 ? _a2 : []).length;
  }
  exports2.calculateStringSize = calculateStringSize;
  function calculateNumberSize(value) {
    return value.toString().length;
  }
  exports2.calculateNumberSize = calculateNumberSize;
})(misc);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.validateJsonAndGetSize = exports2.getJsonRpcIdValidator = exports2.assertIsJsonRpcError = exports2.isJsonRpcError = exports2.assertIsJsonRpcFailure = exports2.isJsonRpcFailure = exports2.assertIsJsonRpcSuccess = exports2.isJsonRpcSuccess = exports2.assertIsJsonRpcResponse = exports2.isJsonRpcResponse = exports2.assertIsPendingJsonRpcResponse = exports2.isPendingJsonRpcResponse = exports2.JsonRpcResponseStruct = exports2.JsonRpcFailureStruct = exports2.JsonRpcSuccessStruct = exports2.PendingJsonRpcResponseStruct = exports2.assertIsJsonRpcRequest = exports2.isJsonRpcRequest = exports2.assertIsJsonRpcNotification = exports2.isJsonRpcNotification = exports2.JsonRpcNotificationStruct = exports2.JsonRpcRequestStruct = exports2.JsonRpcParamsStruct = exports2.JsonRpcErrorStruct = exports2.JsonRpcIdStruct = exports2.JsonRpcVersionStruct = exports2.jsonrpc2 = exports2.isValidJson = exports2.JsonStruct = void 0;
  const superstruct_12 = require$$1$2;
  const assert_12 = assert$2;
  const misc_1 = misc;
  exports2.JsonStruct = (0, superstruct_12.define)("Json", (value) => {
    const [isValid3] = validateJsonAndGetSize(value, true);
    if (!isValid3) {
      return "Expected a valid JSON-serializable value";
    }
    return true;
  });
  function isValidJson(value) {
    return (0, superstruct_12.is)(value, exports2.JsonStruct);
  }
  exports2.isValidJson = isValidJson;
  exports2.jsonrpc2 = "2.0";
  exports2.JsonRpcVersionStruct = (0, superstruct_12.literal)(exports2.jsonrpc2);
  exports2.JsonRpcIdStruct = (0, superstruct_12.nullable)((0, superstruct_12.union)([(0, superstruct_12.number)(), (0, superstruct_12.string)()]));
  exports2.JsonRpcErrorStruct = (0, superstruct_12.object)({
    code: (0, superstruct_12.integer)(),
    message: (0, superstruct_12.string)(),
    data: (0, superstruct_12.optional)(exports2.JsonStruct),
    stack: (0, superstruct_12.optional)((0, superstruct_12.string)())
  });
  exports2.JsonRpcParamsStruct = (0, superstruct_12.optional)((0, superstruct_12.union)([(0, superstruct_12.record)((0, superstruct_12.string)(), exports2.JsonStruct), (0, superstruct_12.array)(exports2.JsonStruct)]));
  exports2.JsonRpcRequestStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    method: (0, superstruct_12.string)(),
    params: exports2.JsonRpcParamsStruct
  });
  exports2.JsonRpcNotificationStruct = (0, superstruct_12.omit)(exports2.JsonRpcRequestStruct, ["id"]);
  function isJsonRpcNotification(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcNotificationStruct);
  }
  exports2.isJsonRpcNotification = isJsonRpcNotification;
  function assertIsJsonRpcNotification(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", ErrorWrapper);
  }
  exports2.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
  function isJsonRpcRequest2(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcRequestStruct);
  }
  exports2.isJsonRpcRequest = isJsonRpcRequest2;
  function assertIsJsonRpcRequest(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcRequestStruct, "Invalid JSON-RPC request", ErrorWrapper);
  }
  exports2.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
  exports2.PendingJsonRpcResponseStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    result: (0, superstruct_12.optional)((0, superstruct_12.unknown)()),
    error: (0, superstruct_12.optional)(exports2.JsonRpcErrorStruct)
  });
  exports2.JsonRpcSuccessStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    result: exports2.JsonStruct
  });
  exports2.JsonRpcFailureStruct = (0, superstruct_12.object)({
    id: exports2.JsonRpcIdStruct,
    jsonrpc: exports2.JsonRpcVersionStruct,
    error: exports2.JsonRpcErrorStruct
  });
  exports2.JsonRpcResponseStruct = (0, superstruct_12.union)([exports2.JsonRpcSuccessStruct, exports2.JsonRpcFailureStruct]);
  function isPendingJsonRpcResponse(response) {
    return (0, superstruct_12.is)(response, exports2.PendingJsonRpcResponseStruct);
  }
  exports2.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
  function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
    (0, assert_12.assertStruct)(response, exports2.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", ErrorWrapper);
  }
  exports2.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
  function isJsonRpcResponse2(response) {
    return (0, superstruct_12.is)(response, exports2.JsonRpcResponseStruct);
  }
  exports2.isJsonRpcResponse = isJsonRpcResponse2;
  function assertIsJsonRpcResponse(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcResponseStruct, "Invalid JSON-RPC response", ErrorWrapper);
  }
  exports2.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
  function isJsonRpcSuccess(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcSuccessStruct);
  }
  exports2.isJsonRpcSuccess = isJsonRpcSuccess;
  function assertIsJsonRpcSuccess(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", ErrorWrapper);
  }
  exports2.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
  function isJsonRpcFailure(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcFailureStruct);
  }
  exports2.isJsonRpcFailure = isJsonRpcFailure;
  function assertIsJsonRpcFailure(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", ErrorWrapper);
  }
  exports2.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
  function isJsonRpcError2(value) {
    return (0, superstruct_12.is)(value, exports2.JsonRpcErrorStruct);
  }
  exports2.isJsonRpcError = isJsonRpcError2;
  function assertIsJsonRpcError(value, ErrorWrapper) {
    (0, assert_12.assertStruct)(value, exports2.JsonRpcErrorStruct, "Invalid JSON-RPC error", ErrorWrapper);
  }
  exports2.assertIsJsonRpcError = assertIsJsonRpcError;
  function getJsonRpcIdValidator(options) {
    const {
      permitEmptyString,
      permitFractions,
      permitNull
    } = Object.assign({
      permitEmptyString: true,
      permitFractions: false,
      permitNull: true
    }, options);
    const isValidJsonRpcId = (id2) => {
      return Boolean(typeof id2 === "number" && (permitFractions || Number.isInteger(id2)) || typeof id2 === "string" && (permitEmptyString || id2.length > 0) || permitNull && id2 === null);
    };
    return isValidJsonRpcId;
  }
  exports2.getJsonRpcIdValidator = getJsonRpcIdValidator;
  function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = /* @__PURE__ */ new Set();
    function getJsonSerializableInfo(value, skipSizing) {
      if (value === void 0) {
        return [false, 0];
      } else if (value === null) {
        return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
      }
      const typeOfValue = typeof value;
      try {
        if (typeOfValue === "function") {
          return [false, 0];
        } else if (typeOfValue === "string" || value instanceof String) {
          return [true, skipSizing ? 0 : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2];
        } else if (typeOfValue === "boolean" || value instanceof Boolean) {
          if (skipSizing) {
            return [true, 0];
          }
          return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
        } else if (typeOfValue === "number" || value instanceof Number) {
          if (skipSizing) {
            return [true, 0];
          }
          return [true, (0, misc_1.calculateNumberSize)(value)];
        } else if (value instanceof Date) {
          if (skipSizing) {
            return [true, 0];
          }
          return [
            true,
            isNaN(value.getDate()) ? misc_1.JsonSize.Null : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2
          ];
        }
      } catch (_2) {
        return [false, 0];
      }
      if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
        return [false, 0];
      }
      if (seenObjects.has(value)) {
        return [false, 0];
      }
      seenObjects.add(value);
      try {
        return [true, Object.entries(value).reduce(
          (sum, [key2, nestedValue], idx, arr2) => {
            let [valid2, size2] = getJsonSerializableInfo(nestedValue, skipSizing);
            if (!valid2) {
              throw new Error("JSON validation did not pass. Validation process stopped.");
            }
            seenObjects.delete(value);
            if (skipSizing) {
              return 0;
            }
            const keySize = Array.isArray(value) ? 0 : key2.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
            const separator = idx < arr2.length - 1 ? misc_1.JsonSize.Comma : 0;
            return sum + keySize + size2 + separator;
          },
          skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2
        )];
      } catch (_2) {
        return [false, 0];
      }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
  }
  exports2.validateJsonAndGetSize = validateJsonAndGetSize;
})(json);
var logging = {};
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w2;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name2) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy2;
  Object.keys(env2).forEach((key2) => {
    createDebug[key2] = env2[key2];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash2 = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend2;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v2) => {
        enableOverride = v2;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split2.length;
    for (i = 0; i < len; i++) {
      if (!split2[i]) {
        continue;
      }
      namespaces = split2[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name2)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp2) {
    return regexp2.toString().substring(2, regexp2.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common = setup;
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = process.env.DEBUG;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = common(exports2);
  const {
    formatters
  } = module2.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser, browser.exports);
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(logging, "__esModule", {
  value: true
});
logging.createModuleLogger = logging.createProjectLogger = void 0;
const debug_1$1 = __importDefault$b(browser.exports);
const globalLogger = (0, debug_1$1.default)("metamask");
function createProjectLogger(projectName) {
  return globalLogger.extend(projectName);
}
logging.createProjectLogger = createProjectLogger;
function createModuleLogger(projectLogger, moduleName) {
  return projectLogger.extend(moduleName);
}
logging.createModuleLogger = createModuleLogger;
var number = {};
Object.defineProperty(number, "__esModule", {
  value: true
});
number.hexToBigInt = number.hexToNumber = number.bigIntToHex = number.numberToHex = void 0;
const assert_1 = assert$2;
const hex_1 = hex;
const numberToHex = (value) => {
  (0, assert_1.assert)(typeof value === "number", "Value must be a number.");
  (0, assert_1.assert)(value >= 0, "Value must be a non-negative number.");
  (0, assert_1.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToHex` instead.");
  return (0, hex_1.add0x)(value.toString(16));
};
number.numberToHex = numberToHex;
const bigIntToHex = (value) => {
  (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
  (0, assert_1.assert)(value >= 0, "Value must be a non-negative bigint.");
  return (0, hex_1.add0x)(value.toString(16));
};
number.bigIntToHex = bigIntToHex;
const hexToNumber = (value) => {
  (0, hex_1.assertIsHexString)(value);
  const numberValue = parseInt(value, 16);
  (0, assert_1.assert)(Number.isSafeInteger(numberValue), "Value is not a safe integer. Use `hexToBigInt` instead.");
  return numberValue;
};
number.hexToNumber = hexToNumber;
const hexToBigInt = (value) => {
  (0, hex_1.assertIsHexString)(value);
  return BigInt((0, hex_1.add0x)(value));
};
number.hexToBigInt = hexToBigInt;
var opaque = {};
Object.defineProperty(opaque, "__esModule", {
  value: true
});
var time = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.timeSince = exports2.inMilliseconds = exports2.Duration = void 0;
  (function(Duration) {
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    Duration[Duration["Second"] = 1e3] = "Second";
    Duration[Duration["Minute"] = 6e4] = "Minute";
    Duration[Duration["Hour"] = 36e5] = "Hour";
    Duration[Duration["Day"] = 864e5] = "Day";
    Duration[Duration["Week"] = 6048e5] = "Week";
    Duration[Duration["Year"] = 31536e6] = "Year";
  })(exports2.Duration || (exports2.Duration = {}));
  const isNonNegativeInteger = (number2) => Number.isInteger(number2) && number2 >= 0;
  const assertIsNonNegativeInteger = (number2, name2) => {
    if (!isNonNegativeInteger(number2)) {
      throw new Error(`"${name2}" must be a non-negative integer. Received: "${number2}".`);
    }
  };
  function inMilliseconds(count2, duration) {
    assertIsNonNegativeInteger(count2, "count");
    return count2 * duration;
  }
  exports2.inMilliseconds = inMilliseconds;
  function timeSince(timestamp2) {
    assertIsNonNegativeInteger(timestamp2, "timestamp");
    return Date.now() - timestamp2;
  }
  exports2.timeSince = timeSince;
})(time);
var versions = {};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
var constants$2 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module2, exports2) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$2;
  const debug2 = debug_1;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const safeRe = exports2.safeRe = [];
  const src6 = exports2.src = [];
  const t2 = exports2.t = {};
  let R2 = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [["\\s", 1], ["\\d", MAX_LENGTH2], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]];
  const makeSafeRegex = (value) => {
    for (const [token2, max2] of safeRegexReplacements) {
      value = value.split(`${token2}*`).join(`${token2}{0,${max2}}`).split(`${token2}+`).join(`${token2}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index2 = R2++;
    debug2(name2, index2, value);
    t2[name2] = index2;
    src6[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src6[t2.NUMERICIDENTIFIER]})\\.(${src6[t2.NUMERICIDENTIFIER]})\\.(${src6[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src6[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src6[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src6[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src6[t2.NUMERICIDENTIFIER]}|${src6[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src6[t2.NUMERICIDENTIFIERLOOSE]}|${src6[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src6[t2.PRERELEASEIDENTIFIER]}(?:\\.${src6[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src6[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src6[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src6[t2.BUILDIDENTIFIER]}(?:\\.${src6[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src6[t2.MAINVERSION]}${src6[t2.PRERELEASE]}?${src6[t2.BUILD]}?`);
  createToken("FULL", `^${src6[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src6[t2.MAINVERSIONLOOSE]}${src6[t2.PRERELEASELOOSE]}?${src6[t2.BUILD]}?`);
  createToken("LOOSE", `^${src6[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src6[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src6[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src6[t2.XRANGEIDENTIFIER]})(?:\\.(${src6[t2.XRANGEIDENTIFIER]})(?:\\.(${src6[t2.XRANGEIDENTIFIER]})(?:${src6[t2.PRERELEASE]})?${src6[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src6[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src6[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src6[t2.XRANGEIDENTIFIERLOOSE]})(?:${src6[t2.PRERELEASELOOSE]})?${src6[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src6[t2.GTLT]}\\s*${src6[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src6[t2.GTLT]}\\s*${src6[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src6[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src6[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src6[t2.LONETILDE]}${src6[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src6[t2.LONETILDE]}${src6[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src6[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src6[t2.LONECARET]}${src6[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src6[t2.LONECARET]}${src6[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src6[t2.GTLT]}\\s*(${src6[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src6[t2.GTLT]}\\s*(${src6[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src6[t2.GTLT]}\\s*(${src6[t2.LOOSEPLAIN]}|${src6[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src6[t2.XRANGEPLAIN]})\\s+-\\s+(${src6[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src6[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src6[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
const looseOption = Object.freeze({
  loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a2, b2) => {
  const anum = numeric.test(a2);
  const bnum = numeric.test(b2);
  if (anum && bnum) {
    a2 = +a2;
    b2 = +b2;
  }
  return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
};
const rcompareIdentifiers = (a2, b2) => compareIdentifiers$1(b2, a2);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const {
  MAX_LENGTH,
  MAX_SAFE_INTEGER
} = constants$2;
const {
  safeRe: re$1,
  t: t$1
} = re$2.exports;
const parseOptions = parseOptions_1;
const {
  compareIdentifiers
} = identifiers$1;
class SemVer$d {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer$d) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version2.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$d)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$d(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$d)) {
      other = new SemVer$d(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$d)) {
      other = new SemVer$d(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a2 = this.prerelease[i];
      const b2 = other.prerelease[i];
      debug("prerelease compare", i, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$d)) {
      other = new SemVer$d(other, this.options);
    }
    let i = 0;
    do {
      const a2 = this.build[i];
      const b2 = other.build[i];
      debug("prerelease compare", i, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i);
  }
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base3 = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base3];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base3);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base3];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
}
var semver$1 = SemVer$d;
const SemVer$c = semver$1;
const parse$6 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version2, options) => {
  const v2 = parse$5(version2, options);
  return v2 ? v2.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version2, options) => {
  const s2 = parse$4(version2.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$1;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(version2 instanceof SemVer$b ? version2.version : version2, options).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$1;
const major$1 = (a2, loose) => new SemVer$a(a2, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$1;
const minor$1 = (a2, loose) => new SemVer$9(a2, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$1;
const patch$1 = (a2, loose) => new SemVer$8(a2, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version2, options) => {
  const parsed = parse$2(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$1;
const compare$b = (a2, b2, loose) => new SemVer$7(a2, loose).compare(new SemVer$7(b2, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a2, b2, loose) => compare$a(b2, a2, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a2, b2) => compare$9(a2, b2, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$1;
const compareBuild$3 = (a2, b2, loose) => {
  const versionA = new SemVer$6(a2, loose);
  const versionB = new SemVer$6(b2, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$2(a2, b2, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$1(b2, a2, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a2, b2, loose) => compare$8(a2, b2, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a2, b2, loose) => compare$7(a2, b2, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a2, b2, loose) => compare$6(a2, b2, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a2, b2, loose) => compare$5(a2, b2, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a2, b2, loose) => compare$4(a2, b2, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a2, b2, loose) => compare$3(a2, b2, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a2, op, b2, loose) => {
  switch (op) {
    case "===":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 === b2;
    case "!==":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 !== b2;
    case "":
    case "=":
    case "==":
      return eq$1(a2, b2, loose);
    case "!=":
      return neq$1(a2, b2, loose);
    case ">":
      return gt$3(a2, b2, loose);
    case ">=":
      return gte$2(a2, b2, loose);
    case "<":
      return lt$2(a2, b2, loose);
    case "<=":
      return lte$2(a2, b2, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$1;
const parse$1 = parse_1;
const {
  safeRe: re,
  t
} = re$2.exports;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(re[t.COERCE]);
  } else {
    let next;
    while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re[t.COERCERTL].lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  return parse$1(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce$1;
var iterator$1;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator$1;
  hasRequiredIterator = 1;
  iterator$1 = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator$1;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l2 = arguments.length; i < l2; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn2, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn2.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn2, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn2.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n2) {
  for (var i = 0, walker = this.head; walker !== null && i < n2; i++) {
    walker = walker.next;
  }
  if (i === n2 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n2) {
  for (var i = 0, walker = this.tail; walker !== null && i < n2; i++) {
    walker = walker.prev;
  }
  if (i === n2 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn2, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn2.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn2, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn2.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn2, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn2(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn2, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn2(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr2 = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr2[i] = walker.value;
    walker = walker.next;
  }
  return arr2;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr2 = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr2[i] = walker.value;
    walker = walker.prev;
  }
  return arr2;
};
Yallist$1.prototype.slice = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from2; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from2; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p2 = walker.prev;
    walker.prev = walker.next;
    walker.next = p2;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX$1 = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = {
        max: options
      };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX$1] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX$1] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX$1];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn2, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn2, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn2, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn2, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k2) => k2.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k2) => k2.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key2, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key2);
    if (this[CACHE].has(key2)) {
      if (len > this[MAX$1]) {
        del(this, this[CACHE].get(key2));
        return false;
      }
      const node = this[CACHE].get(key2);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key2, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key2);
      trim(this);
      return true;
    }
    const hit = new Entry(key2, value, len, now, maxAge);
    if (hit.length > this[MAX$1]) {
      if (this[DISPOSE])
        this[DISPOSE](key2, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key2, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key2) {
    if (!this[CACHE].has(key2))
      return false;
    const hit = this[CACHE].get(key2).value;
    return !isStale(this, hit);
  }
  get(key2) {
    return get(this, key2, true);
  }
  peek(key2) {
    return get(this, key2, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key2) {
    del(this, this[CACHE].get(key2));
  }
  load(arr2) {
    this.reset();
    const now = Date.now();
    for (let l2 = arr2.length - 1; l2 >= 0; l2--) {
      const hit = arr2[l2];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key2) => get(this, key2, false));
  }
}
const get = (self2, key2, doUse) => {
  const node = self2[CACHE].get(key2);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX$1]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX$1] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key2, value, length, now, maxAge) {
    this.key = key2;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn2, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn2.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
var range$1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range$1;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer2(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range$1 = Range2;
  const LRU = lruCache;
  const cache = new LRU({
    max: 1e3
  });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer2 = semver$1;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = re$2.exports;
  const {
    FLAG_INCLUDE_PRERELEASE,
    FLAG_LOOSE
  } = constants$2;
  const isNullSet = (c2) => c2.value === "<0.0.0-0";
  const isAny = (c2) => c2.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r2 = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r2, (_2, M2, m2, p2, pr) => {
      debug2("tilde", comp, _2, M2, m2, p2, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX(p2)) {
        ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m2}.${p2} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r2 = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_2, M2, m2, p2, pr) => {
      debug2("caret", comp, _2, M2, m2, p2, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
      } else if (isX(p2)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p2} <${+M2 + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r2, (ret, gtlt, M2, m2, p2, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m2, p2, pr);
      const xM = isX(M2);
      const xm = xM || isX(m2);
      const xp = xm || isX(p2);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p2 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p2 = 0;
          } else {
            m2 = +m2 + 1;
            p2 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M2}.${m2}.${p2}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from2 = "";
    } else if (isX(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range$1;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer2(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer2(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const {
    safeRe: re2,
    t: t2
  } = re$2.exports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer2 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$1;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions2, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions2.forEach((v2) => {
    if (rangeObj.test(v2)) {
      if (!max2 || maxSV.compare(v2) === -1) {
        max2 = v2;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const minSatisfying$1 = (versions2, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions2.forEach((v2) => {
    if (rangeObj.test(v2)) {
      if (!min2 || minSV.compare(v2) === 1) {
        min2 = v2;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$1;
const Comparator$2 = requireComparator();
const {
  ANY: ANY$1
} = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions2, range2, options) => {
  const set2 = [];
  let first2 = null;
  let prev = null;
  const v2 = versions2.sort((a2, b2) => compare$2(a2, b2, options));
  for (const version2 of v2) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first2) {
        first2 = version2;
      }
    } else {
      if (prev) {
        set2.push([first2, prev]);
      }
      prev = null;
      first2 = null;
    }
  }
  if (first2) {
    set2.push([first2, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v2[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v2[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const {
  ANY
} = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c2 of sub) {
    if (c2.operator === ">" || c2.operator === ">=") {
      gt2 = higherGT(gt2, c2, options);
    } else if (c2.operator === "<" || c2.operator === "<=") {
      lt2 = lowerLT(lt2, c2, options);
    } else {
      eqSet.add(c2.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq5 of eqSet) {
    if (gt2 && !satisfies$1(eq5, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq5, String(lt2), options)) {
      return null;
    }
    for (const c2 of dom) {
      if (!satisfies$1(eq5, String(c2), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c2 of dom) {
    hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
    hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c2.operator === ">" || c2.operator === ">=") {
        higher = higherGT(gt2, c2, options);
        if (higher === c2 && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c2.operator === "<" || c2.operator === "<=") {
        lower = lowerLT(lt2, c2, options);
        if (lower === c2 && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a2, b2, options) => {
  if (!a2) {
    return b2;
  }
  const comp = compare$1(a2.semver, b2.semver, options);
  return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
};
const lowerLT = (a2, b2, options) => {
  if (!a2) {
    return b2;
  }
  const comp = compare$1(a2.semver, b2.semver, options);
  return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
};
var subset_1 = subset$1;
const internalRe = re$2.exports;
const constants$1 = constants$2;
const SemVer = semver$1;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq4 = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq: eq4,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$1.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.satisfiesVersionRange = exports2.gtRange = exports2.gtVersion = exports2.assertIsSemVerRange = exports2.assertIsSemVerVersion = exports2.isValidSemVerRange = exports2.isValidSemVerVersion = exports2.VersionRangeStruct = exports2.VersionStruct = void 0;
  const semver_1 = semver;
  const superstruct_12 = require$$1$2;
  const assert_12 = assert$2;
  exports2.VersionStruct = (0, superstruct_12.refine)((0, superstruct_12.string)(), "Version", (value) => {
    if ((0, semver_1.valid)(value) === null) {
      return `Expected SemVer version, got "${value}"`;
    }
    return true;
  });
  exports2.VersionRangeStruct = (0, superstruct_12.refine)((0, superstruct_12.string)(), "Version range", (value) => {
    if ((0, semver_1.validRange)(value) === null) {
      return `Expected SemVer range, got "${value}"`;
    }
    return true;
  });
  function isValidSemVerVersion(version2) {
    return (0, superstruct_12.is)(version2, exports2.VersionStruct);
  }
  exports2.isValidSemVerVersion = isValidSemVerVersion;
  function isValidSemVerRange(versionRange) {
    return (0, superstruct_12.is)(versionRange, exports2.VersionRangeStruct);
  }
  exports2.isValidSemVerRange = isValidSemVerRange;
  function assertIsSemVerVersion(version2) {
    (0, assert_12.assertStruct)(version2, exports2.VersionStruct);
  }
  exports2.assertIsSemVerVersion = assertIsSemVerVersion;
  function assertIsSemVerRange(range2) {
    (0, assert_12.assertStruct)(range2, exports2.VersionRangeStruct);
  }
  exports2.assertIsSemVerRange = assertIsSemVerRange;
  function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
  }
  exports2.gtVersion = gtVersion;
  function gtRange(version2, range2) {
    return (0, semver_1.gtr)(version2, range2);
  }
  exports2.gtRange = gtRange;
  function satisfiesVersionRange(version2, versionRange) {
    return (0, semver_1.satisfies)(version2, versionRange, {
      includePrerelease: true
    });
  }
  exports2.satisfiesVersionRange = satisfiesVersionRange;
})(versions);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function() {
          return m2[k2];
        }
      };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  __exportStar2(assert$2, exports2);
  __exportStar2(base64$1, exports2);
  __exportStar2(bytes, exports2);
  __exportStar2(checksum, exports2);
  __exportStar2(coercers, exports2);
  __exportStar2(collections, exports2);
  __exportStar2(hex, exports2);
  __exportStar2(json, exports2);
  __exportStar2(logging, exports2);
  __exportStar2(misc, exports2);
  __exportStar2(number, exports2);
  __exportStar2(opaque, exports2);
  __exportStar2(time, exports2);
  __exportStar2(versions, exports2);
})(dist$2);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.createModuleLogger = exports2.projectLogger = void 0;
  const utils_12 = dist$2;
  Object.defineProperty(exports2, "createModuleLogger", {
    enumerable: true,
    get: function() {
      return utils_12.createModuleLogger;
    }
  });
  exports2.projectLogger = (0, utils_12.createProjectLogger)("eth-block-tracker");
})(loggingUtils);
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(PollingBlockTracker$1, "__esModule", {
  value: true
});
PollingBlockTracker$1.PollingBlockTracker = void 0;
const json_rpc_random_id_1$1 = __importDefault$a(jsonRpcRandomId);
const pify_1 = __importDefault$a(pify$2);
const BaseBlockTracker_1$1 = BaseBlockTracker$1;
const logging_utils_1 = loggingUtils;
const log3 = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, "polling-block-tracker");
const createRandomId$2 = (0, json_rpc_random_id_1$1.default)();
const sec = 1e3;
class PollingBlockTracker extends BaseBlockTracker_1$1.BaseBlockTracker {
  constructor(opts = {}) {
    var _a2;
    if (!opts.provider) {
      throw new Error("PollingBlockTracker - no provider specified.");
    }
    super({
      blockResetDuration: (_a2 = opts.blockResetDuration) !== null && _a2 !== void 0 ? _a2 : opts.pollingInterval
    });
    this._provider = opts.provider;
    this._pollingInterval = opts.pollingInterval || 20 * sec;
    this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
    this._keepEventLoopActive = opts.keepEventLoopActive === void 0 ? true : opts.keepEventLoopActive;
    this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
  }
  async checkForLatestBlock() {
    await this._updateLatestBlock();
    return await this.getLatestBlock();
  }
  async _start() {
    this._synchronize();
  }
  async _end() {
  }
  async _synchronize() {
    var _a2;
    while (this._isRunning) {
      try {
        await this._updateLatestBlock();
        const promise = timeout$1(this._pollingInterval, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration");
        await promise;
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err}`);
        try {
          this.emit("error", newErr);
        } catch (emitErr) {
          console.error(newErr);
        }
        const promise = timeout$1(this._retryTimeout, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration");
        await promise;
      }
    }
  }
  async _updateLatestBlock() {
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }
  async _fetchLatestBlock() {
    const req = {
      jsonrpc: "2.0",
      id: createRandomId$2(),
      method: "eth_blockNumber",
      params: []
    };
    if (this._setSkipCacheFlag) {
      req.skipCache = true;
    }
    log3("Making request", req);
    const res = await (0, pify_1.default)((cb) => this._provider.sendAsync(req, cb))();
    log3("Got response", res);
    if (res.error) {
      throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error.message}`);
    }
    return res.result;
  }
}
PollingBlockTracker$1.PollingBlockTracker = PollingBlockTracker;
function timeout$1(duration, unref) {
  return new Promise((resolve) => {
    const timeoutRef = setTimeout(resolve, duration);
    if (timeoutRef.unref && unref) {
      timeoutRef.unref();
    }
  });
}
var SubscribeBlockTracker$1 = {};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(SubscribeBlockTracker$1, "__esModule", {
  value: true
});
SubscribeBlockTracker$1.SubscribeBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault$9(jsonRpcRandomId);
const BaseBlockTracker_1 = BaseBlockTracker$1;
const createRandomId$1 = (0, json_rpc_random_id_1.default)();
class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
  constructor(opts = {}) {
    if (!opts.provider) {
      throw new Error("SubscribeBlockTracker - no provider specified.");
    }
    super(opts);
    this._provider = opts.provider;
    this._subscriptionId = null;
  }
  async checkForLatestBlock() {
    return await this.getLatestBlock();
  }
  async _start() {
    if (this._subscriptionId === void 0 || this._subscriptionId === null) {
      try {
        const blockNumber = await this._call("eth_blockNumber");
        this._subscriptionId = await this._call("eth_subscribe", "newHeads");
        this._provider.on("data", this._handleSubData.bind(this));
        this._newPotentialLatest(blockNumber);
      } catch (e2) {
        this.emit("error", e2);
      }
    }
  }
  async _end() {
    if (this._subscriptionId !== null && this._subscriptionId !== void 0) {
      try {
        await this._call("eth_unsubscribe", this._subscriptionId);
        this._subscriptionId = null;
      } catch (e2) {
        this.emit("error", e2);
      }
    }
  }
  _call(method, ...params) {
    return new Promise((resolve, reject) => {
      this._provider.sendAsync({
        id: createRandomId$1(),
        method,
        params,
        jsonrpc: "2.0"
      }, (err, res) => {
        if (err) {
          reject(err);
        } else {
          resolve(res.result);
        }
      });
    });
  }
  _handleSubData(_2, response) {
    var _a2;
    if (response.method === "eth_subscription" && ((_a2 = response.params) === null || _a2 === void 0 ? void 0 : _a2.subscription) === this._subscriptionId) {
      this._newPotentialLatest(response.params.result.number);
    }
  }
}
SubscribeBlockTracker$1.SubscribeBlockTracker = SubscribeBlockTracker;
var types$1 = {};
Object.defineProperty(types$1, "__esModule", {
  value: true
});
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, {
      enumerable: true,
      get: function() {
        return m2[k2];
      }
    });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  __exportStar2(PollingBlockTracker$1, exports2);
  __exportStar2(SubscribeBlockTracker$1, exports2);
  __exportStar2(types$1, exports2);
})(dist$3);
var dist = {};
var idRemapMiddleware = {};
var getUniqueId$1 = {};
Object.defineProperty(getUniqueId$1, "__esModule", {
  value: true
});
getUniqueId$1.getUniqueId = void 0;
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
  idCounter = (idCounter + 1) % MAX;
  return idCounter;
}
getUniqueId$1.getUniqueId = getUniqueId;
Object.defineProperty(idRemapMiddleware, "__esModule", {
  value: true
});
idRemapMiddleware.createIdRemapMiddleware = void 0;
const getUniqueId_1 = getUniqueId$1;
function createIdRemapMiddleware() {
  return (req, res, next, _end) => {
    const originalId = req.id;
    const newId = getUniqueId_1.getUniqueId();
    req.id = newId;
    res.id = newId;
    next((done2) => {
      req.id = originalId;
      res.id = originalId;
      done2();
    });
  };
}
idRemapMiddleware.createIdRemapMiddleware = createIdRemapMiddleware;
var createAsyncMiddleware$3 = {};
Object.defineProperty(createAsyncMiddleware$3, "__esModule", {
  value: true
});
createAsyncMiddleware$3.createAsyncMiddleware = void 0;
function createAsyncMiddleware$2(asyncMiddleware) {
  return async (req, res, next, end) => {
    let resolveNextPromise;
    const nextPromise = new Promise((resolve) => {
      resolveNextPromise = resolve;
    });
    let returnHandlerCallback = null;
    let nextWasCalled = false;
    const asyncNext = async () => {
      nextWasCalled = true;
      next((runReturnHandlersCallback) => {
        returnHandlerCallback = runReturnHandlersCallback;
        resolveNextPromise();
      });
      await nextPromise;
    };
    try {
      await asyncMiddleware(req, res, asyncNext);
      if (nextWasCalled) {
        await nextPromise;
        returnHandlerCallback(null);
      } else {
        end(null);
      }
    } catch (error) {
      if (returnHandlerCallback) {
        returnHandlerCallback(error);
      } else {
        end(error);
      }
    }
  };
}
createAsyncMiddleware$3.createAsyncMiddleware = createAsyncMiddleware$2;
var createScaffoldMiddleware$3 = {};
Object.defineProperty(createScaffoldMiddleware$3, "__esModule", {
  value: true
});
createScaffoldMiddleware$3.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware$2(handlers) {
  return (req, res, next, end) => {
    const handler = handlers[req.method];
    if (handler === void 0) {
      return next();
    }
    if (typeof handler === "function") {
      return handler(req, res, next, end);
    }
    res.result = handler;
    return end();
  };
}
createScaffoldMiddleware$3.createScaffoldMiddleware = createScaffoldMiddleware$2;
var JsonRpcEngine$1 = {};
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(JsonRpcEngine$1, "__esModule", {
  value: true
});
JsonRpcEngine$1.JsonRpcEngine = void 0;
const safe_event_emitter_1$1 = __importDefault$8(safeEventEmitter);
const eth_rpc_errors_1 = dist$4;
class JsonRpcEngine extends safe_event_emitter_1$1.default {
  constructor() {
    super();
    this._middleware = [];
  }
  push(middleware) {
    this._middleware.push(middleware);
  }
  handle(req, cb) {
    if (cb && typeof cb !== "function") {
      throw new Error('"callback" must be a function if provided.');
    }
    if (Array.isArray(req)) {
      if (cb) {
        return this._handleBatch(req, cb);
      }
      return this._handleBatch(req);
    }
    if (cb) {
      return this._handle(req, cb);
    }
    return this._promiseHandle(req);
  }
  asMiddleware() {
    return async (req, res, next, end) => {
      try {
        const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        if (isComplete) {
          await JsonRpcEngine._runReturnHandlers(returnHandlers);
          return end(middlewareError);
        }
        return next(async (handlerCallback) => {
          try {
            await JsonRpcEngine._runReturnHandlers(returnHandlers);
          } catch (error) {
            return handlerCallback(error);
          }
          return handlerCallback();
        });
      } catch (error) {
        return end(error);
      }
    };
  }
  async _handleBatch(reqs, cb) {
    try {
      const responses = await Promise.all(
        reqs.map(this._promiseHandle.bind(this))
      );
      if (cb) {
        return cb(null, responses);
      }
      return responses;
    } catch (error) {
      if (cb) {
        return cb(error);
      }
      throw error;
    }
  }
  _promiseHandle(req) {
    return new Promise((resolve) => {
      this._handle(req, (_err, res) => {
        resolve(res);
      });
    });
  }
  async _handle(callerReq, cb) {
    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
      const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, {
        request: callerReq
      });
      return cb(error2, {
        id: void 0,
        jsonrpc: "2.0",
        error: error2
      });
    }
    if (typeof callerReq.method !== "string") {
      const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, {
        request: callerReq
      });
      return cb(error2, {
        id: callerReq.id,
        jsonrpc: "2.0",
        error: error2
      });
    }
    const req = Object.assign({}, callerReq);
    const res = {
      id: req.id,
      jsonrpc: req.jsonrpc
    };
    let error = null;
    try {
      await this._processRequest(req, res);
    } catch (_error) {
      error = _error;
    }
    if (error) {
      delete res.result;
      if (!res.error) {
        res.error = eth_rpc_errors_1.serializeError(error);
      }
    }
    return cb(error, res);
  }
  async _processRequest(req, res) {
    const [error, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
    JsonRpcEngine._checkForCompletion(req, res, isComplete);
    await JsonRpcEngine._runReturnHandlers(returnHandlers);
    if (error) {
      throw error;
    }
  }
  static async _runAllMiddleware(req, res, middlewareStack) {
    const returnHandlers = [];
    let error = null;
    let isComplete = false;
    for (const middleware of middlewareStack) {
      [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
      if (isComplete) {
        break;
      }
    }
    return [error, isComplete, returnHandlers.reverse()];
  }
  static _runMiddleware(req, res, middleware, returnHandlers) {
    return new Promise((resolve) => {
      const end = (err) => {
        const error = err || res.error;
        if (error) {
          res.error = eth_rpc_errors_1.serializeError(error);
        }
        resolve([error, true]);
      };
      const next = (returnHandler) => {
        if (res.error) {
          end(res.error);
        } else {
          if (returnHandler) {
            if (typeof returnHandler !== "function") {
              end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, {
                request: req
              }));
            }
            returnHandlers.push(returnHandler);
          }
          resolve([null, false]);
        }
      };
      try {
        middleware(req, res, next, end);
      } catch (error) {
        end(error);
      }
    });
  }
  static async _runReturnHandlers(handlers) {
    for (const handler of handlers) {
      await new Promise((resolve, reject) => {
        handler((err) => err ? reject(err) : resolve());
      });
    }
  }
  static _checkForCompletion(req, res, isComplete) {
    if (!("result" in res) && !("error" in res)) {
      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, {
        request: req
      });
    }
    if (!isComplete) {
      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, {
        request: req
      });
    }
  }
}
JsonRpcEngine$1.JsonRpcEngine = JsonRpcEngine;
function jsonify(request) {
  return JSON.stringify(request, null, 2);
}
var mergeMiddleware$1 = {};
Object.defineProperty(mergeMiddleware$1, "__esModule", {
  value: true
});
mergeMiddleware$1.mergeMiddleware = void 0;
const JsonRpcEngine_1 = JsonRpcEngine$1;
function mergeMiddleware(middlewareStack) {
  const engine = new JsonRpcEngine_1.JsonRpcEngine();
  middlewareStack.forEach((middleware) => engine.push(middleware));
  return engine.asMiddleware();
}
mergeMiddleware$1.mergeMiddleware = mergeMiddleware;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, {
      enumerable: true,
      get: function() {
        return m2[k2];
      }
    });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  __exportStar2(idRemapMiddleware, exports2);
  __exportStar2(createAsyncMiddleware$3, exports2);
  __exportStar2(createScaffoldMiddleware$3, exports2);
  __exportStar2(getUniqueId$1, exports2);
  __exportStar2(JsonRpcEngine$1, exports2);
  __exportStar2(mergeMiddleware$1, exports2);
})(dist);
var lib = {};
var Mutex$2 = {};
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var Semaphore$1 = {};
Object.defineProperty(Semaphore$1, "__esModule", {
  value: true
});
var tslib_1$2 = require$$0$1;
var Semaphore = function() {
  function Semaphore2(_maxConcurrency) {
    this._maxConcurrency = _maxConcurrency;
    this._queue = [];
    if (_maxConcurrency <= 0) {
      throw new Error("semaphore must be initialized to a positive value");
    }
    this._value = _maxConcurrency;
  }
  Semaphore2.prototype.acquire = function() {
    var _this = this;
    var locked = this.isLocked();
    var ticket = new Promise(function(r2) {
      return _this._queue.push(r2);
    });
    if (!locked)
      this._dispatch();
    return ticket;
  };
  Semaphore2.prototype.runExclusive = function(callback) {
    return tslib_1$2.__awaiter(this, void 0, void 0, function() {
      var _a2, value, release;
      return tslib_1$2.__generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            return [4, this.acquire()];
          case 1:
            _a2 = _b2.sent(), value = _a2[0], release = _a2[1];
            _b2.label = 2;
          case 2:
            _b2.trys.push([2, , 4, 5]);
            return [4, callback(value)];
          case 3:
            return [2, _b2.sent()];
          case 4:
            release();
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Semaphore2.prototype.isLocked = function() {
    return this._value <= 0;
  };
  Semaphore2.prototype.release = function() {
    if (this._maxConcurrency > 1) {
      throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
    }
    if (this._currentReleaser) {
      var releaser = this._currentReleaser;
      this._currentReleaser = void 0;
      releaser();
    }
  };
  Semaphore2.prototype._dispatch = function() {
    var _this = this;
    var nextConsumer = this._queue.shift();
    if (!nextConsumer)
      return;
    var released = false;
    this._currentReleaser = function() {
      if (released)
        return;
      released = true;
      _this._value++;
      _this._dispatch();
    };
    nextConsumer([this._value--, this._currentReleaser]);
  };
  return Semaphore2;
}();
Semaphore$1.default = Semaphore;
Object.defineProperty(Mutex$2, "__esModule", {
  value: true
});
var tslib_1$1 = require$$0$1;
var Semaphore_1 = Semaphore$1;
var Mutex$1 = function() {
  function Mutex2() {
    this._semaphore = new Semaphore_1.default(1);
  }
  Mutex2.prototype.acquire = function() {
    return tslib_1$1.__awaiter(this, void 0, void 0, function() {
      var _a2, releaser;
      return tslib_1$1.__generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            return [4, this._semaphore.acquire()];
          case 1:
            _a2 = _b2.sent(), releaser = _a2[1];
            return [2, releaser];
        }
      });
    });
  };
  Mutex2.prototype.runExclusive = function(callback) {
    return this._semaphore.runExclusive(function() {
      return callback();
    });
  };
  Mutex2.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  };
  Mutex2.prototype.release = function() {
    this._semaphore.release();
  };
  return Mutex2;
}();
Mutex$2.default = Mutex$1;
var withTimeout$1 = {};
Object.defineProperty(withTimeout$1, "__esModule", {
  value: true
});
withTimeout$1.withTimeout = void 0;
var tslib_1 = require$$0$1;
function withTimeout(sync, timeout2, timeoutError) {
  var _this = this;
  if (timeoutError === void 0) {
    timeoutError = new Error("timeout");
  }
  return {
    acquire: function() {
      return new Promise(function(resolve, reject) {
        return tslib_1.__awaiter(_this, void 0, void 0, function() {
          var isTimeout, ticket, release;
          return tslib_1.__generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isTimeout = false;
                setTimeout(function() {
                  isTimeout = true;
                  reject(timeoutError);
                }, timeout2);
                return [4, sync.acquire()];
              case 1:
                ticket = _a2.sent();
                if (isTimeout) {
                  release = Array.isArray(ticket) ? ticket[1] : ticket;
                  release();
                } else {
                  resolve(ticket);
                }
                return [2];
            }
          });
        });
      });
    },
    runExclusive: function(callback) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var release, ticket;
        return tslib_1.__generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              release = function() {
                return void 0;
              };
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, , 7, 8]);
              return [4, this.acquire()];
            case 2:
              ticket = _a2.sent();
              if (!Array.isArray(ticket))
                return [3, 4];
              release = ticket[1];
              return [4, callback(ticket[0])];
            case 3:
              return [2, _a2.sent()];
            case 4:
              release = ticket;
              return [4, callback()];
            case 5:
              return [2, _a2.sent()];
            case 6:
              return [3, 8];
            case 7:
              release();
              return [7];
            case 8:
              return [2];
          }
        });
      });
    },
    release: function() {
      sync.release();
    },
    isLocked: function() {
      return sync.isLocked();
    }
  };
}
withTimeout$1.withTimeout = withTimeout;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.withTimeout = exports2.Semaphore = exports2.Mutex = void 0;
  var Mutex_1 = Mutex$2;
  Object.defineProperty(exports2, "Mutex", {
    enumerable: true,
    get: function() {
      return Mutex_1.default;
    }
  });
  var Semaphore_12 = Semaphore$1;
  Object.defineProperty(exports2, "Semaphore", {
    enumerable: true,
    get: function() {
      return Semaphore_12.default;
    }
  });
  var withTimeout_1 = withTimeout$1;
  Object.defineProperty(exports2, "withTimeout", {
    enumerable: true,
    get: function() {
      return withTimeout_1.withTimeout;
    }
  });
})(lib);
var immutable = extend$1;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend$1() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key2 in source) {
      if (hasOwnProperty.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
const extend = immutable;
const createRandomId = jsonRpcRandomId();
var ethQuery = EthQuery$1;
function EthQuery$1(provider) {
  const self2 = this;
  self2.currentProvider = provider;
}
EthQuery$1.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
EthQuery$1.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
EthQuery$1.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
EthQuery$1.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
EthQuery$1.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
EthQuery$1.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
EthQuery$1.prototype.syncing = generateFnFor("eth_syncing");
EthQuery$1.prototype.coinbase = generateFnFor("eth_coinbase");
EthQuery$1.prototype.mining = generateFnFor("eth_mining");
EthQuery$1.prototype.hashrate = generateFnFor("eth_hashrate");
EthQuery$1.prototype.gasPrice = generateFnFor("eth_gasPrice");
EthQuery$1.prototype.accounts = generateFnFor("eth_accounts");
EthQuery$1.prototype.blockNumber = generateFnFor("eth_blockNumber");
EthQuery$1.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
EthQuery$1.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
EthQuery$1.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
EthQuery$1.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
EthQuery$1.prototype.sign = generateFnFor("eth_sign");
EthQuery$1.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
EthQuery$1.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
EthQuery$1.prototype.estimateGas = generateFnFor("eth_estimateGas");
EthQuery$1.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
EthQuery$1.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
EthQuery$1.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
EthQuery$1.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
EthQuery$1.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
EthQuery$1.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
EthQuery$1.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
EthQuery$1.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
EthQuery$1.prototype.getCompilers = generateFnFor("eth_getCompilers");
EthQuery$1.prototype.compileLLL = generateFnFor("eth_compileLLL");
EthQuery$1.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
EthQuery$1.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
EthQuery$1.prototype.newFilter = generateFnFor("eth_newFilter");
EthQuery$1.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
EthQuery$1.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
EthQuery$1.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
EthQuery$1.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
EthQuery$1.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
EthQuery$1.prototype.getLogs = generateFnFor("eth_getLogs");
EthQuery$1.prototype.getWork = generateFnFor("eth_getWork");
EthQuery$1.prototype.submitWork = generateFnFor("eth_submitWork");
EthQuery$1.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
EthQuery$1.prototype.sendAsync = function(opts, cb) {
  const self2 = this;
  self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
    if (!err && response.error)
      err = new Error("EthQuery - RPC Error - " + response.error.message);
    if (err)
      return cb(err);
    cb(null, response.result);
  });
};
function generateFnFor(methodName) {
  return function() {
    const self2 = this;
    var args = [].slice.call(arguments);
    var cb = args.pop();
    self2.sendAsync({
      method: methodName,
      params: args
    }, cb);
  };
}
function generateFnWithDefaultBlockFor(argCount, methodName) {
  return function() {
    const self2 = this;
    var args = [].slice.call(arguments);
    var cb = args.pop();
    if (args.length < argCount)
      args.push("latest");
    self2.sendAsync({
      method: methodName,
      params: args
    }, cb);
  };
}
function createPayload(data) {
  return extend({
    id: createRandomId(),
    jsonrpc: "2.0",
    params: []
  }, data);
}
const processFn = (fn2, options, proxy, unwrapped) => function(...arguments_) {
  const P2 = options.promiseModule;
  return new P2((resolve, reject) => {
    if (options.multiArgs) {
      arguments_.push((...result) => {
        if (options.errorFirst) {
          if (result[0]) {
            reject(result);
          } else {
            result.shift();
            resolve(result);
          }
        } else {
          resolve(result);
        }
      });
    } else if (options.errorFirst) {
      arguments_.push((error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    } else {
      arguments_.push(resolve);
    }
    const self2 = this === proxy ? unwrapped : this;
    Reflect.apply(fn2, self2, arguments_);
  });
};
const filterCache = /* @__PURE__ */ new WeakMap();
var pify$1 = (input, options) => {
  options = {
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise,
    ...options
  };
  const objectType = typeof input;
  if (!(input !== null && (objectType === "object" || objectType === "function"))) {
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
  }
  const filter2 = (target, key2) => {
    let cached = filterCache.get(target);
    if (!cached) {
      cached = {};
      filterCache.set(target, cached);
    }
    if (key2 in cached) {
      return cached[key2];
    }
    const match = (pattern2) => typeof pattern2 === "string" || typeof key2 === "symbol" ? key2 === pattern2 : pattern2.test(key2);
    const desc = Reflect.getOwnPropertyDescriptor(target, key2);
    const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
    const included = options.include ? options.include.some(match) : !options.exclude.some(match);
    const shouldFilter = included && writableOrConfigurableOwn;
    cached[key2] = shouldFilter;
    return shouldFilter;
  };
  const cache = /* @__PURE__ */ new WeakMap();
  const proxy = new Proxy(input, {
    apply(target, thisArg, args) {
      const cached = cache.get(target);
      if (cached) {
        return Reflect.apply(cached, thisArg, args);
      }
      const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
      cache.set(target, pified);
      return Reflect.apply(pified, thisArg, args);
    },
    get(target, key2) {
      const property = target[key2];
      if (!filter2(target, key2) || property === Function.prototype[key2]) {
        return property;
      }
      const cached = cache.get(property);
      if (cached) {
        return cached;
      }
      if (typeof property === "function") {
        const pified = processFn(property, options, proxy, target);
        cache.set(property, pified);
        return pified;
      }
      return property;
    }
  });
  return proxy;
};
const SafeEventEmitter$1 = safeEventEmitter.default;
class BaseFilter$3 extends SafeEventEmitter$1 {
  constructor() {
    super();
    this.updates = [];
  }
  async initialize() {
  }
  async update() {
    throw new Error("BaseFilter - no update method specified");
  }
  addResults(newResults) {
    this.updates = this.updates.concat(newResults);
    newResults.forEach((result) => this.emit("update", result));
  }
  addInitialResults(newResults) {
  }
  getChangesAndClear() {
    const updates = this.updates;
    this.updates = [];
    return updates;
  }
}
var baseFilter = BaseFilter$3;
const BaseFilter$2 = baseFilter;
class BaseFilterWithHistory$1 extends BaseFilter$2 {
  constructor() {
    super();
    this.allResults = [];
  }
  async update() {
    throw new Error("BaseFilterWithHistory - no update method specified");
  }
  addResults(newResults) {
    this.allResults = this.allResults.concat(newResults);
    super.addResults(newResults);
  }
  addInitialResults(newResults) {
    this.allResults = this.allResults.concat(newResults);
    super.addInitialResults(newResults);
  }
  getAllResults() {
    return this.allResults;
  }
}
var baseFilterHistory = BaseFilterWithHistory$1;
var hexUtils = {
  minBlockRef: minBlockRef$1,
  maxBlockRef,
  sortBlockRefs,
  bnToHex: bnToHex$1,
  blockRefIsNumber: blockRefIsNumber$1,
  hexToInt: hexToInt$3,
  incrementHexInt: incrementHexInt$4,
  intToHex: intToHex$2,
  unsafeRandomBytes: unsafeRandomBytes$1
};
function minBlockRef$1(...refs) {
  const sortedRefs = sortBlockRefs(refs);
  return sortedRefs[0];
}
function maxBlockRef(...refs) {
  const sortedRefs = sortBlockRefs(refs);
  return sortedRefs[sortedRefs.length - 1];
}
function sortBlockRefs(refs) {
  return refs.sort((refA, refB) => {
    if (refA === "latest" || refB === "earliest")
      return 1;
    if (refB === "latest" || refA === "earliest")
      return -1;
    return hexToInt$3(refA) - hexToInt$3(refB);
  });
}
function bnToHex$1(bn2) {
  return "0x" + bn2.toString(16);
}
function blockRefIsNumber$1(blockRef) {
  return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
}
function hexToInt$3(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  return Number.parseInt(hexString, 16);
}
function incrementHexInt$4(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  const value = hexToInt$3(hexString);
  return intToHex$2(value + 1);
}
function intToHex$2(int) {
  if (int === void 0 || int === null)
    return int;
  let hexString = int.toString(16);
  const needsLeftPad = hexString.length % 2;
  if (needsLeftPad)
    hexString = "0" + hexString;
  return "0x" + hexString;
}
function unsafeRandomBytes$1(byteCount) {
  let result = "0x";
  for (let i = 0; i < byteCount; i++) {
    result += unsafeRandomNibble();
    result += unsafeRandomNibble();
  }
  return result;
}
function unsafeRandomNibble() {
  return Math.floor(Math.random() * 16).toString(16);
}
const EthQuery = ethQuery;
const pify = pify$1;
const BaseFilterWithHistory = baseFilterHistory;
const {
  bnToHex,
  hexToInt: hexToInt$2,
  incrementHexInt: incrementHexInt$3,
  minBlockRef,
  blockRefIsNumber
} = hexUtils;
class LogFilter$1 extends BaseFilterWithHistory {
  constructor({
    provider,
    params
  }) {
    super();
    this.type = "log";
    this.ethQuery = new EthQuery(provider);
    this.params = Object.assign({
      fromBlock: "latest",
      toBlock: "latest",
      address: void 0,
      topics: []
    }, params);
    if (this.params.address) {
      if (!Array.isArray(this.params.address)) {
        this.params.address = [this.params.address];
      }
      this.params.address = this.params.address.map((address) => address.toLowerCase());
    }
  }
  async initialize({
    currentBlock
  }) {
    let fromBlock = this.params.fromBlock;
    if (["latest", "pending"].includes(fromBlock))
      fromBlock = currentBlock;
    if ("earliest" === fromBlock)
      fromBlock = "0x0";
    this.params.fromBlock = fromBlock;
    const toBlock = minBlockRef(this.params.toBlock, currentBlock);
    const params = Object.assign({}, this.params, {
      toBlock
    });
    const newLogs = await this._fetchLogs(params);
    this.addInitialResults(newLogs);
  }
  async update({
    oldBlock,
    newBlock
  }) {
    const toBlock = newBlock;
    let fromBlock;
    if (oldBlock) {
      fromBlock = incrementHexInt$3(oldBlock);
    } else {
      fromBlock = newBlock;
    }
    const params = Object.assign({}, this.params, {
      fromBlock,
      toBlock
    });
    const newLogs = await this._fetchLogs(params);
    const matchingLogs = newLogs.filter((log4) => this.matchLog(log4));
    this.addResults(matchingLogs);
  }
  async _fetchLogs(params) {
    const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
    return newLogs;
  }
  matchLog(log4) {
    if (hexToInt$2(this.params.fromBlock) >= hexToInt$2(log4.blockNumber))
      return false;
    if (blockRefIsNumber(this.params.toBlock) && hexToInt$2(this.params.toBlock) <= hexToInt$2(log4.blockNumber))
      return false;
    const normalizedLogAddress = log4.address && log4.address.toLowerCase();
    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
      return false;
    const topicsMatch = this.params.topics.every((topicPattern, index2) => {
      let logTopic = log4.topics[index2];
      if (!logTopic)
        return false;
      logTopic = logTopic.toLowerCase();
      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
      if (subtopicsIncludeWildcard)
        return true;
      subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
      const topicDoesMatch = subtopicsToMatch.includes(logTopic);
      return topicDoesMatch;
    });
    return topicsMatch;
  }
}
var logFilter = LogFilter$1;
var getBlocksForRange_1 = getBlocksForRange$3;
async function getBlocksForRange$3({
  provider,
  fromBlock,
  toBlock
}) {
  if (!fromBlock)
    fromBlock = toBlock;
  const fromBlockNumber = hexToInt$1(fromBlock);
  const toBlockNumber = hexToInt$1(toBlock);
  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
  const missingBlockNumbers = Array(blockCountToQuery).fill().map((_2, index2) => fromBlockNumber + index2).map(intToHex$1);
  const blockBodies = await Promise.all(missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false])));
  return blockBodies;
}
function hexToInt$1(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  return Number.parseInt(hexString, 16);
}
function intToHex$1(int) {
  if (int === void 0 || int === null)
    return int;
  const hexString = int.toString(16);
  return "0x" + hexString;
}
function sendAsync(provider, request) {
  return new Promise((resolve, reject) => {
    provider.sendAsync(request, (error, response) => {
      if (error) {
        reject(error);
      } else if (response.error) {
        reject(response.error);
      } else if (response.result) {
        resolve(response.result);
      } else {
        reject(new Error("Result was empty"));
      }
    });
  });
}
async function query(provider, method, params) {
  for (let i = 0; i < 3; i++) {
    try {
      return await sendAsync(provider, {
        id: 1,
        jsonrpc: "2.0",
        method,
        params
      });
    } catch (error) {
      console.error(`provider.sendAsync failed: ${error.stack || error.message || error}`);
    }
  }
  throw new Error(`Block not found for params: ${JSON.stringify(params)}`);
}
const BaseFilter$1 = baseFilter;
const getBlocksForRange$2 = getBlocksForRange_1;
const {
  incrementHexInt: incrementHexInt$2
} = hexUtils;
class BlockFilter$1 extends BaseFilter$1 {
  constructor({
    provider,
    params
  }) {
    super();
    this.type = "block";
    this.provider = provider;
  }
  async update({
    oldBlock,
    newBlock
  }) {
    const toBlock = newBlock;
    const fromBlock = incrementHexInt$2(oldBlock);
    const blockBodies = await getBlocksForRange$2({
      provider: this.provider,
      fromBlock,
      toBlock
    });
    const blockHashes = blockBodies.map((block) => block.hash);
    this.addResults(blockHashes);
  }
}
var blockFilter = BlockFilter$1;
const BaseFilter = baseFilter;
const getBlocksForRange$1 = getBlocksForRange_1;
const {
  incrementHexInt: incrementHexInt$1
} = hexUtils;
class TxFilter$1 extends BaseFilter {
  constructor({
    provider
  }) {
    super();
    this.type = "tx";
    this.provider = provider;
  }
  async update({
    oldBlock
  }) {
    const toBlock = oldBlock;
    const fromBlock = incrementHexInt$1(oldBlock);
    const blocks = await getBlocksForRange$1({
      provider: this.provider,
      fromBlock,
      toBlock
    });
    const blockTxHashes = [];
    for (const block of blocks) {
      blockTxHashes.push(...block.transactions);
    }
    this.addResults(blockTxHashes);
  }
}
var txFilter = TxFilter$1;
const Mutex = lib.Mutex;
const {
  createAsyncMiddleware: createAsyncMiddleware$1,
  createScaffoldMiddleware: createScaffoldMiddleware$1
} = dist;
const LogFilter = logFilter;
const BlockFilter = blockFilter;
const TxFilter = txFilter;
const {
  intToHex,
  hexToInt
} = hexUtils;
var ethJsonRpcFilters = createEthFilterMiddleware;
function createEthFilterMiddleware({
  blockTracker,
  provider
}) {
  let filterIndex = 0;
  let filters = {};
  const mutex = new Mutex();
  const waitForFree = mutexMiddlewareWrapper({
    mutex
  });
  const middleware = createScaffoldMiddleware$1({
    eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
    eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
    eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
    eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
    eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
    eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
  });
  const filterUpdater = async ({
    oldBlock,
    newBlock
  }) => {
    if (filters.length === 0)
      return;
    const releaseLock = await mutex.acquire();
    try {
      await Promise.all(objValues(filters).map(async (filter2) => {
        try {
          await filter2.update({
            oldBlock,
            newBlock
          });
        } catch (err) {
          console.error(err);
        }
      }));
    } catch (err) {
      console.error(err);
    }
    releaseLock();
  };
  middleware.newLogFilter = newLogFilter;
  middleware.newBlockFilter = newBlockFilter;
  middleware.newPendingTransactionFilter = newPendingTransactionFilter;
  middleware.uninstallFilter = uninstallFilterHandler;
  middleware.getFilterChanges = getFilterChanges;
  middleware.getFilterLogs = getFilterLogs;
  middleware.destroy = () => {
    uninstallAllFilters();
  };
  return middleware;
  async function newLogFilter(params) {
    const filter2 = new LogFilter({
      provider,
      params
    });
    await installFilter(filter2);
    return filter2;
  }
  async function newBlockFilter() {
    const filter2 = new BlockFilter({
      provider
    });
    await installFilter(filter2);
    return filter2;
  }
  async function newPendingTransactionFilter() {
    const filter2 = new TxFilter({
      provider
    });
    await installFilter(filter2);
    return filter2;
  }
  async function getFilterChanges(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters[filterIndex2];
    if (!filter2) {
      throw new Error(`No filter for index "${filterIndex2}"`);
    }
    const results = filter2.getChangesAndClear();
    return results;
  }
  async function getFilterLogs(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters[filterIndex2];
    if (!filter2) {
      throw new Error(`No filter for index "${filterIndex2}"`);
    }
    let results = [];
    if (filter2.type === "log") {
      results = filter2.getAllResults();
    }
    return results;
  }
  async function uninstallFilterHandler(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters[filterIndex2];
    const result = Boolean(filter2);
    if (result) {
      await uninstallFilter(filterIndex2);
    }
    return result;
  }
  async function installFilter(filter2) {
    const prevFilterCount = objValues(filters).length;
    const currentBlock = await blockTracker.getLatestBlock();
    await filter2.initialize({
      currentBlock
    });
    filterIndex++;
    filters[filterIndex] = filter2;
    filter2.id = filterIndex;
    filter2.idHex = intToHex(filterIndex);
    const newFilterCount = objValues(filters).length;
    updateBlockTrackerSubs({
      prevFilterCount,
      newFilterCount
    });
    return filterIndex;
  }
  async function uninstallFilter(filterIndex2) {
    const prevFilterCount = objValues(filters).length;
    delete filters[filterIndex2];
    const newFilterCount = objValues(filters).length;
    updateBlockTrackerSubs({
      prevFilterCount,
      newFilterCount
    });
  }
  async function uninstallAllFilters() {
    const prevFilterCount = objValues(filters).length;
    filters = {};
    updateBlockTrackerSubs({
      prevFilterCount,
      newFilterCount: 0
    });
  }
  function updateBlockTrackerSubs({
    prevFilterCount,
    newFilterCount
  }) {
    if (prevFilterCount === 0 && newFilterCount > 0) {
      blockTracker.on("sync", filterUpdater);
      return;
    }
    if (prevFilterCount > 0 && newFilterCount === 0) {
      blockTracker.removeListener("sync", filterUpdater);
      return;
    }
  }
}
function toFilterCreationMiddleware(createFilterFn) {
  return toAsyncRpcMiddleware(async (...args) => {
    const filter2 = await createFilterFn(...args);
    const result = intToHex(filter2.id);
    return result;
  });
}
function toAsyncRpcMiddleware(asyncFn) {
  return createAsyncMiddleware$1(async (req, res) => {
    const result = await asyncFn.apply(null, req.params);
    res.result = result;
  });
}
function mutexMiddlewareWrapper({
  mutex
}) {
  return (middleware) => {
    return async (req, res, next, end) => {
      const releaseLock = await mutex.acquire();
      releaseLock();
      middleware(req, res, next, end);
    };
  };
}
function objValues(obj, fn2) {
  const values = [];
  for (let key2 in obj) {
    values.push(obj[key2]);
  }
  return values;
}
const SafeEventEmitter = safeEventEmitter.default;
const {
  createAsyncMiddleware,
  createScaffoldMiddleware
} = dist;
const createFilterMiddleware = ethJsonRpcFilters;
const {
  unsafeRandomBytes,
  incrementHexInt
} = hexUtils;
const getBlocksForRange = getBlocksForRange_1;
var subscriptionManager = createSubscriptionMiddleware;
function createSubscriptionMiddleware({
  blockTracker,
  provider
}) {
  const subscriptions = {};
  const filterManager = createFilterMiddleware({
    blockTracker,
    provider
  });
  let isDestroyed = false;
  const events2 = new SafeEventEmitter();
  const middleware = createScaffoldMiddleware({
    eth_subscribe: createAsyncMiddleware(subscribe),
    eth_unsubscribe: createAsyncMiddleware(unsubscribe)
  });
  middleware.destroy = destroy2;
  return {
    events: events2,
    middleware
  };
  async function subscribe(req, res) {
    if (isDestroyed)
      throw new Error("SubscriptionManager - attempting to use after destroying");
    const subscriptionType = req.params[0];
    const subId = unsafeRandomBytes(16);
    let sub;
    switch (subscriptionType) {
      case "newHeads":
        sub = createSubNewHeads({
          subId
        });
        break;
      case "logs":
        const filterParams = req.params[1];
        const filter2 = await filterManager.newLogFilter(filterParams);
        sub = createSubFromFilter({
          subId,
          filter: filter2
        });
        break;
      default:
        throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
    }
    subscriptions[subId] = sub;
    res.result = subId;
    return;
    function createSubNewHeads({
      subId: subId2
    }) {
      const sub2 = {
        type: subscriptionType,
        destroy: async () => {
          blockTracker.removeListener("sync", sub2.update);
        },
        update: async ({
          oldBlock,
          newBlock
        }) => {
          const toBlock = newBlock;
          const fromBlock = incrementHexInt(oldBlock);
          const rawBlocks = await getBlocksForRange({
            provider,
            fromBlock,
            toBlock
          });
          const results = rawBlocks.map(normalizeBlock).filter((block) => block !== null);
          results.forEach((value) => {
            _emitSubscriptionResult(subId2, value);
          });
        }
      };
      blockTracker.on("sync", sub2.update);
      return sub2;
    }
    function createSubFromFilter({
      subId: subId2,
      filter: filter2
    }) {
      filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
      const sub2 = {
        type: subscriptionType,
        destroy: async () => {
          return await filterManager.uninstallFilter(filter2.idHex);
        }
      };
      return sub2;
    }
  }
  async function unsubscribe(req, res) {
    if (isDestroyed)
      throw new Error("SubscriptionManager - attempting to use after destroying");
    const id2 = req.params[0];
    const subscription = subscriptions[id2];
    if (!subscription) {
      res.result = false;
      return;
    }
    delete subscriptions[id2];
    await subscription.destroy();
    res.result = true;
  }
  function _emitSubscriptionResult(filterIdHex, value) {
    events2.emit("notification", {
      jsonrpc: "2.0",
      method: "eth_subscription",
      params: {
        subscription: filterIdHex,
        result: value
      }
    });
  }
  function destroy2() {
    events2.removeAllListeners();
    for (const id2 in subscriptions) {
      subscriptions[id2].destroy();
      delete subscriptions[id2];
    }
    isDestroyed = true;
  }
}
function normalizeBlock(block) {
  if (block === null || block === void 0) {
    return null;
  }
  return {
    hash: block.hash,
    parentHash: block.parentHash,
    sha3Uncles: block.sha3Uncles,
    miner: block.miner,
    stateRoot: block.stateRoot,
    transactionsRoot: block.transactionsRoot,
    receiptsRoot: block.receiptsRoot,
    logsBloom: block.logsBloom,
    difficulty: block.difficulty,
    number: block.number,
    gasLimit: block.gasLimit,
    gasUsed: block.gasUsed,
    nonce: block.nonce,
    mixHash: block.mixHash,
    timestamp: block.timestamp,
    extraData: block.extraData
  };
}
Object.defineProperty(SubscriptionManager$1, "__esModule", {
  value: true
});
SubscriptionManager$1.SubscriptionManager = void 0;
const eth_block_tracker_1 = dist$3;
const createSubscriptionManager = subscriptionManager;
const noop$1 = () => {
};
class SubscriptionManager {
  constructor(provider) {
    const blockTracker = new eth_block_tracker_1.PollingBlockTracker({
      provider,
      pollingInterval: 15 * 1e3,
      setSkipCacheFlag: true
    });
    const {
      events: events2,
      middleware
    } = createSubscriptionManager({
      blockTracker,
      provider
    });
    this.events = events2;
    this.subscriptionMiddleware = middleware;
  }
  async handleRequest(request) {
    const result = {};
    await this.subscriptionMiddleware(request, result, noop$1, noop$1);
    return result;
  }
  destroy() {
    this.subscriptionMiddleware.destroy();
  }
}
SubscriptionManager$1.SubscriptionManager = SubscriptionManager;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(CoinbaseWalletProvider$1, "__esModule", {
  value: true
});
CoinbaseWalletProvider$1.CoinbaseWalletProvider = void 0;
const safe_event_emitter_1 = __importDefault$7(safeEventEmitter);
const bn_js_1 = __importDefault$7(bn.exports);
const DiagnosticLogger_1$2 = DiagnosticLogger;
const errors_1$1 = errors$1;
const Session_1$2 = Session$1;
const WalletSDKRelayAbstract_1$1 = WalletSDKRelayAbstract$1;
const Web3Method_1$1 = Web3Method;
const Web3Response_1$1 = Web3Response;
const util_1$5 = util$3;
const eth_eip712_util_1 = __importDefault$7(ethEip712Util);
const FilterPolyfill_1 = FilterPolyfill$1;
const JSONRPC_1 = JSONRPC;
const SubscriptionManager_1 = SubscriptionManager$1;
const DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
const DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
class CoinbaseWalletProvider extends safe_event_emitter_1.default {
  constructor(options) {
    var _a2, _b2;
    super();
    this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
    this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
    this._relay = null;
    this._addresses = [];
    this.hasMadeFirstChainChangedEmission = false;
    this.setProviderInfo = this.setProviderInfo.bind(this);
    this.updateProviderInfo = this.updateProviderInfo.bind(this);
    this.getChainId = this.getChainId.bind(this);
    this.setAppInfo = this.setAppInfo.bind(this);
    this.enable = this.enable.bind(this);
    this.close = this.close.bind(this);
    this.send = this.send.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.request = this.request.bind(this);
    this._setAddresses = this._setAddresses.bind(this);
    this.scanQRCode = this.scanQRCode.bind(this);
    this.genericRequest = this.genericRequest.bind(this);
    this._chainIdFromOpts = options.chainId;
    this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
    this._overrideIsMetaMask = options.overrideIsMetaMask;
    this._relayProvider = options.relayProvider;
    this._storage = options.storage;
    this._relayEventManager = options.relayEventManager;
    this.diagnostic = options.diagnosticLogger;
    this.reloadOnDisconnect = true;
    this.isCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
    this.isCoinbaseBrowser = (_b2 = options.overrideIsCoinbaseBrowser) !== null && _b2 !== void 0 ? _b2 : false;
    this.qrUrl = options.qrUrl;
    this.supportsAddressSwitching = options.supportsAddressSwitching;
    this.isLedger = options.isLedger;
    const chainId = this.getChainId();
    const chainIdStr = (0, util_1$5.prepend0x)(chainId.toString(16));
    this.emit("connect", {
      chainIdStr
    });
    const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY);
    if (cachedAddresses) {
      const addresses = cachedAddresses.split(" ");
      if (addresses[0] !== "") {
        this._addresses = addresses.map((address) => (0, util_1$5.ensureAddressString)(address));
        this.emit("accountsChanged", addresses);
      }
    }
    this._subscriptionManager.events.on("notification", (notification) => {
      this.emit("message", {
        type: notification.method,
        data: notification.params
      });
    });
    if (this._addresses.length > 0) {
      void this.initializeRelay();
    }
    window.addEventListener("message", (event) => {
      var _a3;
      if (event.origin !== location.origin || event.source !== window) {
        return;
      }
      if (event.data.type !== "walletLinkMessage")
        return;
      if (event.data.data.action === "defaultChainChanged" || event.data.data.action === "dappChainSwitched") {
        const _chainId = event.data.data.chainId;
        const jsonRpcUrl = (_a3 = event.data.data.jsonRpcUrl) !== null && _a3 !== void 0 ? _a3 : this.jsonRpcUrl;
        this.updateProviderInfo(jsonRpcUrl, Number(_chainId));
      }
      if (event.data.data.action === "addressChanged") {
        this._setAddresses([event.data.data.address]);
      }
    });
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get networkVersion() {
    return this.getChainId().toString(10);
  }
  get chainId() {
    return (0, util_1$5.prepend0x)(this.getChainId().toString(16));
  }
  get isWalletLink() {
    return true;
  }
  get isMetaMask() {
    return this._overrideIsMetaMask;
  }
  get host() {
    return this.jsonRpcUrl;
  }
  get connected() {
    return true;
  }
  isConnected() {
    return true;
  }
  get jsonRpcUrl() {
    var _a2;
    return (_a2 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a2 !== void 0 ? _a2 : this._jsonRpcUrlFromOpts;
  }
  set jsonRpcUrl(value) {
    this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
  }
  disableReloadOnDisconnect() {
    this.reloadOnDisconnect = false;
  }
  setProviderInfo(jsonRpcUrl, chainId) {
    if (!(this.isLedger || this.isCoinbaseBrowser)) {
      this._chainIdFromOpts = chainId;
      this._jsonRpcUrlFromOpts = jsonRpcUrl;
    }
    this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
  }
  updateProviderInfo(jsonRpcUrl, chainId) {
    this.jsonRpcUrl = jsonRpcUrl;
    const originalChainId = this.getChainId();
    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
    const chainChanged = (0, util_1$5.ensureIntNumber)(chainId) !== originalChainId;
    if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
      this.emit("chainChanged", this.getChainId());
      this.hasMadeFirstChainChangedEmission = true;
    }
  }
  async watchAsset(type2, address, symbol, decimals, image, chainId) {
    const relay = await this.initializeRelay();
    const result = await relay.watchAsset(type2, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
    return !!result.result;
  }
  async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
    var _a2, _b2;
    if ((0, util_1$5.ensureIntNumber)(chainId) === this.getChainId()) {
      return false;
    }
    const relay = await this.initializeRelay();
    const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
    if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
      await relay.requestEthereumAccounts().promise;
    }
    const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
    if (((_a2 = res.result) === null || _a2 === void 0 ? void 0 : _a2.isApproved) === true) {
      this.updateProviderInfo(rpcUrls[0], chainId);
    }
    return ((_b2 = res.result) === null || _b2 === void 0 ? void 0 : _b2.isApproved) === true;
  }
  async switchEthereumChain(chainId) {
    const relay = await this.initializeRelay();
    const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0).promise;
    if ((0, Web3Response_1$1.isErrorResponse)(res) && res.errorCode) {
      if (res.errorCode === errors_1$1.standardErrorCodes.provider.unsupportedChain) {
        throw errors_1$1.standardErrors.provider.unsupportedChain(chainId);
      } else {
        throw errors_1$1.standardErrors.provider.custom({
          message: res.errorMessage,
          code: res.errorCode
        });
      }
    }
    const switchResponse = res.result;
    if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
      this.updateProviderInfo(switchResponse.rpcUrl, chainId);
    }
  }
  setAppInfo(appName, appLogoUrl) {
    void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
  }
  async enable() {
    var _a2;
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$2.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::enable",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Session_1$2.Session.hash(this._relay.session.id) : void 0
    });
    if (this._addresses.length > 0) {
      return [...this._addresses];
    }
    return await this.send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
  }
  async close() {
    const relay = await this.initializeRelay();
    relay.resetAndReload();
  }
  send(requestOrMethod, callbackOrParams) {
    try {
      const result = this._send(requestOrMethod, callbackOrParams);
      if (result instanceof Promise) {
        return result.catch((error) => {
          throw (0, errors_1$1.serializeError)(error, requestOrMethod);
        });
      }
    } catch (error) {
      throw (0, errors_1$1.serializeError)(error, requestOrMethod);
    }
  }
  _send(requestOrMethod, callbackOrParams) {
    if (typeof requestOrMethod === "string") {
      const method = requestOrMethod;
      const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
      const request = {
        jsonrpc: "2.0",
        id: 0,
        method,
        params
      };
      return this._sendRequestAsync(request).then((res) => res.result);
    }
    if (typeof callbackOrParams === "function") {
      const request = requestOrMethod;
      const callback = callbackOrParams;
      return this._sendAsync(request, callback);
    }
    if (Array.isArray(requestOrMethod)) {
      const requests = requestOrMethod;
      return requests.map((r2) => this._sendRequest(r2));
    }
    const req = requestOrMethod;
    return this._sendRequest(req);
  }
  async sendAsync(request, callback) {
    try {
      return this._sendAsync(request, callback).catch((error) => {
        throw (0, errors_1$1.serializeError)(error, request);
      });
    } catch (error) {
      return Promise.reject((0, errors_1$1.serializeError)(error, request));
    }
  }
  async _sendAsync(request, callback) {
    if (typeof callback !== "function") {
      throw new Error("callback is required");
    }
    if (Array.isArray(request)) {
      const arrayCb = callback;
      this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
      return;
    }
    const cb = callback;
    return this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
  }
  async request(args) {
    try {
      return this._request(args).catch((error) => {
        throw (0, errors_1$1.serializeError)(error, args.method);
      });
    } catch (error) {
      return Promise.reject((0, errors_1$1.serializeError)(error, args.method));
    }
  }
  async _request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw errors_1$1.standardErrors.rpc.invalidRequest({
        message: "Expected a single, non-array, object argument.",
        data: args
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw errors_1$1.standardErrors.rpc.invalidRequest({
        message: "'args.method' must be a non-empty string.",
        data: args
      });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw errors_1$1.standardErrors.rpc.invalidRequest({
        message: "'args.params' must be an object or array if provided.",
        data: args
      });
    }
    const newParams = params === void 0 ? [] : params;
    const id2 = this._relayEventManager.makeRequestId();
    const result = await this._sendRequestAsync({
      method,
      params: newParams,
      jsonrpc: "2.0",
      id: id2
    });
    return result.result;
  }
  async scanQRCode(match) {
    var _a2;
    const relay = await this.initializeRelay();
    const res = await relay.scanQRCode((0, util_1$5.ensureRegExpString)(match)).promise;
    if (typeof res.result !== "string") {
      throw (0, errors_1$1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1$1.Web3Method.scanQRCode);
    }
    return res.result;
  }
  async genericRequest(data, action) {
    var _a2;
    const relay = await this.initializeRelay();
    const res = await relay.genericRequest(data, action).promise;
    if (typeof res.result !== "string") {
      throw (0, errors_1$1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1$1.Web3Method.generic);
    }
    return res.result;
  }
  async selectProvider(providerOptions) {
    var _a2;
    const relay = await this.initializeRelay();
    const res = await relay.selectProvider(providerOptions).promise;
    if (typeof res.result !== "string") {
      throw (0, errors_1$1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1$1.Web3Method.selectProvider);
    }
    return res.result;
  }
  supportsSubscriptions() {
    return false;
  }
  subscribe() {
    throw new Error("Subscriptions are not supported");
  }
  unsubscribe() {
    throw new Error("Subscriptions are not supported");
  }
  disconnect() {
    return true;
  }
  _sendRequest(request) {
    const response = {
      jsonrpc: "2.0",
      id: request.id
    };
    const {
      method
    } = request;
    response.result = this._handleSynchronousMethods(request);
    if (response.result === void 0) {
      throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
    }
    return response;
  }
  _setAddresses(addresses, isDisconnect) {
    if (!Array.isArray(addresses)) {
      throw new Error("addresses is not an array");
    }
    const newAddresses = addresses.map((address) => (0, util_1$5.ensureAddressString)(address));
    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
      return;
    }
    if (this._addresses.length > 0 && this.supportsAddressSwitching === false && !isDisconnect) {
      return;
    }
    this._addresses = newAddresses;
    this.emit("accountsChanged", this._addresses);
    this._storage.setItem(WalletSDKRelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
  }
  _sendRequestAsync(request) {
    return new Promise((resolve, reject) => {
      try {
        const syncResult = this._handleSynchronousMethods(request);
        if (syncResult !== void 0) {
          return resolve({
            jsonrpc: "2.0",
            id: request.id,
            result: syncResult
          });
        }
        const filterPromise = this._handleAsynchronousFilterMethods(request);
        if (filterPromise !== void 0) {
          filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), {
            id: request.id
          }))).catch((err) => reject(err));
          return;
        }
        const subscriptionPromise = this._handleSubscriptionMethods(request);
        if (subscriptionPromise !== void 0) {
          subscriptionPromise.then((res) => resolve({
            jsonrpc: "2.0",
            id: request.id,
            result: res.result
          })).catch((err) => reject(err));
          return;
        }
      } catch (err) {
        return reject(err);
      }
      this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), {
        id: request.id
      }))).catch((err) => reject(err));
    });
  }
  _sendMultipleRequestsAsync(requests) {
    return Promise.all(requests.map((r2) => this._sendRequestAsync(r2)));
  }
  _handleSynchronousMethods(request) {
    const {
      method
    } = request;
    const params = request.params || [];
    switch (method) {
      case JSONRPC_1.JSONRPCMethod.eth_accounts:
        return this._eth_accounts();
      case JSONRPC_1.JSONRPCMethod.eth_coinbase:
        return this._eth_coinbase();
      case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
        return this._eth_uninstallFilter(params);
      case JSONRPC_1.JSONRPCMethod.net_version:
        return this._net_version();
      case JSONRPC_1.JSONRPCMethod.eth_chainId:
        return this._eth_chainId();
      default:
        return void 0;
    }
  }
  async _handleAsynchronousMethods(request) {
    const {
      method
    } = request;
    const params = request.params || [];
    switch (method) {
      case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
        return this._eth_requestAccounts();
      case JSONRPC_1.JSONRPCMethod.eth_sign:
        return this._eth_sign(params);
      case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
        return this._eth_ecRecover(params);
      case JSONRPC_1.JSONRPCMethod.personal_sign:
        return this._personal_sign(params);
      case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
        return this._personal_ecRecover(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
        return this._eth_signTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
        return this._eth_sendRawTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
        return this._eth_sendTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
        return this._eth_signTypedData_v1(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
        return this._throwUnsupportedMethodError();
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
        return this._eth_signTypedData_v3(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
        return this._eth_signTypedData_v4(params);
      case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:
        return this._cbwallet_arbitrary(params);
      case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
        return this._wallet_addEthereumChain(params);
      case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
        return this._wallet_switchEthereumChain(params);
      case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
        return this._wallet_watchAsset(params);
    }
    const relay = await this.initializeRelay();
    return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
  }
  _handleAsynchronousFilterMethods(request) {
    const {
      method
    } = request;
    const params = request.params || [];
    switch (method) {
      case JSONRPC_1.JSONRPCMethod.eth_newFilter:
        return this._eth_newFilter(params);
      case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
        return this._eth_newBlockFilter();
      case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
        return this._eth_newPendingTransactionFilter();
      case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
        return this._eth_getFilterChanges(params);
      case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
        return this._eth_getFilterLogs(params);
    }
    return void 0;
  }
  _handleSubscriptionMethods(request) {
    switch (request.method) {
      case JSONRPC_1.JSONRPCMethod.eth_subscribe:
      case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
        return this._subscriptionManager.handleRequest(request);
    }
    return void 0;
  }
  _isKnownAddress(addressString) {
    try {
      const addressStr = (0, util_1$5.ensureAddressString)(addressString);
      const lowercaseAddresses = this._addresses.map((address) => (0, util_1$5.ensureAddressString)(address));
      return lowercaseAddresses.includes(addressStr);
    } catch (_a2) {
    }
    return false;
  }
  _ensureKnownAddress(addressString) {
    var _a2;
    if (!this._isKnownAddress(addressString)) {
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$2.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
      throw new Error("Unknown Ethereum address");
    }
  }
  _prepareTransactionParams(tx) {
    const fromAddress = tx.from ? (0, util_1$5.ensureAddressString)(tx.from) : this.selectedAddress;
    if (!fromAddress) {
      throw new Error("Ethereum address is unavailable");
    }
    this._ensureKnownAddress(fromAddress);
    const toAddress = tx.to ? (0, util_1$5.ensureAddressString)(tx.to) : null;
    const weiValue = tx.value != null ? (0, util_1$5.ensureBN)(tx.value) : new bn_js_1.default(0);
    const data = tx.data ? (0, util_1$5.ensureBuffer)(tx.data) : Buffer.alloc(0);
    const nonce = tx.nonce != null ? (0, util_1$5.ensureIntNumber)(tx.nonce) : null;
    const gasPriceInWei = tx.gasPrice != null ? (0, util_1$5.ensureBN)(tx.gasPrice) : null;
    const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1$5.ensureBN)(tx.maxFeePerGas) : null;
    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1$5.ensureBN)(tx.maxPriorityFeePerGas) : null;
    const gasLimit = tx.gas != null ? (0, util_1$5.ensureBN)(tx.gas) : null;
    const chainId = this.getChainId();
    return {
      fromAddress,
      toAddress,
      weiValue,
      data,
      nonce,
      gasPriceInWei,
      maxFeePerGas,
      maxPriorityFeePerGas,
      gasLimit,
      chainId
    };
  }
  _isAuthorized() {
    return this._addresses.length > 0;
  }
  _requireAuthorization() {
    if (!this._isAuthorized()) {
      throw errors_1$1.standardErrors.provider.unauthorized({});
    }
  }
  _throwUnsupportedMethodError() {
    throw errors_1$1.standardErrors.provider.unsupportedMethod({});
  }
  async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
    this._ensureKnownAddress(address);
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
      return {
        jsonrpc: "2.0",
        id: 0,
        result: res.result
      };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied message signature");
      }
      throw err;
    }
  }
  async _ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
    const relay = await this.initializeRelay();
    const res = await relay.ethereumAddressFromSignedMessage(message, signature2, addPrefix).promise;
    return {
      jsonrpc: "2.0",
      id: 0,
      result: res.result
    };
  }
  _eth_accounts() {
    return [...this._addresses];
  }
  _eth_coinbase() {
    return this.selectedAddress || null;
  }
  _net_version() {
    return this.getChainId().toString(10);
  }
  _eth_chainId() {
    return (0, util_1$5.hexStringFromIntNumber)(this.getChainId());
  }
  getChainId() {
    const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);
    if (!chainIdStr) {
      return (0, util_1$5.ensureIntNumber)(this._chainIdFromOpts);
    }
    const chainId = parseInt(chainIdStr, 10);
    return (0, util_1$5.ensureIntNumber)(chainId);
  }
  async _eth_requestAccounts() {
    var _a2;
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$2.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::_eth_requestAccounts",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Session_1$2.Session.hash(this._relay.session.id) : void 0
    });
    if (this._addresses.length > 0) {
      return Promise.resolve({
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses
      });
    }
    let res;
    try {
      const relay = await this.initializeRelay();
      res = await relay.requestEthereumAccounts().promise;
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied account authorization");
      }
      throw err;
    }
    if (!res.result) {
      throw new Error("accounts received is empty");
    }
    this._setAddresses(res.result);
    if (!(this.isLedger || this.isCoinbaseBrowser)) {
      await this.switchEthereumChain(this.getChainId());
    }
    return {
      jsonrpc: "2.0",
      id: 0,
      result: this._addresses
    };
  }
  _eth_sign(params) {
    this._requireAuthorization();
    const address = (0, util_1$5.ensureAddressString)(params[0]);
    const message = (0, util_1$5.ensureBuffer)(params[1]);
    return this._signEthereumMessage(message, address, false);
  }
  _eth_ecRecover(params) {
    const message = (0, util_1$5.ensureBuffer)(params[0]);
    const signature2 = (0, util_1$5.ensureBuffer)(params[1]);
    return this._ethereumAddressFromSignedMessage(message, signature2, false);
  }
  _personal_sign(params) {
    this._requireAuthorization();
    const message = (0, util_1$5.ensureBuffer)(params[0]);
    const address = (0, util_1$5.ensureAddressString)(params[1]);
    return this._signEthereumMessage(message, address, true);
  }
  _personal_ecRecover(params) {
    const message = (0, util_1$5.ensureBuffer)(params[0]);
    const signature2 = (0, util_1$5.ensureBuffer)(params[1]);
    return this._ethereumAddressFromSignedMessage(message, signature2, true);
  }
  async _eth_signTransaction(params) {
    this._requireAuthorization();
    const tx = this._prepareTransactionParams(params[0] || {});
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signEthereumTransaction(tx).promise;
      return {
        jsonrpc: "2.0",
        id: 0,
        result: res.result
      };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied transaction signature");
      }
      throw err;
    }
  }
  async _eth_sendRawTransaction(params) {
    const signedTransaction = (0, util_1$5.ensureBuffer)(params[0]);
    const relay = await this.initializeRelay();
    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
    return {
      jsonrpc: "2.0",
      id: 0,
      result: res.result
    };
  }
  async _eth_sendTransaction(params) {
    this._requireAuthorization();
    const tx = this._prepareTransactionParams(params[0] || {});
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
      return {
        jsonrpc: "2.0",
        id: 0,
        result: res.result
      };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw errors_1$1.standardErrors.provider.userRejectedRequest("User denied transaction signature");
      }
      throw err;
    }
  }
  async _eth_signTypedData_v1(params) {
    this._requireAuthorization();
    const typedData = (0, util_1$5.ensureParsedJSONObject)(params[0]);
    const address = (0, util_1$5.ensureAddressString)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({
      data: typedData
    });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _eth_signTypedData_v3(params) {
    this._requireAuthorization();
    const address = (0, util_1$5.ensureAddressString)(params[0]);
    const typedData = (0, util_1$5.ensureParsedJSONObject)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedData_v3({
      data: typedData
    });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _eth_signTypedData_v4(params) {
    this._requireAuthorization();
    const address = (0, util_1$5.ensureAddressString)(params[0]);
    const typedData = (0, util_1$5.ensureParsedJSONObject)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedData_v4({
      data: typedData
    });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _cbwallet_arbitrary(params) {
    const action = params[0];
    const data = params[1];
    if (typeof data !== "string") {
      throw new Error("parameter must be a string");
    }
    if (typeof action !== "object" || action === null) {
      throw new Error("parameter must be an object");
    }
    const result = await this.genericRequest(action, data);
    return {
      jsonrpc: "2.0",
      id: 0,
      result
    };
  }
  async _wallet_addEthereumChain(params) {
    var _a2, _b2, _c2, _d;
    const request = params[0];
    if (((_a2 = request.rpcUrls) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
      return {
        jsonrpc: "2.0",
        id: 0,
        error: {
          code: 2,
          message: `please pass in at least 1 rpcUrl`
        }
      };
    }
    if (!request.chainName || request.chainName.trim() === "") {
      throw errors_1$1.standardErrors.rpc.invalidParams("chainName is a required field");
    }
    if (!request.nativeCurrency) {
      throw errors_1$1.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
    }
    const chainIdNumber = parseInt(request.chainId, 16);
    const success = await this.addEthereumChain(chainIdNumber, (_b2 = request.rpcUrls) !== null && _b2 !== void 0 ? _b2 : [], (_c2 = request.blockExplorerUrls) !== null && _c2 !== void 0 ? _c2 : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
    if (success) {
      return {
        jsonrpc: "2.0",
        id: 0,
        result: null
      };
    } else {
      return {
        jsonrpc: "2.0",
        id: 0,
        error: {
          code: 2,
          message: `unable to add ethereum chain`
        }
      };
    }
  }
  async _wallet_switchEthereumChain(params) {
    const request = params[0];
    await this.switchEthereumChain(parseInt(request.chainId, 16));
    return {
      jsonrpc: "2.0",
      id: 0,
      result: null
    };
  }
  async _wallet_watchAsset(params) {
    const request = Array.isArray(params) ? params[0] : params;
    if (!request.type) {
      throw errors_1$1.standardErrors.rpc.invalidParams("Type is required");
    }
    if ((request === null || request === void 0 ? void 0 : request.type) !== "ERC20") {
      throw errors_1$1.standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);
    }
    if (!(request === null || request === void 0 ? void 0 : request.options)) {
      throw errors_1$1.standardErrors.rpc.invalidParams("Options are required");
    }
    if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
      throw errors_1$1.standardErrors.rpc.invalidParams("Address is required");
    }
    const chainId = this.getChainId();
    const {
      address,
      symbol,
      image,
      decimals
    } = request.options;
    const res = await this.watchAsset(request.type, address, symbol, decimals, image, chainId);
    return {
      jsonrpc: "2.0",
      id: 0,
      result: res
    };
  }
  _eth_uninstallFilter(params) {
    const filterId = (0, util_1$5.ensureHexString)(params[0]);
    return this._filterPolyfill.uninstallFilter(filterId);
  }
  async _eth_newFilter(params) {
    const param = params[0];
    const filterId = await this._filterPolyfill.newFilter(param);
    return {
      jsonrpc: "2.0",
      id: 0,
      result: filterId
    };
  }
  async _eth_newBlockFilter() {
    const filterId = await this._filterPolyfill.newBlockFilter();
    return {
      jsonrpc: "2.0",
      id: 0,
      result: filterId
    };
  }
  async _eth_newPendingTransactionFilter() {
    const filterId = await this._filterPolyfill.newPendingTransactionFilter();
    return {
      jsonrpc: "2.0",
      id: 0,
      result: filterId
    };
  }
  _eth_getFilterChanges(params) {
    const filterId = (0, util_1$5.ensureHexString)(params[0]);
    return this._filterPolyfill.getFilterChanges(filterId);
  }
  _eth_getFilterLogs(params) {
    const filterId = (0, util_1$5.ensureHexString)(params[0]);
    return this._filterPolyfill.getFilterLogs(filterId);
  }
  initializeRelay() {
    if (this._relay) {
      return Promise.resolve(this._relay);
    }
    return this._relayProvider().then((relay) => {
      relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));
      relay.setChainCallback((chainId, jsonRpcUrl) => {
        this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));
      });
      relay.setDappDefaultChainCallback(this._chainIdFromOpts);
      this._relay = relay;
      return relay;
    });
  }
}
CoinbaseWalletProvider$1.CoinbaseWalletProvider = CoinbaseWalletProvider;
var WalletSDKUI$1 = {};
var LinkFlow$1 = {};
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(preact_module);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function isFunction(x2) {
  return typeof x2 === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = /* @__PURE__ */ new Error();
      /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$1 = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};
var isArray = /* @__PURE__ */ function() {
  return Array.isArray || function(x2) {
    return x2 && typeof x2.length === "number";
  };
}();
function isObject(x2) {
  return x2 !== null && typeof x2 === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors2) {
    Error.call(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors2;
    if (this.closed) {
      return;
    }
    var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
        var parent_1 = _parentOrParents[index2];
        parent_1.remove(this);
      }
    }
    if (isFunction(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e2) {
        errors2 = e2 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e2.errors) : [e2];
      }
    }
    if (isArray(_subscriptions)) {
      var index2 = -1;
      var len = _subscriptions.length;
      while (++index2 < len) {
        var sub = _subscriptions[index2];
        if (isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e2) {
            errors2 = errors2 || [];
            if (e2 instanceof UnsubscriptionError) {
              errors2 = errors2.concat(flattenUnsubscriptionErrors(e2.errors));
            } else {
              errors2.push(e2);
            }
          }
        }
      }
    }
    if (errors2) {
      throw new UnsubscriptionError(errors2);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors2) {
  return errors2.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$1;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$1;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;
    if (isFunction(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$1) {
        context = Object.create(observerOrNext);
        if (isFunction(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
    try {
      fn2.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn2.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty$1);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe) {
    this._isScalar = false;
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy2 = observers.slice();
      for (var i = 0; i < len; i++) {
        copy2[i].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy2 = observers.slice();
    for (var i = 0; i < len; i++) {
      copy2[i].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy2 = observers.slice();
    for (var i = 0; i < len; i++) {
      copy2[i].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: {
      value: null
    },
    _refCount: {
      value: 0,
      writable: true
    },
    _subject: {
      value: null,
      writable: true
    },
    _connection: {
      value: null,
      writable: true
    },
    _subscribe: {
      value: connectableProto._subscribe
    },
    _isComplete: {
      value: connectableProto._isComplete,
      writable: true
    },
    getSubject: {
      value: connectableProto.getSubject
    },
    connect: {
      value: connectableProto.connect
    },
    refCount: {
      value: connectableProto.refCount
    }
  };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value) {
    var key2;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key2);
  };
  GroupBySubscriber2.prototype._group = function(value, key2) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = /* @__PURE__ */ new Map();
    }
    var group = groups.get(key2);
    var element2;
    if (this.elementSelector) {
      try {
        element2 = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element2 = value;
    }
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject();
      groups.set(key2, group);
      var groupedObservable = new GroupedObservable(key2, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key2, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
      }
    }
    if (!group.closed) {
      group.next(element2);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key2) {
        group.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key2) {
        group.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key2) {
    this.groups.delete(key2);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key2, group, parent) {
    var _this = _super.call(this, group) || this;
    _this.key = key2;
    _this.group = group;
    _this.parent = parent;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, parent = _a2.parent, key2 = _a2.key;
    this.key = this.parent = null;
    if (parent) {
      parent.removeGroup(key2);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key2, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key2;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription();
    var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable);
var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    parent.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent = this.parent;
    if (!parent.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent.count -= 1;
      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
        parent.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription);
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, delay2) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state2);
    } catch (e2) {
      errored = true;
      errorValue = !!e2 && e2 || new Error(e2);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id2 = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index2 = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index2 !== -1) {
      actions.splice(index2, 1);
    }
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay2, state2);
    } else {
      return _super.prototype.schedule.call(this, work, delay2, state2);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue = queueScheduler;
var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var subscribeToArray = function(array2) {
  return function(subscriber) {
    for (var i = 0, len = array2.length; i < len && !subscriber.closed; i++) {
      subscriber.next(array2[i]);
    }
    subscriber.complete();
  };
};
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i = 0;
    sub.add(scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch$7, 0, {
        error,
        subscriber
      });
    });
  }
}
function dispatch$7(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var NotificationKind;
/* @__PURE__ */ (function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler;
    _this.delay = delay2;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
var ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime2 === void 0) {
      windowTime2 = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
    if (windowTime2 === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time2, value) {
    this.time = time2;
    this.value = value;
  }
  return ReplayEvent2;
}();
var AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject);
var nextHandle = 1;
var RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
var AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    if (scheduler.actions.length === 0) {
      Immediate.clearImmediate(id2);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);
var AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);
var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
var asap = asapScheduler;
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var AnimationFrameAction = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
      return scheduler.flush(null);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id2);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);
var AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);
var animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction);
var animationFrame = animationFrameScheduler;
var VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error, action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = /* @__PURE__ */ function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index2) {
    if (index2 === void 0) {
      index2 = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index2;
    _this.active = true;
    _this.index = scheduler.index = index2;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (!this.id) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.active = false;
    var action = new VirtualAction2(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state2, delay2);
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state2, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);
function noop() {
}
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
var TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state2 = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch$6, 0, state2);
      }
    });
  };
}
function dispatch$6(state2) {
  var _this = this;
  var args = state2.args, subscriber = state2.subscriber, params = state2.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext$3, 0, {
        value,
        subject
      }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$3(state2) {
  var value = state2.value, subject = state2.subject;
  subject.next(value);
  subject.complete();
}
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch$5, 0, {
          params,
          subscriber,
          context
        });
      }
    });
  };
}
function dispatch$5(state2) {
  var _this = this;
  var params = state2.params, subscriber = state2.subscriber, context = state2.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, {
          err,
          subject
        }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext$2, 0, {
          value,
          subject
        }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, {
        err,
        subject
      }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$12 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$12.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$12.return === "function") {
      subscriber.add(function() {
        if (iterator$12.return) {
          iterator$12.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;
      for (var i = 0; i < len; i++) {
        var observable2 = observables[i];
        this.add(subscribeToResult(this, observable2, void 0, i));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator$12;
    sub.add(function() {
      if (iterator$12 && typeof iterator$12.return === "function") {
        iterator$12.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator$12 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done2;
        try {
          var result = iterator$12.next();
          value = result.value;
          done2 = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a2, i) {
        return from(project(a2, i)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
var flatMap = mergeMap;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty();
    return source.subscribe(subscriber);
  });
}
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key2) {
        return first_1[key2];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i2) {
      var source = from(sources[i2]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i2] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function(result, key2, i3) {
                return result[key2] = values[i3], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
  });
}
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e2) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e2);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e2[_i] = arguments[_i];
      }
      return subscriber.next(e2.length === 1 ? e2[0] : e2);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
function generate2(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state2 = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch$4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state: state2
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state2);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state2);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state2 = iterate(state2);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch$4(state2) {
  var subscriber = state2.subscriber, condition = state2.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state2.needIterate) {
    try {
      state2.state = state2.iterate(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state2.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state2.resultSelector(state2.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state2);
}
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch$3, period, {
      subscriber,
      counter: 0,
      period
    }));
    return subscriber;
  });
}
function dispatch$3(state2) {
  var subscriber = state2.subscriber, counter = state2.counter, period = state2.period;
  subscriber.next(counter);
  this.schedule({
    subscriber,
    counter: counter + 1,
    period
  }, period);
}
function merge$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var NEVER = /* @__PURE__ */ new Observable(noop);
function never() {
  return NEVER;
}
function onErrorResumeNext$1() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray(first2)) {
    return onErrorResumeNext$1.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length && !subscriber.closed; i++) {
        var key2 = keys[i];
        if (obj.hasOwnProperty(key2)) {
          subscriber.next([key2, obj[key2]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch$2, 0, {
        keys,
        index: 0,
        subscriber,
        subscription,
        obj
      }));
      return subscription;
    });
  }
}
function dispatch$2(state2) {
  var keys = state2.keys, index2 = state2.index, subscriber = state2.subscriber, subscription = state2.subscription, obj = state2.obj;
  if (!subscriber.closed) {
    if (index2 < keys.length) {
      var key2 = keys[index2];
      subscriber.next([key2, obj[key2]]);
      subscription.add(this.schedule({
        keys,
        index: index2 + 1,
        subscriber,
        subscription,
        obj
      }));
    } else {
      subscriber.complete();
    }
  }
}
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
function partition$1(source, predicate, thisArg) {
  return [filter(predicate, thisArg)(new Observable(subscribeTo(source))), filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))];
}
function race$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i = 0; i < len && !this.hasFirst; i++) {
        var observable2 = observables[i];
        var subscription = subscribeToResult(this, observable2, void 0, i);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i = 0; i < this.subscriptions.length; i++) {
        if (i !== outerIndex) {
          var subscription = this.subscriptions[i];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index2 = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch$1, 0, {
        index: index2,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index2++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch$1(state2) {
  var start = state2.start, index2 = state2.index, count2 = state2.count, subscriber = state2.subscriber;
  if (index2 >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state2.index = index2 + 1;
  state2.start = start + 1;
  this.schedule(state2);
}
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state2) {
  var index2 = state2.index, period = state2.period, subscriber = state2.subscriber;
  subscriber.next(index2);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state2.index = index2 + 1;
  this.schedule(state2, period);
}
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
function zip$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    if (isArray(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator] === "function") {
      iterators.push(new StaticIterator(value[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  };
  return StaticIterator2;
}();
var StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array2) {
    this.array = array2;
    this.index = 0;
    this.length = 0;
    this.length = array2.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value) {
    var i = this.index++;
    var array2 = this.array;
    return i < this.length ? {
      value: array2[i],
      done: false
    } : {
      value: null,
      done: true
    };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    if (buffer2.length === 0 && this.isComplete) {
      return {
        value: null,
        done: true
      };
    } else {
      return {
        value: buffer2.shift(),
        done: false
      };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  };
  return ZipBufferIterator2;
}(SimpleOuterSubscriber);
const _esm5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Observable,
  ConnectableObservable,
  GroupedObservable,
  observable,
  Subject,
  BehaviorSubject,
  ReplaySubject,
  AsyncSubject,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  queue,
  queueScheduler,
  animationFrame,
  animationFrameScheduler,
  VirtualTimeScheduler,
  VirtualAction,
  Scheduler,
  Subscription,
  Subscriber,
  Notification,
  get NotificationKind() {
    return NotificationKind;
  },
  pipe,
  noop,
  identity,
  isObservable,
  ArgumentOutOfRangeError,
  EmptyError,
  ObjectUnsubscribedError,
  UnsubscriptionError,
  TimeoutError,
  bindCallback,
  bindNodeCallback,
  combineLatest: combineLatest$1,
  concat: concat$1,
  defer,
  empty,
  forkJoin,
  from,
  fromEvent,
  fromEventPattern,
  generate: generate2,
  iif,
  interval,
  merge: merge$1,
  never,
  of,
  onErrorResumeNext: onErrorResumeNext$1,
  pairs,
  partition: partition$1,
  race: race$1,
  range,
  throwError,
  timer,
  using,
  zip: zip$1,
  scheduled,
  EMPTY,
  NEVER,
  config
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(_esm5);
var ConnectDialog$1 = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(clsx_m);
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(hooks_module);
var ConnectContent$1 = {};
var CloseIcon$1 = {};
Object.defineProperty(CloseIcon$1, "__esModule", {
  value: true
});
CloseIcon$1.CloseIcon = void 0;
const preact_1$b = require$$1$1;
function CloseIcon(props) {
  return (0, preact_1$b.h)("svg", Object.assign({
    width: "40",
    height: "40",
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), (0, preact_1$b.h)("path", {
    d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z"
  }));
}
CloseIcon$1.CloseIcon = CloseIcon;
var coinbaseRoundSvg = {};
Object.defineProperty(coinbaseRoundSvg, "__esModule", {
  value: true
});
coinbaseRoundSvg.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMTQuMDM3IDE4LjkyNmMtMi43NSAwLTQuOTA3LTIuMjA1LTQuOTA3LTQuOTI2IDAtMi43MiAyLjIzLTQuOTI2IDQuOTA3LTQuOTI2YTQuODY2IDQuODY2IDAgMCAxIDQuODMzIDQuMTE4aDQuOTgyYy0uNDQ2LTUuMDczLTQuNjg0LTkuMDQ0LTkuODE1LTkuMDQ0QzguNjEgNC4xNDggNC4xNDkgOC41NiA0LjE0OSAxNHM0LjM4NyA5Ljg1MiA5Ljg5IDkuODUyYzUuMjA0IDAgOS4zNjgtMy45NyA5LjgxNC05LjA0M0gxOC44N2E0Ljg2NiA0Ljg2NiAwIDAgMS00LjgzMyA0LjExN1oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=`;
var coinbaseWalletRoundSvg = {};
Object.defineProperty(coinbaseWalletRoundSvg, "__esModule", {
  value: true
});
coinbaseWalletRoundSvg.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMjMuODUyIDE0QTkuODM0IDkuODM0IDAgMCAxIDE0IDIzLjg1MiA5LjgzNCA5LjgzNCAwIDAgMSA0LjE0OCAxNCA5LjgzNCA5LjgzNCAwIDAgMSAxNCA0LjE0OCA5LjgzNCA5LjgzNCAwIDAgMSAyMy44NTIgMTRaIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjE4NSAxMi41MDRjMC0uNDU2IDAtLjcxLjA5OC0uODYyLjA5OC0uMTUyLjE5Ni0uMzA0LjM0My0uMzU1LjE5Ni0uMTAyLjM5Mi0uMTAyLjg4MS0uMTAyaDIuOTg2Yy40OSAwIC42ODYgMCAuODgyLjEwMi4xNDYuMTAxLjI5My4yMDMuMzQyLjM1NS4wOTguMjAzLjA5OC40MDYuMDk4Ljg2MnYyLjk5MmMwIC40NTcgMCAuNzEtLjA5OC44NjMtLjA5OC4xNTItLjE5NS4zMDQtLjM0Mi4zNTUtLjE5Ni4xMDEtLjM5Mi4xMDEtLjg4Mi4xMDFoLTIuOTg2Yy0uNDkgMC0uNjg1IDAtLjg4LS4xMDEtLjE0OC0uMTAyLS4yOTUtLjIwMy0uMzQ0LS4zNTUtLjA5OC0uMjAzLS4wOTgtLjQwNi0uMDk4LS44NjN2LTIuOTkyWiIgZmlsbD0iIzAwNTJGRiIvPjwvc3ZnPg==`;
var QRCodeIcon$1 = {};
Object.defineProperty(QRCodeIcon$1, "__esModule", {
  value: true
});
QRCodeIcon$1.QRCodeIcon = void 0;
const preact_1$a = require$$1$1;
function QRCodeIcon(props) {
  return (0, preact_1$a.h)("svg", Object.assign({
    width: "10",
    height: "10",
    viewBox: "0 0 10 10",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), (0, preact_1$a.h)("path", {
    d: "M8.2271 1.77124L7.0271 1.77124V2.97124H8.2271V1.77124Z"
  }), (0, preact_1$a.h)("path", {
    d: "M5.44922 0.199219L5.44922 4.54922L9.79922 4.54922V0.199219L5.44922 0.199219ZM8.89922 3.64922L6.34922 3.64922L6.34922 1.09922L8.89922 1.09922V3.64922Z"
  }), (0, preact_1$a.h)("path", {
    d: "M2.97124 1.77124L1.77124 1.77124L1.77124 2.97124H2.97124V1.77124Z"
  }), (0, preact_1$a.h)("path", {
    d: "M0.199219 4.54922L4.54922 4.54922L4.54922 0.199219L0.199219 0.199219L0.199219 4.54922ZM1.09922 1.09922L3.64922 1.09922L3.64922 3.64922L1.09922 3.64922L1.09922 1.09922Z"
  }), (0, preact_1$a.h)("path", {
    d: "M2.97124 7.0271H1.77124L1.77124 8.2271H2.97124V7.0271Z"
  }), (0, preact_1$a.h)("path", {
    d: "M0.199219 9.79922H4.54922L4.54922 5.44922L0.199219 5.44922L0.199219 9.79922ZM1.09922 6.34922L3.64922 6.34922L3.64922 8.89922H1.09922L1.09922 6.34922Z"
  }), (0, preact_1$a.h)("path", {
    d: "M8.89922 7.39912H7.99922V5.40112H5.44922L5.44922 9.79912H6.34922L6.34922 6.30112H7.09922V8.29912H9.79922V5.40112H8.89922V7.39912Z"
  }), (0, preact_1$a.h)("path", {
    d: "M7.99912 8.89917H7.09912V9.79917H7.99912V8.89917Z"
  }), (0, preact_1$a.h)("path", {
    d: "M9.79917 8.89917H8.89917V9.79917H9.79917V8.89917Z"
  }));
}
QRCodeIcon$1.QRCodeIcon = QRCodeIcon;
var QRLogoCoinbase = {};
Object.defineProperty(QRLogoCoinbase, "__esModule", {
  value: true
});
const svg = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 100C77.6142 100 100 77.6142 100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100Z" fill="white"/>
        <path d="M50.512 94C74.2907 94 93.5673 74.5244 93.5673 50.5C93.5673 26.4756 74.2907 7 50.512 7C26.7332 7 7.45667 26.4756 7.45667 50.5C7.45667 74.5244 26.7332 94 50.512 94Z" fill="#0052FF"/>
        <path d="M50.6248 65.4335C42.3697 65.4335 35.8996 58.7469 35.8996 50.5C35.8996 42.2531 42.5928 35.5664 50.6248 35.5664C57.9873 35.5664 64.0111 40.9157 65.1267 48.0481H80.0749C78.7363 32.6688 66.0191 20.6328 50.6248 20.6328C34.3379 20.6328 20.9514 34.0062 20.9514 50.5C20.9514 66.9936 34.1148 80.3671 50.6248 80.3671C66.2422 80.3671 78.7363 68.331 80.0749 52.9516H65.1267C64.0111 60.0841 57.9873 65.4335 50.6248 65.4335Z" fill="white"/>
    </svg>
`;
QRLogoCoinbase.default = svg;
var QRLogoWallet = {};
Object.defineProperty(QRLogoWallet, "__esModule", {
  value: true
});
QRLogoWallet.default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="50" fill="white"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
    </svg>
`;
var StatusDotIcon$1 = {};
Object.defineProperty(StatusDotIcon$1, "__esModule", {
  value: true
});
StatusDotIcon$1.StatusDotIcon = void 0;
const preact_1$9 = require$$1$1;
function StatusDotIcon(props) {
  return (0, preact_1$9.h)("svg", Object.assign({
    width: "10",
    height: "10",
    viewBox: "0 0 10 10",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), (0, preact_1$9.h)("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M2.29995 4.99995C2.29995 5.57985 1.82985 6.04995 1.24995 6.04995C0.670052 6.04995 0.199951 5.57985 0.199951 4.99995C0.199951 4.42005 0.670052 3.94995 1.24995 3.94995C1.82985 3.94995 2.29995 4.42005 2.29995 4.99995ZM4.99995 6.04995C5.57985 6.04995 6.04995 5.57985 6.04995 4.99995C6.04995 4.42005 5.57985 3.94995 4.99995 3.94995C4.42005 3.94995 3.94995 4.42005 3.94995 4.99995C3.94995 5.57985 4.42005 6.04995 4.99995 6.04995ZM8.74995 6.04995C9.32985 6.04995 9.79995 5.57985 9.79995 4.99995C9.79995 4.42005 9.32985 3.94995 8.74995 3.94995C8.17005 3.94995 7.69995 4.42005 7.69995 4.99995C7.69995 5.57985 8.17005 6.04995 8.74995 6.04995Z"
  }));
}
StatusDotIcon$1.StatusDotIcon = StatusDotIcon;
var QRCode$2 = {};
function QR8bitByte(data) {
  this.mode = QRMode.MODE_8BIT_BYTE;
  this.data = data;
  this.parsedData = [];
  for (var i = 0, l2 = this.data.length; i < l2; i++) {
    var byteArray = [];
    var code2 = this.data.charCodeAt(i);
    if (code2 > 65536) {
      byteArray[0] = 240 | (code2 & 1835008) >>> 18;
      byteArray[1] = 128 | (code2 & 258048) >>> 12;
      byteArray[2] = 128 | (code2 & 4032) >>> 6;
      byteArray[3] = 128 | code2 & 63;
    } else if (code2 > 2048) {
      byteArray[0] = 224 | (code2 & 61440) >>> 12;
      byteArray[1] = 128 | (code2 & 4032) >>> 6;
      byteArray[2] = 128 | code2 & 63;
    } else if (code2 > 128) {
      byteArray[0] = 192 | (code2 & 1984) >>> 6;
      byteArray[1] = 128 | code2 & 63;
    } else {
      byteArray[0] = code2;
    }
    this.parsedData.push(byteArray);
  }
  this.parsedData = Array.prototype.concat.apply([], this.parsedData);
  if (this.parsedData.length != this.data.length) {
    this.parsedData.unshift(191);
    this.parsedData.unshift(187);
    this.parsedData.unshift(239);
  }
}
QR8bitByte.prototype = {
  getLength: function(buffer2) {
    return this.parsedData.length;
  },
  write: function(buffer2) {
    for (var i = 0, l2 = this.parsedData.length; i < l2; i++) {
      buffer2.put(this.parsedData[i], 8);
    }
  }
};
function QRCodeModel(typeNumber, errorCorrectLevel) {
  this.typeNumber = typeNumber;
  this.errorCorrectLevel = errorCorrectLevel;
  this.modules = null;
  this.moduleCount = 0;
  this.dataCache = null;
  this.dataList = [];
}
QRCodeModel.prototype = {
  addData: function(data) {
    var newData = new QR8bitByte(data);
    this.dataList.push(newData);
    this.dataCache = null;
  },
  isDark: function(row, col) {
    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
      throw new Error(row + "," + col);
    }
    return this.modules[row][col];
  },
  getModuleCount: function() {
    return this.moduleCount;
  },
  make: function() {
    this.makeImpl(false, this.getBestMaskPattern());
  },
  makeImpl: function(test2, maskPattern2) {
    this.moduleCount = this.typeNumber * 4 + 17;
    this.modules = new Array(this.moduleCount);
    for (var row = 0; row < this.moduleCount; row++) {
      this.modules[row] = new Array(this.moduleCount);
      for (var col = 0; col < this.moduleCount; col++) {
        this.modules[row][col] = null;
      }
    }
    this.setupPositionProbePattern(0, 0);
    this.setupPositionProbePattern(this.moduleCount - 7, 0);
    this.setupPositionProbePattern(0, this.moduleCount - 7);
    this.setupPositionAdjustPattern();
    this.setupTimingPattern();
    this.setupTypeInfo(test2, maskPattern2);
    if (this.typeNumber >= 7) {
      this.setupTypeNumber(test2);
    }
    if (this.dataCache == null) {
      this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
    }
    this.mapData(this.dataCache, maskPattern2);
  },
  setupPositionProbePattern: function(row, col) {
    for (var r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || this.moduleCount <= row + r2)
        continue;
      for (var c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || this.moduleCount <= col + c2)
          continue;
        if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
          this.modules[row + r2][col + c2] = true;
        } else {
          this.modules[row + r2][col + c2] = false;
        }
      }
    }
  },
  getBestMaskPattern: function() {
    var minLostPoint = 0;
    var pattern2 = 0;
    for (var i = 0; i < 8; i++) {
      this.makeImpl(true, i);
      var lostPoint = QRUtil.getLostPoint(this);
      if (i == 0 || minLostPoint > lostPoint) {
        minLostPoint = lostPoint;
        pattern2 = i;
      }
    }
    return pattern2;
  },
  createMovieClip: function(target_mc, instance_name, depth) {
    var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
    var cs = 1;
    this.make();
    for (var row = 0; row < this.modules.length; row++) {
      var y2 = row * cs;
      for (var col = 0; col < this.modules[row].length; col++) {
        var x2 = col * cs;
        var dark = this.modules[row][col];
        if (dark) {
          qr_mc.beginFill(0, 100);
          qr_mc.moveTo(x2, y2);
          qr_mc.lineTo(x2 + cs, y2);
          qr_mc.lineTo(x2 + cs, y2 + cs);
          qr_mc.lineTo(x2, y2 + cs);
          qr_mc.endFill();
        }
      }
    }
    return qr_mc;
  },
  setupTimingPattern: function() {
    for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
      if (this.modules[r2][6] != null) {
        continue;
      }
      this.modules[r2][6] = r2 % 2 == 0;
    }
    for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
      if (this.modules[6][c2] != null) {
        continue;
      }
      this.modules[6][c2] = c2 % 2 == 0;
    }
  },
  setupPositionAdjustPattern: function() {
    var pos = QRUtil.getPatternPosition(this.typeNumber);
    for (var i = 0; i < pos.length; i++) {
      for (var j2 = 0; j2 < pos.length; j2++) {
        var row = pos[i];
        var col = pos[j2];
        if (this.modules[row][col] != null) {
          continue;
        }
        for (var r2 = -2; r2 <= 2; r2++) {
          for (var c2 = -2; c2 <= 2; c2++) {
            if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
              this.modules[row + r2][col + c2] = true;
            } else {
              this.modules[row + r2][col + c2] = false;
            }
          }
        }
      }
    }
  },
  setupTypeNumber: function(test2) {
    var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
    for (var i = 0; i < 18; i++) {
      var mod = !test2 && (bits >> i & 1) == 1;
      this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
    }
    for (var i = 0; i < 18; i++) {
      var mod = !test2 && (bits >> i & 1) == 1;
      this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
    }
  },
  setupTypeInfo: function(test2, maskPattern2) {
    var data = this.errorCorrectLevel << 3 | maskPattern2;
    var bits = QRUtil.getBCHTypeInfo(data);
    for (var i = 0; i < 15; i++) {
      var mod = !test2 && (bits >> i & 1) == 1;
      if (i < 6) {
        this.modules[i][8] = mod;
      } else if (i < 8) {
        this.modules[i + 1][8] = mod;
      } else {
        this.modules[this.moduleCount - 15 + i][8] = mod;
      }
    }
    for (var i = 0; i < 15; i++) {
      var mod = !test2 && (bits >> i & 1) == 1;
      if (i < 8) {
        this.modules[8][this.moduleCount - i - 1] = mod;
      } else if (i < 9) {
        this.modules[8][15 - i - 1 + 1] = mod;
      } else {
        this.modules[8][15 - i - 1] = mod;
      }
    }
    this.modules[this.moduleCount - 8][8] = !test2;
  },
  mapData: function(data, maskPattern2) {
    var inc2 = -1;
    var row = this.moduleCount - 1;
    var bitIndex = 7;
    var byteIndex = 0;
    for (var col = this.moduleCount - 1; col > 0; col -= 2) {
      if (col == 6)
        col--;
      while (true) {
        for (var c2 = 0; c2 < 2; c2++) {
          if (this.modules[row][col - c2] == null) {
            var dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) == 1;
            }
            var mask2 = QRUtil.getMask(maskPattern2, row, col - c2);
            if (mask2) {
              dark = !dark;
            }
            this.modules[row][col - c2] = dark;
            bitIndex--;
            if (bitIndex == -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc2;
        if (row < 0 || this.moduleCount <= row) {
          row -= inc2;
          inc2 = -inc2;
          break;
        }
      }
    }
  }
};
QRCodeModel.PAD0 = 236;
QRCodeModel.PAD1 = 17;
QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
  var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
  var buffer2 = new QRBitBuffer();
  for (var i = 0; i < dataList.length; i++) {
    var data = dataList[i];
    buffer2.put(data.mode, 4);
    buffer2.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
    data.write(buffer2);
  }
  var totalDataCount = 0;
  for (var i = 0; i < rsBlocks.length; i++) {
    totalDataCount += rsBlocks[i].dataCount;
  }
  if (buffer2.getLengthInBits() > totalDataCount * 8) {
    throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
  }
  if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 != 0) {
    buffer2.putBit(false);
  }
  while (true) {
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCodeModel.PAD0, 8);
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCodeModel.PAD1, 8);
  }
  return QRCodeModel.createBytes(buffer2, rsBlocks);
};
QRCodeModel.createBytes = function(buffer2, rsBlocks) {
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcdata = new Array(rsBlocks.length);
  var ecdata = new Array(rsBlocks.length);
  for (var r2 = 0; r2 < rsBlocks.length; r2++) {
    var dcCount = rsBlocks[r2].dataCount;
    var ecCount = rsBlocks[r2].totalCount - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcdata[r2] = new Array(dcCount);
    for (var i = 0; i < dcdata[r2].length; i++) {
      dcdata[r2][i] = 255 & buffer2.buffer[i + offset];
    }
    offset += dcCount;
    var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
    var rawPoly = new QRPolynomial(dcdata[r2], rsPoly.getLength() - 1);
    var modPoly = rawPoly.mod(rsPoly);
    ecdata[r2] = new Array(rsPoly.getLength() - 1);
    for (var i = 0; i < ecdata[r2].length; i++) {
      var modIndex = i + modPoly.getLength() - ecdata[r2].length;
      ecdata[r2][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
    }
  }
  var totalCodeCount = 0;
  for (var i = 0; i < rsBlocks.length; i++) {
    totalCodeCount += rsBlocks[i].totalCount;
  }
  var data = new Array(totalCodeCount);
  var index2 = 0;
  for (var i = 0; i < maxDcCount; i++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i < dcdata[r2].length) {
        data[index2++] = dcdata[r2][i];
      }
    }
  }
  for (var i = 0; i < maxEcCount; i++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i < ecdata[r2].length) {
        data[index2++] = ecdata[r2][i];
      }
    }
  }
  return data;
};
var QRMode = {
  MODE_NUMBER: 1 << 0,
  MODE_ALPHA_NUM: 1 << 1,
  MODE_8BIT_BYTE: 1 << 2,
  MODE_KANJI: 1 << 3
};
var QRErrorCorrectLevel = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
};
var QRMaskPattern = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};
var QRUtil = {
  PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
  G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
  G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
  G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
  getBCHTypeInfo: function(data) {
    var d2 = data << 10;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
      d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
    }
    return (data << 10 | d2) ^ QRUtil.G15_MASK;
  },
  getBCHTypeNumber: function(data) {
    var d2 = data << 12;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
      d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
    }
    return data << 12 | d2;
  },
  getBCHDigit: function(data) {
    var digit = 0;
    while (data != 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  },
  getPatternPosition: function(typeNumber) {
    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
  },
  getMask: function(maskPattern2, i, j2) {
    switch (maskPattern2) {
      case QRMaskPattern.PATTERN000:
        return (i + j2) % 2 == 0;
      case QRMaskPattern.PATTERN001:
        return i % 2 == 0;
      case QRMaskPattern.PATTERN010:
        return j2 % 3 == 0;
      case QRMaskPattern.PATTERN011:
        return (i + j2) % 3 == 0;
      case QRMaskPattern.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j2 / 3)) % 2 == 0;
      case QRMaskPattern.PATTERN101:
        return i * j2 % 2 + i * j2 % 3 == 0;
      case QRMaskPattern.PATTERN110:
        return (i * j2 % 2 + i * j2 % 3) % 2 == 0;
      case QRMaskPattern.PATTERN111:
        return (i * j2 % 3 + (i + j2) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  },
  getErrorCorrectPolynomial: function(errorCorrectLength) {
    var a2 = new QRPolynomial([1], 0);
    for (var i = 0; i < errorCorrectLength; i++) {
      a2 = a2.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
    }
    return a2;
  },
  getLengthInBits: function(mode2, type2) {
    if (1 <= type2 && type2 < 10) {
      switch (mode2) {
        case QRMode.MODE_NUMBER:
          return 10;
        case QRMode.MODE_ALPHA_NUM:
          return 9;
        case QRMode.MODE_8BIT_BYTE:
          return 8;
        case QRMode.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + mode2);
      }
    } else if (type2 < 27) {
      switch (mode2) {
        case QRMode.MODE_NUMBER:
          return 12;
        case QRMode.MODE_ALPHA_NUM:
          return 11;
        case QRMode.MODE_8BIT_BYTE:
          return 16;
        case QRMode.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + mode2);
      }
    } else if (type2 < 41) {
      switch (mode2) {
        case QRMode.MODE_NUMBER:
          return 14;
        case QRMode.MODE_ALPHA_NUM:
          return 13;
        case QRMode.MODE_8BIT_BYTE:
          return 16;
        case QRMode.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + mode2);
      }
    } else {
      throw new Error("type:" + type2);
    }
  },
  getLostPoint: function(qrCode) {
    var moduleCount = qrCode.getModuleCount();
    var lostPoint = 0;
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount; col++) {
        var sameCount = 0;
        var dark = qrCode.isDark(row, col);
        for (var r2 = -1; r2 <= 1; r2++) {
          if (row + r2 < 0 || moduleCount <= row + r2) {
            continue;
          }
          for (var c2 = -1; c2 <= 1; c2++) {
            if (col + c2 < 0 || moduleCount <= col + c2) {
              continue;
            }
            if (r2 == 0 && c2 == 0) {
              continue;
            }
            if (dark == qrCode.isDark(row + r2, col + c2)) {
              sameCount++;
            }
          }
        }
        if (sameCount > 5) {
          lostPoint += 3 + sameCount - 5;
        }
      }
    }
    for (var row = 0; row < moduleCount - 1; row++) {
      for (var col = 0; col < moduleCount - 1; col++) {
        var count2 = 0;
        if (qrCode.isDark(row, col))
          count2++;
        if (qrCode.isDark(row + 1, col))
          count2++;
        if (qrCode.isDark(row, col + 1))
          count2++;
        if (qrCode.isDark(row + 1, col + 1))
          count2++;
        if (count2 == 0 || count2 == 4) {
          lostPoint += 3;
        }
      }
    }
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount - 6; col++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
          lostPoint += 40;
        }
      }
    }
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount - 6; row++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
          lostPoint += 40;
        }
      }
    }
    var darkCount = 0;
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount; row++) {
        if (qrCode.isDark(row, col)) {
          darkCount++;
        }
      }
    }
    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
    lostPoint += ratio * 10;
    return lostPoint;
  }
};
var QRMath = {
  glog: function(n2) {
    if (n2 < 1) {
      throw new Error("glog(" + n2 + ")");
    }
    return QRMath.LOG_TABLE[n2];
  },
  gexp: function(n2) {
    while (n2 < 0) {
      n2 += 255;
    }
    while (n2 >= 256) {
      n2 -= 255;
    }
    return QRMath.EXP_TABLE[n2];
  },
  EXP_TABLE: new Array(256),
  LOG_TABLE: new Array(256)
};
for (var i = 0; i < 8; i++) {
  QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
  QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}
function QRPolynomial(num, shift) {
  if (num.length == void 0) {
    throw new Error(num.length + "/" + shift);
  }
  var offset = 0;
  while (offset < num.length && num[offset] == 0) {
    offset++;
  }
  this.num = new Array(num.length - offset + shift);
  for (var i = 0; i < num.length - offset; i++) {
    this.num[i] = num[i + offset];
  }
}
QRPolynomial.prototype = {
  get: function(index2) {
    return this.num[index2];
  },
  getLength: function() {
    return this.num.length;
  },
  multiply: function(e2) {
    var num = new Array(this.getLength() + e2.getLength() - 1);
    for (var i = 0; i < this.getLength(); i++) {
      for (var j2 = 0; j2 < e2.getLength(); j2++) {
        num[i + j2] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e2.get(j2)));
      }
    }
    return new QRPolynomial(num, 0);
  },
  mod: function(e2) {
    if (this.getLength() - e2.getLength() < 0) {
      return this;
    }
    var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e2.get(0));
    var num = new Array(this.getLength());
    for (var i = 0; i < this.getLength(); i++) {
      num[i] = this.get(i);
    }
    for (var i = 0; i < e2.getLength(); i++) {
      num[i] ^= QRMath.gexp(QRMath.glog(e2.get(i)) + ratio);
    }
    return new QRPolynomial(num, 0).mod(e2);
  }
};
function QRRSBlock(totalCount, dataCount) {
  this.totalCount = totalCount;
  this.dataCount = dataCount;
}
QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
  var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
  if (rsBlock == void 0) {
    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
  }
  var length = rsBlock.length / 3;
  var list = [];
  for (var i = 0; i < length; i++) {
    var count2 = rsBlock[i * 3 + 0];
    var totalCount = rsBlock[i * 3 + 1];
    var dataCount = rsBlock[i * 3 + 2];
    for (var j2 = 0; j2 < count2; j2++) {
      list.push(new QRRSBlock(totalCount, dataCount));
    }
  }
  return list;
};
QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
  switch (errorCorrectLevel) {
    case QRErrorCorrectLevel.L:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
    case QRErrorCorrectLevel.M:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
    case QRErrorCorrectLevel.Q:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
    case QRErrorCorrectLevel.H:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
    default:
      return void 0;
  }
};
function QRBitBuffer() {
  this.buffer = [];
  this.length = 0;
}
QRBitBuffer.prototype = {
  get: function(index2) {
    var bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) == 1;
  },
  put: function(num, length) {
    for (var i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) == 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
function QRCode$1(options) {
  this.options = {
    padding: 4,
    width: 256,
    height: 256,
    typeNumber: 4,
    color: "#000000",
    background: "#ffffff",
    ecl: "M",
    image: {
      svg: "",
      width: 0,
      height: 0
    }
  };
  if (typeof options === "string") {
    options = {
      content: options
    };
  }
  if (options) {
    for (var i in options) {
      this.options[i] = options[i];
    }
  }
  if (typeof this.options.content !== "string") {
    throw new Error("Expected 'content' as string!");
  }
  if (this.options.content.length === 0) {
    throw new Error("Expected 'content' to be non-empty!");
  }
  if (!(this.options.padding >= 0)) {
    throw new Error("Expected 'padding' value to be non-negative!");
  }
  if (!(this.options.width > 0) || !(this.options.height > 0)) {
    throw new Error("Expected 'width' or 'height' value to be higher than zero!");
  }
  function _getErrorCorrectLevel(ecl2) {
    switch (ecl2) {
      case "L":
        return QRErrorCorrectLevel.L;
      case "M":
        return QRErrorCorrectLevel.M;
      case "Q":
        return QRErrorCorrectLevel.Q;
      case "H":
        return QRErrorCorrectLevel.H;
      default:
        throw new Error("Unknwon error correction level: " + ecl2);
    }
  }
  function _getTypeNumber(content3, ecl2) {
    var length = _getUTF8Length(content3);
    var type3 = 1;
    var limit = 0;
    for (var i2 = 0, len = QRCodeLimitLength.length; i2 <= len; i2++) {
      var table = QRCodeLimitLength[i2];
      if (!table) {
        throw new Error("Content too long: expected " + limit + " but got " + length);
      }
      switch (ecl2) {
        case "L":
          limit = table[0];
          break;
        case "M":
          limit = table[1];
          break;
        case "Q":
          limit = table[2];
          break;
        case "H":
          limit = table[3];
          break;
        default:
          throw new Error("Unknwon error correction level: " + ecl2);
      }
      if (length <= limit) {
        break;
      }
      type3++;
    }
    if (type3 > QRCodeLimitLength.length) {
      throw new Error("Content too long");
    }
    return type3;
  }
  function _getUTF8Length(content3) {
    var result = encodeURI(content3).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
    return result.length + (result.length != content3 ? 3 : 0);
  }
  var content2 = this.options.content;
  var type2 = _getTypeNumber(content2, this.options.ecl);
  var ecl = _getErrorCorrectLevel(this.options.ecl);
  this.qrcode = new QRCodeModel(type2, ecl);
  this.qrcode.addData(content2);
  this.qrcode.make();
}
QRCode$1.prototype.svg = function(opt) {
  var options = this.options || {};
  var modules = this.qrcode.modules;
  if (typeof opt == "undefined") {
    opt = {
      container: options.container || "svg"
    };
  }
  var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
  var indent = pretty ? "  " : "";
  var EOL = pretty ? "\r\n" : "";
  var width = options.width;
  var height = options.height;
  var length = modules.length;
  var xsize = width / (length + 2 * options.padding);
  var ysize = height / (length + 2 * options.padding);
  var join = typeof options.join != "undefined" ? !!options.join : false;
  var swap = typeof options.swap != "undefined" ? !!options.swap : false;
  var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
  var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
  var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
  var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
  var modrect = "";
  var pathdata = "";
  for (var y2 = 0; y2 < length; y2++) {
    for (var x2 = 0; x2 < length; x2++) {
      var module2 = modules[x2][y2];
      if (module2) {
        var px = x2 * xsize + options.padding * xsize;
        var py = y2 * ysize + options.padding * ysize;
        if (swap) {
          var t2 = px;
          px = py;
          py = t2;
        }
        if (join) {
          var w2 = xsize + px;
          var h2 = ysize + py;
          px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
          py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
          w2 = Number.isInteger(w2) ? Number(w2) : w2.toFixed(2);
          h2 = Number.isInteger(h2) ? Number(h2) : h2.toFixed(2);
          pathdata += "M" + px + "," + py + " V" + h2 + " H" + w2 + " V" + py + " H" + px + " Z ";
        } else if (predefined) {
          modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
        } else {
          modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
        }
      }
    }
  }
  if (join) {
    modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
  }
  let imgSvg = "";
  if (this.options.image !== void 0 && this.options.image.svg) {
    const imgWidth = width * this.options.image.width / 100;
    const imgHeight = height * this.options.image.height / 100;
    const imgX = width / 2 - imgWidth / 2;
    const imgY = height / 2 - imgHeight / 2;
    imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
    imgSvg += this.options.image.svg + EOL;
    imgSvg += "</svg>";
  }
  var svg2 = "";
  switch (opt.container) {
    case "svg":
      if (xmlDeclaration) {
        svg2 += '<?xml version="1.0" standalone="yes"?>' + EOL;
      }
      svg2 += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
      svg2 += defs + bgrect + modrect;
      svg2 += imgSvg;
      svg2 += "</svg>";
      break;
    case "svg-viewbox":
      if (xmlDeclaration) {
        svg2 += '<?xml version="1.0" standalone="yes"?>' + EOL;
      }
      svg2 += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
      svg2 += defs + bgrect + modrect;
      svg2 += imgSvg;
      svg2 += "</svg>";
      break;
    case "g":
      svg2 += '<g width="' + width + '" height="' + height + '">' + EOL;
      svg2 += defs + bgrect + modrect;
      svg2 += imgSvg;
      svg2 += "</g>";
      break;
    default:
      svg2 += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
      break;
  }
  return svg2;
};
var qrcodeSvg = QRCode$1;
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(QRCode$2, "__esModule", {
  value: true
});
QRCode$2.QRCode = void 0;
const preact_1$8 = require$$1$1;
const hooks_1$3 = require$$2$1;
const qrcode_svg_1 = __importDefault$6(qrcodeSvg);
const QRCode = (props) => {
  const [svg2, setSvg] = (0, hooks_1$3.useState)("");
  (0, hooks_1$3.useEffect)(() => {
    var _a2, _b2;
    const qrcode2 = new qrcode_svg_1.default({
      content: props.content,
      background: props.bgColor || "#ffffff",
      color: props.fgColor || "#000000",
      container: "svg",
      ecl: "M",
      width: (_a2 = props.width) !== null && _a2 !== void 0 ? _a2 : 256,
      height: (_b2 = props.height) !== null && _b2 !== void 0 ? _b2 : 256,
      padding: 0,
      image: props.image
    });
    const base642 = Buffer.from(qrcode2.svg(), "utf8").toString("base64");
    setSvg(`data:image/svg+xml;base64,${base642}`);
  });
  return svg2 ? (0, preact_1$8.h)("img", {
    src: svg2,
    alt: "QR Code"
  }) : null;
};
QRCode$2.QRCode = QRCode;
var Spinner$1 = {};
var SpinnerCss = {};
Object.defineProperty(SpinnerCss, "__esModule", {
  value: true
});
SpinnerCss.default = `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(Spinner$1, "__esModule", {
  value: true
});
Spinner$1.Spinner = void 0;
const preact_1$7 = require$$1$1;
const Spinner_css_1 = __importDefault$5(SpinnerCss);
const Spinner = (props) => {
  var _a2;
  const size2 = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : 64;
  const color = props.color || "#000";
  return (0, preact_1$7.h)("div", {
    class: "-cbwsdk-spinner"
  }, (0, preact_1$7.h)("style", null, Spinner_css_1.default), (0, preact_1$7.h)("svg", {
    viewBox: "0 0 100 100",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      width: size2,
      height: size2
    }
  }, (0, preact_1$7.h)("circle", {
    style: {
      cx: 50,
      cy: 50,
      r: 45,
      stroke: color
    }
  })));
};
Spinner$1.Spinner = Spinner;
var ConnectContentCss = {};
Object.defineProperty(ConnectContentCss, "__esModule", {
  value: true
});
ConnectContentCss.default = `.-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-item.light.selected{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark.selected{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item.selected{border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}`;
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(ConnectContent$1, "__esModule", {
  value: true
});
ConnectContent$1.CoinbaseAppSteps = ConnectContent$1.CoinbaseWalletSteps = ConnectContent$1.ConnectItem = ConnectContent$1.ConnectContent = void 0;
const clsx_1$2 = __importDefault$4(require$$0);
const preact_1$6 = require$$1$1;
const hooks_1$2 = require$$2$1;
const util_1$4 = util$3;
const version_1 = version$1;
const CloseIcon_1 = CloseIcon$1;
const coinbase_round_svg_1 = __importDefault$4(coinbaseRoundSvg);
const coinbase_wallet_round_svg_1 = __importDefault$4(coinbaseWalletRoundSvg);
const QRCodeIcon_1 = QRCodeIcon$1;
const QRLogoCoinbase_1 = __importDefault$4(QRLogoCoinbase);
const QRLogoWallet_1 = __importDefault$4(QRLogoWallet);
const StatusDotIcon_1 = StatusDotIcon$1;
const QRCode_1 = QRCode$2;
const Spinner_1 = Spinner$1;
const ConnectContent_css_1 = __importDefault$4(ConnectContentCss);
const wallets = {
  "coinbase-wallet-app": {
    title: "Coinbase Wallet app",
    description: "Connect with your self-custody wallet",
    icon: coinbase_wallet_round_svg_1.default,
    steps: CoinbaseWalletSteps
  },
  "coinbase-app": {
    title: "Coinbase app",
    description: "Connect with your Coinbase account",
    icon: coinbase_round_svg_1.default,
    steps: CoinbaseAppSteps
  }
};
const makeQrCodeImage = (app) => {
  switch (app) {
    case "coinbase-app":
      return QRLogoCoinbase_1.default;
    case "coinbase-wallet-app":
    default:
      return QRLogoWallet_1.default;
  }
};
const makeIconColor = (theme) => {
  return theme === "light" ? "#FFFFFF" : "#0A0B0D";
};
function ConnectContent(props) {
  const {
    theme
  } = props;
  const [selected, setSelected] = (0, hooks_1$2.useState)("coinbase-wallet-app");
  const handleSelect = (0, hooks_1$2.useCallback)((id2) => {
    setSelected(id2);
  }, []);
  const qrUrl = (0, util_1$4.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection, props.version, props.chainId);
  const wallet = wallets[selected];
  if (!selected) {
    return null;
  }
  const WalletSteps = wallet.steps;
  const coinbaseApp = selected === "coinbase-app";
  return (0, preact_1$6.h)("div", {
    "data-testid": "connect-content",
    class: (0, clsx_1$2.default)("-cbwsdk-connect-content", theme)
  }, (0, preact_1$6.h)("style", null, ConnectContent_css_1.default), (0, preact_1$6.h)("div", {
    class: "-cbwsdk-connect-content-header"
  }, (0, preact_1$6.h)("h2", {
    class: (0, clsx_1$2.default)("-cbwsdk-connect-content-heading", theme)
  }, "Scan to connect with one of our mobile apps"), props.onCancel && (0, preact_1$6.h)("button", {
    type: "button",
    class: "-cbwsdk-cancel-button",
    onClick: props.onCancel
  }, (0, preact_1$6.h)(CloseIcon_1.CloseIcon, {
    fill: theme === "light" ? "#0A0B0D" : "#FFFFFF"
  }))), (0, preact_1$6.h)("div", {
    class: "-cbwsdk-connect-content-layout"
  }, (0, preact_1$6.h)("div", {
    class: "-cbwsdk-connect-content-column-left"
  }, (0, preact_1$6.h)("div", null, Object.entries(wallets).map(([key2, value]) => {
    return (0, preact_1$6.h)(ConnectItem, {
      key: key2,
      title: value.title,
      description: value.description,
      icon: value.icon,
      selected: selected === key2,
      onClick: () => handleSelect(key2),
      theme
    });
  })), coinbaseApp && (0, preact_1$6.h)("div", {
    class: (0, clsx_1$2.default)("-cbwsdk-connect-content-update-app", theme)
  }, "Don\u2019t see a ", (0, preact_1$6.h)("strong", null, "Scan"), " option? Update your Coinbase app to the latest version and try again.")), (0, preact_1$6.h)("div", {
    class: "-cbwsdk-connect-content-column-right"
  }, (0, preact_1$6.h)("div", {
    class: "-cbwsdk-connect-content-qr-wrapper"
  }, (0, preact_1$6.h)(QRCode_1.QRCode, {
    content: qrUrl,
    width: 200,
    height: 200,
    fgColor: "#000",
    bgColor: "transparent",
    image: {
      svg: makeQrCodeImage(selected),
      width: 25,
      height: 25
    }
  }), (0, preact_1$6.h)("input", {
    type: "hidden",
    name: "cbw-cbwsdk-version",
    value: version_1.LIB_VERSION
  }), (0, preact_1$6.h)("input", {
    type: "hidden",
    value: qrUrl
  })), (0, preact_1$6.h)(WalletSteps, {
    theme
  }), !props.isConnected && (0, preact_1$6.h)("div", {
    "data-testid": "connecting-spinner",
    class: (0, clsx_1$2.default)("-cbwsdk-connect-content-qr-connecting", theme)
  }, (0, preact_1$6.h)(Spinner_1.Spinner, {
    size: 36,
    color: theme === "dark" ? "#FFF" : "#000"
  }), (0, preact_1$6.h)("p", null, "Connecting...")))));
}
ConnectContent$1.ConnectContent = ConnectContent;
function ConnectItem({
  title,
  description: description2,
  icon,
  selected,
  theme,
  onClick
}) {
  return (0, preact_1$6.h)("div", {
    onClick,
    class: (0, clsx_1$2.default)("-cbwsdk-connect-item", theme, {
      selected
    })
  }, (0, preact_1$6.h)("div", null, (0, preact_1$6.h)("img", {
    src: icon,
    alt: title
  })), (0, preact_1$6.h)("div", {
    class: "-cbwsdk-connect-item-copy-wrapper"
  }, (0, preact_1$6.h)("h3", {
    class: "-cbwsdk-connect-item-title"
  }, title), (0, preact_1$6.h)("p", {
    class: "-cbwsdk-connect-item-description"
  }, description2)));
}
ConnectContent$1.ConnectItem = ConnectItem;
function CoinbaseWalletSteps({
  theme
}) {
  return (0, preact_1$6.h)("ol", {
    class: "-cbwsdk-wallet-steps"
  }, (0, preact_1$6.h)("li", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme)
  }, (0, preact_1$6.h)("div", {
    class: "-cbwsdk-wallet-steps-item-wrapper"
  }, "Open Coinbase Wallet app")), (0, preact_1$6.h)("li", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme)
  }, (0, preact_1$6.h)("div", {
    class: "-cbwsdk-wallet-steps-item-wrapper"
  }, (0, preact_1$6.h)("span", null, "Tap ", (0, preact_1$6.h)("strong", null, "Scan"), " "), (0, preact_1$6.h)("span", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme)
  }, (0, preact_1$6.h)(QRCodeIcon_1.QRCodeIcon, {
    fill: makeIconColor(theme)
  })))));
}
ConnectContent$1.CoinbaseWalletSteps = CoinbaseWalletSteps;
function CoinbaseAppSteps({
  theme
}) {
  return (0, preact_1$6.h)("ol", {
    class: "-cbwsdk-wallet-steps"
  }, (0, preact_1$6.h)("li", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme)
  }, (0, preact_1$6.h)("div", {
    class: "-cbwsdk-wallet-steps-item-wrapper"
  }, "Open Coinbase app")), (0, preact_1$6.h)("li", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-item", theme)
  }, (0, preact_1$6.h)("div", {
    class: "-cbwsdk-wallet-steps-item-wrapper"
  }, (0, preact_1$6.h)("span", null, "Tap ", (0, preact_1$6.h)("strong", null, "More")), (0, preact_1$6.h)("span", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme)
  }, (0, preact_1$6.h)(StatusDotIcon_1.StatusDotIcon, {
    fill: makeIconColor(theme)
  })), (0, preact_1$6.h)("span", {
    class: "-cbwsdk-wallet-steps-pad-left"
  }, "then ", (0, preact_1$6.h)("strong", null, "Scan")), (0, preact_1$6.h)("span", {
    class: (0, clsx_1$2.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme)
  }, (0, preact_1$6.h)(QRCodeIcon_1.QRCodeIcon, {
    fill: makeIconColor(theme)
  })))));
}
ConnectContent$1.CoinbaseAppSteps = CoinbaseAppSteps;
var TryExtensionContent$1 = {};
var ArrowLeftIcon$1 = {};
Object.defineProperty(ArrowLeftIcon$1, "__esModule", {
  value: true
});
ArrowLeftIcon$1.ArrowLeftIcon = void 0;
const preact_1$5 = require$$1$1;
function ArrowLeftIcon(props) {
  return (0, preact_1$5.h)("svg", Object.assign({
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), (0, preact_1$5.h)("path", {
    d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z"
  }));
}
ArrowLeftIcon$1.ArrowLeftIcon = ArrowLeftIcon;
var LaptopIcon$1 = {};
Object.defineProperty(LaptopIcon$1, "__esModule", {
  value: true
});
LaptopIcon$1.LaptopIcon = void 0;
const preact_1$4 = require$$1$1;
function LaptopIcon(props) {
  return (0, preact_1$4.h)("svg", Object.assign({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), (0, preact_1$4.h)("path", {
    d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z"
  }), (0, preact_1$4.h)("path", {
    d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z"
  }));
}
LaptopIcon$1.LaptopIcon = LaptopIcon;
var SafeIcon$1 = {};
Object.defineProperty(SafeIcon$1, "__esModule", {
  value: true
});
SafeIcon$1.SafeIcon = void 0;
const preact_1$3 = require$$1$1;
function SafeIcon(props) {
  return (0, preact_1$3.h)("svg", Object.assign({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), (0, preact_1$3.h)("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z"
  }));
}
SafeIcon$1.SafeIcon = SafeIcon;
var TryExtensionContentCss = {};
Object.defineProperty(TryExtensionContentCss, "__esModule", {
  value: true
});
TryExtensionContentCss.default = `.-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}`;
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(TryExtensionContent$1, "__esModule", {
  value: true
});
TryExtensionContent$1.TryExtensionContent = void 0;
const clsx_1$1 = __importDefault$3(require$$0);
const preact_1$2 = require$$1$1;
const hooks_1$1 = require$$2$1;
const ArrowLeftIcon_1 = ArrowLeftIcon$1;
const LaptopIcon_1 = LaptopIcon$1;
const SafeIcon_1 = SafeIcon$1;
const TryExtensionContent_css_1 = __importDefault$3(TryExtensionContentCss);
function TryExtensionContent({
  theme
}) {
  const [clicked, setClicked] = (0, hooks_1$1.useState)(false);
  const handleInstallClick = (0, hooks_1$1.useCallback)(() => {
    window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
  }, []);
  const handleClick = (0, hooks_1$1.useCallback)(() => {
    if (clicked) {
      window.location.reload();
    } else {
      handleInstallClick();
      setClicked(true);
    }
  }, [handleInstallClick, clicked]);
  return (0, preact_1$2.h)("div", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension", theme)
  }, (0, preact_1$2.h)("style", null, TryExtensionContent_css_1.default), (0, preact_1$2.h)("div", {
    class: "-cbwsdk-try-extension-column-half"
  }, (0, preact_1$2.h)("h3", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension-heading", theme)
  }, "Or try the Coinbase Wallet browser extension"), (0, preact_1$2.h)("div", {
    class: "-cbwsdk-try-extension-cta-wrapper"
  }, (0, preact_1$2.h)("button", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension-cta", theme),
    onClick: handleClick
  }, clicked ? "Refresh" : "Install"), (0, preact_1$2.h)("div", null, !clicked && (0, preact_1$2.h)(ArrowLeftIcon_1.ArrowLeftIcon, {
    class: "-cbwsdk-try-extension-cta-icon",
    fill: theme === "light" ? "#0052FF" : "#588AF5"
  })))), (0, preact_1$2.h)("div", {
    class: "-cbwsdk-try-extension-column-half"
  }, (0, preact_1$2.h)("ul", {
    class: "-cbwsdk-try-extension-list"
  }, (0, preact_1$2.h)("li", {
    class: "-cbwsdk-try-extension-list-item"
  }, (0, preact_1$2.h)("div", {
    class: "-cbwsdk-try-extension-list-item-icon-wrapper"
  }, (0, preact_1$2.h)("span", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-icon", theme)
  }, (0, preact_1$2.h)(LaptopIcon_1.LaptopIcon, {
    fill: theme === "light" ? "#0A0B0D" : "#FFFFFF"
  }))), (0, preact_1$2.h)("div", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-copy", theme)
  }, "Connect with dapps with just one click on your desktop browser")), (0, preact_1$2.h)("li", {
    class: "-cbwsdk-try-extension-list-item"
  }, (0, preact_1$2.h)("div", {
    class: "-cbwsdk-try-extension-list-item-icon-wrapper"
  }, (0, preact_1$2.h)("span", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-icon", theme)
  }, (0, preact_1$2.h)(SafeIcon_1.SafeIcon, {
    fill: theme === "light" ? "#0A0B0D" : "#FFFFFF"
  }))), (0, preact_1$2.h)("div", {
    class: (0, clsx_1$1.default)("-cbwsdk-try-extension-list-item-copy", theme)
  }, "Add an additional layer of security by using a supported Ledger hardware wallet")))));
}
TryExtensionContent$1.TryExtensionContent = TryExtensionContent;
var ConnectDialogCss = {};
Object.defineProperty(ConnectDialogCss, "__esModule", {
  value: true
});
ConnectDialogCss.default = `.-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}`;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(ConnectDialog$1, "__esModule", {
  value: true
});
ConnectDialog$1.ConnectDialog = void 0;
const clsx_1 = __importDefault$2(require$$0);
const preact_1$1 = require$$1$1;
const hooks_1 = require$$2$1;
const ConnectContent_1 = ConnectContent$1;
const TryExtensionContent_1 = TryExtensionContent$1;
const ConnectDialog_css_1 = __importDefault$2(ConnectDialogCss);
const ConnectDialog = (props) => {
  const {
    isOpen,
    darkMode
  } = props;
  const [containerHidden, setContainerHidden] = (0, hooks_1.useState)(!isOpen);
  const [dialogHidden, setDialogHidden] = (0, hooks_1.useState)(!isOpen);
  (0, hooks_1.useEffect)(() => {
    const timers = [window.setTimeout(() => {
      setDialogHidden(!isOpen);
    }, 10)];
    if (isOpen) {
      setContainerHidden(false);
    } else {
      timers.push(window.setTimeout(() => {
        setContainerHidden(true);
      }, 360));
    }
    return () => {
      timers.forEach(window.clearTimeout);
    };
  }, [props.isOpen]);
  const theme = darkMode ? "dark" : "light";
  return (0, preact_1$1.h)("div", {
    class: (0, clsx_1.default)("-cbwsdk-connect-dialog-container", containerHidden && "-cbwsdk-connect-dialog-container-hidden")
  }, (0, preact_1$1.h)("style", null, ConnectDialog_css_1.default), (0, preact_1$1.h)("div", {
    class: (0, clsx_1.default)("-cbwsdk-connect-dialog-backdrop", theme, dialogHidden && "-cbwsdk-connect-dialog-backdrop-hidden")
  }), (0, preact_1$1.h)("div", {
    class: "-cbwsdk-connect-dialog"
  }, (0, preact_1$1.h)("div", {
    class: (0, clsx_1.default)("-cbwsdk-connect-dialog-box", dialogHidden && "-cbwsdk-connect-dialog-box-hidden")
  }, !props.connectDisabled ? (0, preact_1$1.h)(ConnectContent_1.ConnectContent, {
    theme,
    version: props.version,
    sessionId: props.sessionId,
    sessionSecret: props.sessionSecret,
    linkAPIUrl: props.linkAPIUrl,
    isConnected: props.isConnected,
    isParentConnection: props.isParentConnection,
    chainId: props.chainId,
    onCancel: props.onCancel
  }) : null, (0, preact_1$1.h)(TryExtensionContent_1.TryExtensionContent, {
    theme
  }))));
};
ConnectDialog$1.ConnectDialog = ConnectDialog;
Object.defineProperty(LinkFlow$1, "__esModule", {
  value: true
});
LinkFlow$1.LinkFlow = void 0;
const preact_1 = require$$1$1;
const rxjs_1$2 = require$$1;
const ConnectDialog_1 = ConnectDialog$1;
class LinkFlow {
  constructor(options) {
    this.extensionUI$ = new rxjs_1$2.BehaviorSubject({});
    this.subscriptions = new rxjs_1$2.Subscription();
    this.isConnected = false;
    this.chainId = 1;
    this.isOpen = false;
    this.onCancel = null;
    this.root = null;
    this.connectDisabled = false;
    this.darkMode = options.darkMode;
    this.version = options.version;
    this.sessionId = options.sessionId;
    this.sessionSecret = options.sessionSecret;
    this.linkAPIUrl = options.linkAPIUrl;
    this.isParentConnection = options.isParentConnection;
    this.connected$ = options.connected$;
    this.chainId$ = options.chainId$;
  }
  attach(el) {
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-link-flow-root";
    el.appendChild(this.root);
    this.render();
    this.subscriptions.add(this.connected$.subscribe((v2) => {
      if (this.isConnected !== v2) {
        this.isConnected = v2;
        this.render();
      }
    }));
    this.subscriptions.add(this.chainId$.subscribe((chainId) => {
      if (this.chainId !== chainId) {
        this.chainId = chainId;
        this.render();
      }
    }));
  }
  detach() {
    var _a2;
    if (!this.root) {
      return;
    }
    this.subscriptions.unsubscribe();
    (0, preact_1.render)(null, this.root);
    (_a2 = this.root.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.root);
  }
  setConnectDisabled(connectDisabled) {
    this.connectDisabled = connectDisabled;
  }
  open(options) {
    this.isOpen = true;
    this.onCancel = options.onCancel;
    this.render();
  }
  close() {
    this.isOpen = false;
    this.onCancel = null;
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    const subscription = this.extensionUI$.subscribe(() => {
      if (!this.root) {
        return;
      }
      (0, preact_1.render)((0, preact_1.h)(ConnectDialog_1.ConnectDialog, {
        darkMode: this.darkMode,
        version: this.version,
        sessionId: this.sessionId,
        sessionSecret: this.sessionSecret,
        linkAPIUrl: this.linkAPIUrl,
        isOpen: this.isOpen,
        isConnected: this.isConnected,
        isParentConnection: this.isParentConnection,
        chainId: this.chainId,
        onCancel: this.onCancel,
        connectDisabled: this.connectDisabled
      }), this.root);
    });
    this.subscriptions.add(subscription);
  }
}
LinkFlow$1.LinkFlow = LinkFlow;
var Snackbar = {};
var SnackbarCss = {};
Object.defineProperty(SnackbarCss, "__esModule", {
  value: true
});
SnackbarCss.default = `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.SnackbarInstance = exports2.SnackbarContainer = exports2.Snackbar = void 0;
  const clsx_12 = __importDefault2(require$$0);
  const preact_12 = require$$1$1;
  const hooks_12 = require$$2$1;
  const Snackbar_css_1 = __importDefault2(SnackbarCss);
  const gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
  function makeSnackbarIcon(appSrc) {
    switch (appSrc) {
      case "coinbase-app":
        return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE0LjY3NCAxOC44NThjLTIuMDQ1IDAtMy42NDgtMS43MjItMy42NDgtMy44NDVzMS42NTktMy44NDUgMy42NDgtMy44NDVjMS44MjQgMCAzLjMxNyAxLjM3NyAzLjU5MyAzLjIxNGgzLjcwM2MtLjMzMS0zLjk2LTMuNDgyLTcuMDU5LTcuMjk2LTcuMDU5LTQuMDM0IDAtNy4zNSAzLjQ0My03LjM1IDcuNjkgMCA0LjI0NiAzLjI2IDcuNjkgNy4zNSA3LjY5IDMuODcgMCA2Ljk2NS0zLjEgNy4yOTYtNy4wNTloLTMuNzAzYy0uMjc2IDEuODM2LTEuNzY5IDMuMjE0LTMuNTkzIDMuMjE0WiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0wIDEwLjY3OGMwLTMuNzExIDAtNS41OTYuNzQyLTcuMDIzQTYuNTMyIDYuNTMyIDAgMCAxIDMuNjU1Ljc0MkM1LjA4MiAwIDYuOTY3IDAgMTAuNjc4IDBoNy45MzhjMy43MTEgMCA1LjU5NiAwIDcuMDIzLjc0MmE2LjUzMSA2LjUzMSAwIDAgMSAyLjkxMyAyLjkxM2MuNzQyIDEuNDI3Ljc0MiAzLjMxMi43NDIgNy4wMjN2Ny45MzhjMCAzLjcxMSAwIDUuNTk2LS43NDIgNy4wMjNhNi41MzEgNi41MzEgMCAwIDEtMi45MTMgMi45MTNjLTEuNDI3Ljc0Mi0zLjMxMi43NDItNy4wMjMuNzQyaC03LjkzOGMtMy43MTEgMC01LjU5NiAwLTcuMDIzLS43NDJhNi41MzEgNi41MzEgMCAwIDEtMi45MTMtMi45MTNDMCAyNC4yMTIgMCAyMi4zODQgMCAxOC42MTZ2LTcuOTM4WiIgZmlsbD0iIzAwNTJGRiIvPjxwYXRoIGQ9Ik0xNC42ODQgMTkuNzczYy0yLjcyNyAwLTQuODY0LTIuMjk1LTQuODY0LTUuMTI2IDAtMi44MzEgMi4yMS01LjEyNyA0Ljg2NC01LjEyNyAyLjQzMiAwIDQuNDIyIDEuODM3IDQuNzkgNC4yODVoNC45MzhjLS40NDItNS4yOC00LjY0My05LjQxMS05LjcyOC05LjQxMS01LjM4IDAtOS44MDIgNC41OS05LjgwMiAxMC4yNTMgMCA1LjY2MiA0LjM0OCAxMC4yNTMgOS44MDIgMTAuMjUzIDUuMTU5IDAgOS4yODYtNC4xMzIgOS43MjgtOS40MTFoLTQuOTM4Yy0uMzY4IDIuNDQ4LTIuMzU4IDQuMjg0LTQuNzkgNC4yODRaIiBmaWxsPSIjZmZmIi8+PC9zdmc+`;
      case "coinbase-wallet-app":
      default:
        return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    }
  }
  class Snackbar2 {
    constructor(options) {
      this.items = /* @__PURE__ */ new Map();
      this.nextItemKey = 0;
      this.root = null;
      this.darkMode = options.darkMode;
    }
    attach(el) {
      this.root = document.createElement("div");
      this.root.className = "-cbwsdk-snackbar-root";
      el.appendChild(this.root);
      this.render();
    }
    presentItem(itemProps) {
      const key2 = this.nextItemKey++;
      this.items.set(key2, itemProps);
      this.render();
      return () => {
        this.items.delete(key2);
        this.render();
      };
    }
    clear() {
      this.items.clear();
      this.render();
    }
    render() {
      if (!this.root) {
        return;
      }
      (0, preact_12.render)((0, preact_12.h)("div", null, (0, preact_12.h)(exports2.SnackbarContainer, {
        darkMode: this.darkMode
      }, Array.from(this.items.entries()).map(([key2, itemProps]) => (0, preact_12.h)(exports2.SnackbarInstance, Object.assign({}, itemProps, {
        key: key2
      }))))), this.root);
    }
  }
  exports2.Snackbar = Snackbar2;
  const SnackbarContainer = (props) => (0, preact_12.h)("div", {
    class: (0, clsx_12.default)("-cbwsdk-snackbar-container")
  }, (0, preact_12.h)("style", null, Snackbar_css_1.default), (0, preact_12.h)("div", {
    class: "-cbwsdk-snackbar"
  }, props.children));
  exports2.SnackbarContainer = SnackbarContainer;
  const SnackbarInstance = ({
    autoExpand,
    message,
    menuItems,
    appSrc
  }) => {
    const [hidden, setHidden] = (0, hooks_12.useState)(true);
    const [expanded, setExpanded] = (0, hooks_12.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
    (0, hooks_12.useEffect)(() => {
      const timers = [window.setTimeout(() => {
        setHidden(false);
      }, 1), window.setTimeout(() => {
        setExpanded(true);
      }, 1e4)];
      return () => {
        timers.forEach(window.clearTimeout);
      };
    });
    const toggleExpanded = () => {
      setExpanded(!expanded);
    };
    return (0, preact_12.h)("div", {
      class: (0, clsx_12.default)("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded")
    }, (0, preact_12.h)("div", {
      class: "-cbwsdk-snackbar-instance-header",
      onClick: toggleExpanded
    }, (0, preact_12.h)("img", {
      src: makeSnackbarIcon(appSrc),
      class: "-cbwsdk-snackbar-instance-header-cblogo"
    }), (0, preact_12.h)("div", {
      class: "-cbwsdk-snackbar-instance-header-message"
    }, message), (0, preact_12.h)("div", {
      class: "-gear-container"
    }, !expanded && (0, preact_12.h)("svg", {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, (0, preact_12.h)("circle", {
      cx: "12",
      cy: "12",
      r: "12",
      fill: "#F5F7F8"
    })), (0, preact_12.h)("img", {
      src: gearIcon,
      class: "-gear-icon",
      title: "Expand"
    }))), menuItems && menuItems.length > 0 && (0, preact_12.h)("div", {
      class: "-cbwsdk-snackbar-instance-menu"
    }, menuItems.map((action, i) => (0, preact_12.h)("div", {
      class: (0, clsx_12.default)("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"),
      onClick: action.onClick,
      key: i
    }, (0, preact_12.h)("svg", {
      width: action.svgWidth,
      height: action.svgHeight,
      viewBox: "0 0 10 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, (0, preact_12.h)("path", {
      "fill-rule": action.defaultFillRule,
      "clip-rule": action.defaultClipRule,
      d: action.path,
      fill: "#AAAAAA"
    })), (0, preact_12.h)("span", {
      class: (0, clsx_12.default)("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red")
    }, action.info)))));
  };
  exports2.SnackbarInstance = SnackbarInstance;
})(Snackbar);
var cssReset = {};
var cssResetCss = {};
Object.defineProperty(cssResetCss, "__esModule", {
  value: true
});
cssResetCss.default = `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(cssReset, "__esModule", {
  value: true
});
cssReset.injectCssReset = void 0;
const cssReset_css_1 = __importDefault$1(cssResetCss);
function injectCssReset() {
  const styleEl = document.createElement("style");
  styleEl.type = "text/css";
  styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
  document.documentElement.appendChild(styleEl);
}
cssReset.injectCssReset = injectCssReset;
Object.defineProperty(WalletSDKUI$1, "__esModule", {
  value: true
});
WalletSDKUI$1.WalletSDKUI = void 0;
const LinkFlow_1 = LinkFlow$1;
const Snackbar_1 = Snackbar;
const cssReset_1 = cssReset;
class WalletSDKUI {
  constructor(options) {
    this.standalone = null;
    this.attached = false;
    this.appSrc = null;
    this.snackbar = new Snackbar_1.Snackbar({
      darkMode: options.darkMode
    });
    this.linkFlow = new LinkFlow_1.LinkFlow({
      darkMode: options.darkMode,
      version: options.version,
      sessionId: options.session.id,
      sessionSecret: options.session.secret,
      linkAPIUrl: options.linkAPIUrl,
      connected$: options.connected$,
      chainId$: options.chainId$,
      isParentConnection: false
    });
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    const el = document.documentElement;
    const container = document.createElement("div");
    container.className = "-cbwsdk-css-reset";
    el.appendChild(container);
    this.linkFlow.attach(container);
    this.snackbar.attach(container);
    this.attached = true;
    (0, cssReset_1.injectCssReset)();
  }
  setConnectDisabled(connectDisabled) {
    this.linkFlow.setConnectDisabled(connectDisabled);
  }
  addEthereumChain(_options) {
  }
  watchAsset(_options) {
  }
  switchEthereumChain(_options) {
  }
  requestEthereumAccounts(options) {
    this.linkFlow.open({
      onCancel: options.onCancel
    });
  }
  hideRequestEthereumAccounts() {
    this.linkFlow.close();
  }
  signEthereumMessage(_2) {
  }
  signEthereumTransaction(_2) {
  }
  submitEthereumTransaction(_2) {
  }
  ethereumAddressFromSignedMessage(_2) {
  }
  showConnecting(options) {
    let snackbarProps;
    if (options.isUnlinkedErrorState) {
      snackbarProps = {
        autoExpand: true,
        message: "Connection lost",
        appSrc: this.appSrc,
        menuItems: [{
          isRed: false,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: options.onResetConnection
        }]
      };
    } else {
      snackbarProps = {
        message: "Confirm on phone",
        appSrc: this.appSrc,
        menuItems: [{
          isRed: true,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: options.onCancel
        }, {
          isRed: false,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: options.onResetConnection
        }]
      };
    }
    return this.snackbar.presentItem(snackbarProps);
  }
  setAppSrc(appSrc) {
    this.appSrc = appSrc;
  }
  reloadUI() {
    document.location.reload();
  }
  inlineAccountsResponse() {
    return false;
  }
  inlineAddEthereumChain(_chainId) {
    return false;
  }
  inlineWatchAsset() {
    return false;
  }
  inlineSwitchEthereumChain() {
    return false;
  }
  setStandalone(status) {
    this.standalone = status;
  }
  isStandalone() {
    var _a2;
    return (_a2 = this.standalone) !== null && _a2 !== void 0 ? _a2 : false;
  }
}
WalletSDKUI$1.WalletSDKUI = WalletSDKUI;
var WalletSDKRelay$1 = {};
var bindDecorator = {};
Object.defineProperty(bindDecorator, "__esModule", {
  value: true
});
var constants;
(function(constants2) {
  constants2.typeOfFunction = "function";
  constants2.boolTrue = true;
})(constants || (constants = {}));
function bind2(target, propertyKey, descriptor) {
  if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
    throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
  }
  return {
    configurable: constants.boolTrue,
    get: function() {
      var bound = descriptor.value.bind(this);
      Object.defineProperty(this, propertyKey, {
        value: bound,
        configurable: constants.boolTrue,
        writable: constants.boolTrue
      });
      return bound;
    }
  };
}
bindDecorator.bind = bind2;
bindDecorator.default = bind2;
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  AuditOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };
  return AuditOperator2;
}();
var AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  AuditSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
    if (!this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };
  AuditSubscriber2.prototype.clearThrottle = function() {
    var _a2 = this, value = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
    if (throttled) {
      this.remove(throttled);
      this.throttled = void 0;
      throttled.unsubscribe();
    }
    if (hasValue) {
      this.value = void 0;
      this.hasValue = false;
      this.destination.next(value);
    }
  };
  AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  };
  AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  };
  return AuditSubscriber2;
}(SimpleOuterSubscriber);
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  BufferOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };
  return BufferOperator2;
}();
var BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    _this.buffer = [];
    _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
    return _this;
  }
  BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [];
    this.destination.next(buffer2);
  };
  return BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;
    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }
  BufferCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };
  return BufferCountOperator2;
}();
var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }
  BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value);
    if (buffer2.length == this.bufferSize) {
      this.destination.next(buffer2);
      this.buffer = [];
    }
  };
  BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2.length > 0) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  return BufferCountSubscriber2;
}(Subscriber);
var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }
  BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
    this.count++;
    if (count2 % startBufferEvery === 0) {
      buffers.push([]);
    }
    for (var i = buffers.length; i--; ) {
      var buffer2 = buffers[i];
      buffer2.push(value);
      if (buffer2.length === bufferSize) {
        buffers.splice(i, 1);
        this.destination.next(buffer2);
      }
    }
  };
  BufferSkipCountSubscriber2.prototype._complete = function() {
    var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
    while (buffers.length > 0) {
      var buffer2 = buffers.shift();
      if (buffer2.length > 0) {
        destination.next(buffer2);
      }
    }
    _super.prototype._complete.call(this);
  };
  return BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler;
  }
  BufferTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };
  return BufferTimeOperator2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}();
var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler;
    _this.contexts = [];
    var context = _this.openContext();
    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
    if (_this.timespanOnly) {
      var timeSpanOnlyState = {
        subscriber: _this,
        context,
        bufferTimeSpan
      };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = {
        subscriber: _this,
        context
      };
      var creationState = {
        bufferTimeSpan,
        bufferCreationInterval,
        subscriber: _this,
        scheduler
      };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  BufferTimeSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    var filledBufferContext;
    for (var i = 0; i < len; i++) {
      var context_1 = contexts[i];
      var buffer2 = context_1.buffer;
      buffer2.push(value);
      if (buffer2.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }
    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };
  BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0;
    _super.prototype._error.call(this, err);
  };
  BufferTimeSubscriber2.prototype._complete = function() {
    var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  };
  BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  };
  BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
    this.closeContext(context);
    var closeAction = context.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);
    if (!this.closed && this.timespanOnly) {
      context = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = {
        subscriber: this,
        context,
        bufferTimeSpan
      };
      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };
  BufferTimeSubscriber2.prototype.openContext = function() {
    var context = new Context();
    this.contexts.push(context);
    return context;
  };
  BufferTimeSubscriber2.prototype.closeContext = function(context) {
    this.destination.next(context.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context) : -1;
    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context), 1);
    }
  };
  return BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state2) {
  var subscriber = state2.subscriber;
  var prevContext = state2.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state2.context = subscriber.openContext();
    state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state2) {
  var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
      subscriber,
      context
    }));
    action.schedule(state2, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  BufferToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return BufferToggleOperator2;
}();
var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(subscribeToResult(_this, openings));
    return _this;
  }
  BufferToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    for (var i = 0; i < len; i++) {
      contexts[i].buffer.push(value);
    }
  };
  BufferToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }
    this.contexts = null;
    _super.prototype._error.call(this, err);
  };
  BufferToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }
    this.contexts = null;
    _super.prototype._complete.call(this);
  };
  BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };
  BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  };
  BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value);
      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };
  BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
    var contexts = this.contexts;
    if (contexts && context) {
      var buffer2 = context.buffer, subscription = context.subscription;
      this.destination.next(buffer2);
      contexts.splice(contexts.indexOf(context), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };
  BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts;
    var buffer2 = [];
    var subscription = new Subscription();
    var context = {
      buffer: buffer2,
      subscription
    };
    contexts.push(context);
    var innerSubscription = subscribeToResult(this, closingNotifier, context);
    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context);
    } else {
      innerSubscription.context = context;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };
  return BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  BufferWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };
  return BufferWhenOperator2;
}();
var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.subscribing = false;
    _this.openBuffer();
    return _this;
  }
  BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0;
    this.subscribing = false;
  };
  BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  };
  BufferWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };
  BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }
    var buffer2 = this.buffer;
    if (this.buffer) {
      this.destination.next(buffer2);
    }
    this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
    this.subscribing = false;
  };
  return BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat$1.apply(void 0, [source].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  CountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };
  return CountOperator2;
}();
var CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }
  CountSubscriber2.prototype._next = function(value) {
    if (this.predicate) {
      this._tryPredicate(value);
    } else {
      this.count++;
    }
  };
  CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.count++;
    }
  };
  CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count);
    this.destination.complete();
  };
  return CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  DebounceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };
  return DebounceOperator2;
}();
var DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      if (result) {
        this._tryNext(value, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DebounceSubscriber2.prototype._complete = function() {
    this.emitValue();
    this.destination.complete();
  };
  DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value;
    this.hasValue = true;
    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }
    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };
  DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value;
      var subscription = this.durationSubscription;
      if (subscription) {
        this.durationSubscription = void 0;
        subscription.unsubscribe();
        this.remove(subscription);
      }
      this.value = void 0;
      this.hasValue = false;
      _super.prototype._next.call(this, value);
    }
  };
  return DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  DebounceTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };
  return DebounceTimeOperator2;
}();
var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.dueTime = dueTime;
    _this.scheduler = scheduler;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }
  DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  };
  DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext();
    this.destination.complete();
  };
  DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    this.clearDebounce();
    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };
  DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };
  return DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = false;
    this.destination.next(value);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler) {
    this.delay = delay2;
    this.scheduler = scheduler;
  }
  DelayOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };
  return DelayOperator2;
}();
var DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.delay = delay2;
    _this.scheduler = scheduler;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }
  DelaySubscriber2.dispatch = function(state2) {
    var source = state2.source;
    var queue2 = source.queue;
    var scheduler = state2.scheduler;
    var destination = state2.destination;
    while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
      queue2.shift().notification.observe(destination);
    }
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
      this.schedule(state2, delay_1);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  };
  DelaySubscriber2.prototype._schedule = function(scheduler) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler
    }));
  };
  DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored === true) {
      return;
    }
    var scheduler = this.scheduler;
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler);
    }
  };
  DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  };
  DelaySubscriber2.prototype._error = function(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };
  DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete());
    this.unsubscribe();
  };
  return DelaySubscriber2;
}(Subscriber);
var DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time2, notification) {
    this.time = time2;
    this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  DelayWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };
  return DelayWhenOperator2;
}();
var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }
  DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
    this._error(error);
  };
  DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    if (value) {
      this.destination.next(value);
    }
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index2);
      if (delayNotifier) {
        this.tryDelay(delayNotifier, value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };
  DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }
    return subscription.outerValue;
  };
  DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };
  DelayWhenSubscriber2.prototype.tryComplete = function() {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };
  return DelayWhenSubscriber2;
}(OuterSubscriber);
var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source, subscriptionDelay) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }
  SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };
  return SubscriptionDelayObservable2;
}(Observable);
var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent, source) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.source = source;
    _this.sourceSubscribed = false;
    return _this;
  }
  SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe();
    this.parent.error(err);
  };
  SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe();
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };
  return SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  DeMaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DeMaterializeSubscriber(subscriber));
  };
  return DeMaterializeOperator2;
}();
var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  };
  return DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }
  DistinctOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };
  return DistinctOperator2;
}();
var DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.values = /* @__PURE__ */ new Set();
    if (flushes) {
      _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
    }
    return _this;
  }
  DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  };
  DistinctSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  DistinctSubscriber2.prototype._next = function(value) {
    if (this.keySelector) {
      this._useKeySelector(value);
    } else {
      this._finalizeNext(value, value);
    }
  };
  DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key2;
    var destination = this.destination;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key2, value);
  };
  DistinctSubscriber2.prototype._finalizeNext = function(key2, value) {
    var values = this.values;
    if (!values.has(key2)) {
      values.add(key2);
      this.destination.next(value);
    }
  };
  return DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare2, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare2, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare2, keySelector) {
    this.compare = compare2;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare2 === "function") {
      _this.compare = compare2;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x2, y2) {
    return x2 === y2;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key2;
    try {
      var keySelector = this.keySelector;
      key2 = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare2 = this.compare;
        result = compare2(this.key, key2);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key2;
      this.destination.next(value);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key2, compare2) {
  return distinctUntilChanged(function(x2, y2) {
    return compare2 ? compare2(x2[key2], y2[key2]) : x2[key2] === y2[key2];
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = true;
    this.destination.next(value);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e2) {
        err = e2;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count2 = ++this.count;
    if (count2 <= total) {
      this.destination.next(value);
      if (count2 === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function elementAt(index2, defaultValue) {
  if (index2 < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v2, i) {
      return i === index2;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  return function(source) {
    return concat$1(source, of.apply(void 0, array2));
  };
}
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source;
  }
  EveryOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };
  return EveryOperator2;
}();
var EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };
  EverySubscriber2.prototype._next = function(value) {
    var result = false;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (!result) {
      this.notifyComplete(false);
    }
  };
  EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  SwitchFirstOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchFirstSubscriber(subscriber));
  };
  return SwitchFirstOperator2;
}();
var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }
  SwitchFirstSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
    }
  };
  SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };
  SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a2, i) {
        return from(project(a2, i)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  ExhaustMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };
  return ExhaustMapOperator2;
}();
var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }
  ExhaustMapSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };
  ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = true;
    this._innerSub(result);
  };
  ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
  }
  ExpandOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };
  return ExpandOperator2;
}();
var ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;
    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }
    return _this;
  }
  ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index2 = arg.index;
    subscriber.subscribeToProjection(result, value, index2);
  };
  ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index2 = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project;
        var result = project(value, index2);
        if (!this.scheduler) {
          this.subscribeToProjection(result, value, index2);
        } else {
          var state2 = {
            subscriber: this,
            result,
            value,
            index: index2
          };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
        }
      } catch (e2) {
        destination.error(e2);
      }
    } else {
      this.buffer.push(value);
    }
  };
  ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index2) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  };
  ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  };
  ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2 && buffer2.length > 0) {
      this._next(buffer2.shift());
    }
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };
  return ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  FinallyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FinallySubscriber(subscriber, this.callback));
  };
  return FinallyOperator2;
}();
var FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    _this.add(new Subscription(callback));
    return _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }
  FindValueOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };
  return FindValueOperator2;
}();
var FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }
  FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
    this.unsubscribe();
  };
  FindValueSubscriber2.prototype._next = function(value) {
    var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
    var index2 = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index2, this.source);
      if (result) {
        this.notifyComplete(this.yieldIndex ? index2 : value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  };
  return FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v2, i) {
      return predicate(v2, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  };
  return IgnoreElementsOperator2;
}();
var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IgnoreElementsSubscriber2.prototype._next = function(unused) {
  };
  return IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  IsEmptyOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new IsEmptySubscriber(observer));
  };
  return IsEmptyOperator2;
}();
var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2);
    destination.complete();
  };
  IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(false);
  };
  IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeLastOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };
  return TakeLastOperator2;
}();
var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }
  TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring;
    var total = this.total;
    var count2 = this.count++;
    if (ring.length < total) {
      ring.push(value);
    } else {
      var index2 = count2 % total;
      ring[index2] = value;
    }
  };
  TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    var count2 = this.count;
    if (count2 > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;
      for (var i = 0; i < total; i++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  };
  return TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v2, i) {
      return predicate(v2, i, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  MapToOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  };
  return MapToOperator2;
}();
var MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    _this.value = value;
    return _this;
  }
  MapToSubscriber2.prototype._next = function(x2) {
    this.destination.next(this.value);
  };
  return MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  MaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MaterializeSubscriber(subscriber));
  };
  return MaterializeOperator2;
}();
var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  };
  MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err));
    destination.complete();
  };
  MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete());
    destination.complete();
  };
  return MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  ScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };
  return ScanOperator2;
}();
var ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }
  Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value) {
      this.hasSeed = true;
      this._seed = value;
    },
    enumerable: true,
    configurable: true
  });
  ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };
  ScanSubscriber2.prototype._tryNext = function(value) {
    var index2 = this.index++;
    var result;
    try {
      result = this.accumulator(this.seed, value, index2);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  };
  return ScanSubscriber2;
}(Subscriber);
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value, index2) {
      return accumulator(acc, value, index2 + 1);
    }), takeLast(1))(source);
  };
}
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x2, y2) {
    return comparer(x2, y2) > 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 > y2 ? x2 : y2;
  };
  return reduce(max2);
}
function merge2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge$1.apply(void 0, [source].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }
  MergeScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };
  return MergeScanOperator2;
}();
var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index2 = this.index++;
      var destination = this.destination;
      var ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index2);
      } catch (e2) {
        return destination.error(e2);
      }
      this.active++;
      this._innerSub(ish);
    } else {
      this.buffer.push(value);
    }
  };
  MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };
  MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
  };
  return MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x2, y2) {
    return comparer(x2, y2) < 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 < y2 ? x2 : y2;
  };
  return reduce(min2);
}
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function onErrorResumeNext() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };
  return OnErrorResumeNextOperator2;
}();
var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }
  OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (!!next) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    } else {
      this.destination.complete();
    }
  };
  return OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  PairwiseOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  };
  return PairwiseOperator2;
}();
var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasPrev = false;
    return _this;
  }
  PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  };
  return PairwiseSubscriber2;
}(Subscriber);
function partition(predicate, thisArg) {
  return function(source) {
    return [filter(predicate, thisArg)(source), filter(not(predicate, thisArg))(source)];
  };
}
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x2) {
    var currentProp = x2;
    for (var i = 0; i < length; i++) {
      var p2 = currentProp != null ? currentProp[props[i]] : void 0;
      if (p2 !== void 0) {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race$1.apply(void 0, [source].concat(observables)));
  };
}
function repeat2(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RepeatOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };
  return RepeatOperator2;
}();
var RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.complete.call(this);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  RepeatWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  };
  return RepeatWhenOperator2;
}();
var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }
  RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };
  RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };
  RepeatWhenSubscriber2.prototype.complete = function() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(void 0);
    }
  };
  RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    _super.prototype._unsubscribeAndRecycle.call(this);
    this._unsubscribe = _unsubscribe;
    return this;
  };
  RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e2) {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries;
    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  };
  return RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RetryOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source) {
    this.notifier = notifier;
    this.source = source;
  }
  RetryWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };
  return RetryWhenOperator2;
}();
var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    return _this;
  }
  RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors2 = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;
      if (!retries) {
        errors2 = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors2);
        } catch (e2) {
          return _super.prototype.error.call(this, e2);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      } else {
        this.errors = void 0;
        this.retriesSubscription = void 0;
      }
      this._unsubscribeAndRecycle();
      this.errors = errors2;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors2.next(err);
    }
  };
  RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, errors2 = _a2.errors, retriesSubscription = _a2.retriesSubscription;
    if (errors2) {
      errors2.unsubscribe();
      this.errors = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    this._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };
  return RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  SampleOperator2.prototype.call = function(subscriber, source) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source.subscribe(sampleSubscriber);
    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
    return subscription;
  };
  return SampleOperator2;
}();
var SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasValue = false;
    return _this;
  }
  SampleSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
  };
  SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };
  return SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler) {
    this.period = period;
    this.scheduler = scheduler;
  }
  SampleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };
  return SampleTimeOperator2;
}();
var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.period = period;
    _this.scheduler = scheduler;
    _this.hasValue = false;
    _this.add(scheduler.schedule(dispatchNotification, period, {
      subscriber: _this,
      period
    }));
    return _this;
  }
  SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value;
    this.hasValue = true;
  };
  SampleTimeSubscriber2.prototype.notifyNext = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };
  return SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state2) {
  var subscriber = state2.subscriber, period = state2.period;
  subscriber.notifyNext();
  this.schedule(state2, period);
}
function sequenceEqual(compareTo, comparator2) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator2));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator2) {
    this.compareTo = compareTo;
    this.comparator = comparator2;
  }
  SequenceEqualOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };
  return SequenceEqualOperator2;
}();
var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator2) {
    var _this = _super.call(this, destination) || this;
    _this.compareTo = compareTo;
    _this.comparator = comparator2;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;
    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
    return _this;
  }
  SequenceEqualSubscriber2.prototype._next = function(value) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype._complete = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
    this.unsubscribe();
  };
  SequenceEqualSubscriber2.prototype.checkValues = function() {
    var _c2 = this, _a2 = _c2._a, _b2 = _c2._b, comparator2 = _c2.comparator;
    while (_a2.length > 0 && _b2.length > 0) {
      var a2 = _a2.shift();
      var b2 = _b2.shift();
      var areEqual = false;
      try {
        areEqual = comparator2 ? comparator2(a2, b2) : a2 === b2;
      } catch (e2) {
        this.destination.error(e2);
      }
      if (!areEqual) {
        this.emit(false);
      }
    }
  };
  SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
  };
  SequenceEqualSubscriber2.prototype.nextB = function(value) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype.completeB = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };
  return SequenceEqualSubscriber2;
}(Subscriber);
var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    return _this;
  }
  SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  };
  SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err);
    this.unsubscribe();
  };
  SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB();
    this.unsubscribe();
  };
  return SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b2 = _a2.bufferSize, bufferSize = _b2 === void 0 ? Number.POSITIVE_INFINITY : _b2, _c2 = _a2.windowTime, windowTime2 = _c2 === void 0 ? Number.POSITIVE_INFINITY : _c2, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  SingleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };
  return SingleOperator2;
}();
var SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }
  SingleSubscriber2.prototype.applySingleValue = function(value) {
    if (this.seenValue) {
      this.destination.error("Sequence contains more than one element");
    } else {
      this.seenValue = true;
      this.singleValue = value;
    }
  };
  SingleSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    if (this.predicate) {
      this.tryNext(value, index2);
    } else {
      this.applySingleValue(value);
    }
  };
  SingleSubscriber2.prototype.tryNext = function(value, index2) {
    try {
      if (this.predicate(value, index2, this.source)) {
        this.applySingleValue(value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : void 0);
      destination.complete();
    } else {
      destination.error(new EmptyError());
    }
  };
  return SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  SkipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  };
  return SkipOperator2;
}();
var SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  SkipSubscriber2.prototype._next = function(x2) {
    if (++this.count > this.total) {
      this.destination.next(x2);
    }
  };
  return SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    this._skipCount = _skipCount;
    if (this._skipCount < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  SkipLastOperator2.prototype.call = function(subscriber, source) {
    if (this._skipCount === 0) {
      return source.subscribe(new Subscriber(subscriber));
    } else {
      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };
  return SkipLastOperator2;
}();
var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }
  SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount;
    var count2 = this._count++;
    if (count2 < skipCount) {
      this._ring[count2] = value;
    } else {
      var currentIndex = count2 % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value;
      this.destination.next(oldValue);
    }
  };
  return SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  SkipUntilOperator2.prototype.call = function(destination, source) {
    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };
  return SkipUntilOperator2;
}();
var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = false;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber);
    _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      _this.add(innerSubscription);
      _this.innerSubscription = innerSubscription;
    }
    return _this;
  }
  SkipUntilSubscriber2.prototype._next = function(value) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value);
    }
  };
  SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = true;
    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };
  SkipUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  SkipWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };
  return SkipWhileOperator2;
}();
var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }
  SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value);
    }
    if (!this.skipping) {
      destination.next(value);
    }
  };
  SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };
  return SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  var scheduler = array2[array2.length - 1];
  if (isScheduler(scheduler)) {
    array2.pop();
    return function(source) {
      return concat$1(array2, source, scheduler);
    };
  } else {
    return function(source) {
      return concat$1(array2, source);
    };
  }
}
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source, delayTime, scheduler) {
    if (delayTime === void 0) {
      delayTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler;
    if (!isNumeric(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== "function") {
      _this.scheduler = asap;
    }
    return _this;
  }
  SubscribeOnObservable2.create = function(source, delay2, scheduler) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    return new SubscribeOnObservable2(source, delay2, scheduler);
  };
  SubscribeOnObservable2.dispatch = function(arg) {
    var source = arg.source, subscriber = arg.subscriber;
    return this.add(source.subscribe(subscriber));
  };
  SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime;
    var source = this.source;
    var scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source,
      subscriber
    });
  };
  return SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler, delay2) {
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  SubscribeOnOperator2.prototype.call = function(subscriber, source) {
    return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
  };
  return SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a2, i) {
        return from(project(a2, i)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop;
    _this._tapError = noop;
    _this._tapComplete = noop;
    _this._tapError = error || noop;
    _this._tapComplete = complete || noop;
    if (isFunction(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop;
      _this._tapError = observerOrNext.error || noop;
      _this._tapComplete = observerOrNext.complete || noop;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };
  return ThrottleOperator2;
}();
var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }
  ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = true;
    this._sendValue = value;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };
  ThrottleSubscriber2.prototype.send = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = void 0;
  };
  ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  };
  ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };
  ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = void 0;
    if (_trailing) {
      this.send();
    }
  };
  ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  };
  ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  };
  return ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };
  return ThrottleTimeOperator2;
}();
var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    _this.duration = duration;
    _this.scheduler = scheduler;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }
  ThrottleTimeSubscriber2.prototype._next = function(value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
        subscriber: this
      }));
      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };
  ThrottleTimeSubscriber2.prototype._complete = function() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };
  ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };
  return ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a2, value) {
        var current = _a2.current;
        return {
          value,
          current: scheduler.now(),
          last: current
        };
      }, {
        current: scheduler.now(),
        value: void 0,
        last: void 0
      }), map(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value = _a2.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value;
    this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr2, item, index2) {
  if (index2 === 0) {
    return [item];
  }
  arr2.push(item);
  return arr2;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    var windowSubscriber = new WindowSubscriber$1(subscriber);
    var sourceSubscription = source.subscribe(windowSubscriber);
    if (!sourceSubscription.closed) {
      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
    }
    return sourceSubscription;
  };
  return WindowOperator2;
}();
var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.window = new Subject();
    destination.next(_this.window);
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
  };
  WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  };
  WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var destination = this.destination;
    var newWindow = this.window = new Subject();
    destination.next(newWindow);
  };
  return WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }
  WindowCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };
  return WindowCountOperator2;
}();
var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }
  WindowCountSubscriber2.prototype._next = function(value) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len = windows.length;
    for (var i = 0; i < len && !this.closed; i++) {
      windows[i].next(value);
    }
    var c2 = this.count - windowSize + 1;
    if (c2 >= 0 && c2 % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }
    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };
  WindowCountSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }
    this.destination.error(err);
  };
  WindowCountSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }
    this.destination.complete();
  };
  WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0;
    this.windows = null;
  };
  return WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler;
  }
  WindowTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };
  return WindowTimeOperator2;
}();
var CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._numberOfNextedValues = 0;
    return _this;
  }
  CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++;
    _super.prototype.next.call(this, value);
  };
  Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: true,
    configurable: true
  });
  return CountedSubject2;
}(Subject);
var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler;
    _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = {
        subscriber: _this,
        window: window2,
        context: null
      };
      var creationState = {
        windowTimeSpan,
        windowCreationInterval,
        subscriber: _this,
        scheduler
      };
      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = {
        subscriber: _this,
        window: window2,
        windowTimeSpan
      };
      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  WindowTimeSubscriber2.prototype._next = function(value) {
    var windows = this.windows;
    var len = windows.length;
    for (var i = 0; i < len; i++) {
      var window_1 = windows[i];
      if (!window_1.closed) {
        window_1.next(value);
        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };
  WindowTimeSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    while (windows.length > 0) {
      windows.shift().error(err);
    }
    this.destination.error(err);
  };
  WindowTimeSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    while (windows.length > 0) {
      var window_2 = windows.shift();
      if (!window_2.closed) {
        window_2.complete();
      }
    }
    this.destination.complete();
  };
  WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    destination.next(window2);
    return window2;
  };
  WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window2), 1);
  };
  return WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
  if (window2) {
    subscriber.closeWindow(window2);
  }
  state2.window = subscriber.openWindow();
  this.schedule(state2, windowTimeSpan);
}
function dispatchWindowCreation(state2) {
  var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler, windowCreationInterval = state2.windowCreationInterval;
  var window2 = subscriber.openWindow();
  var action = this;
  var context = {
    action,
    subscription: null
  };
  var timeSpanState = {
    subscriber,
    window: window2,
    context
  };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state2, windowCreationInterval);
}
function dispatchWindowClose(state2) {
  var subscriber = state2.subscriber, window2 = state2.window, context = state2.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  WindowToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return WindowToggleOperator2;
}();
var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
    return _this;
  }
  WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts) {
      var len = contexts.length;
      for (var i = 0; i < len; i++) {
        contexts[i].window.next(value);
      }
    }
  };
  WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_1 = contexts[index2];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }
    _super.prototype._error.call(this, err);
  };
  WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_2 = contexts[index2];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }
    _super.prototype._complete.call(this);
  };
  WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_3 = contexts[index2];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };
  WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e2) {
        return this.error(e2);
      }
      var window_1 = new Subject();
      var subscription = new Subscription();
      var context_4 = {
        window: window_1,
        subscription
      };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }
      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };
  WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  };
  WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };
  WindowToggleSubscriber2.prototype.closeWindow = function(index2) {
    if (index2 === -1) {
      return;
    }
    var contexts = this.contexts;
    var context = contexts[index2];
    var window2 = context.window, subscription = context.subscription;
    contexts.splice(index2, 1);
    window2.complete();
    subscription.unsubscribe();
  };
  return WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };
  return WindowOperator2;
}();
var WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.closingSelector = closingSelector;
    _this.openWindow();
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };
  WindowSubscriber2.prototype.openWindow = function(innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }
    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e2) {
      this.destination.error(e2);
      this.window.error(e2);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  };
  return WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  WithLatestFromOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };
  return WithLatestFromOperator2;
}();
var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);
    for (var i = 0; i < len; i++) {
      _this.toRespond.push(i);
    }
    for (var i = 0; i < len; i++) {
      var observable2 = observables[i];
      _this.add(subscribeToResult(_this, observable2, void 0, i));
    }
    return _this;
  }
  WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };
  WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  };
  WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };
  WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip$1.apply(void 0, [source].concat(observables)));
  };
}
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge: merge2,
  mergeAll,
  mergeMap,
  flatMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  repeat: repeat2,
  repeatWhen,
  retry,
  retryWhen,
  refCount,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(operators);
var WalletSDKConnection$1 = {};
var ClientMessage = {};
Object.defineProperty(ClientMessage, "__esModule", {
  value: true
});
ClientMessage.ClientMessagePublishEvent = ClientMessage.ClientMessageSetSessionConfig = ClientMessage.ClientMessageGetSessionConfig = ClientMessage.ClientMessageIsLinked = ClientMessage.ClientMessageHostSession = void 0;
function ClientMessageHostSession(params) {
  return Object.assign({
    type: "HostSession"
  }, params);
}
ClientMessage.ClientMessageHostSession = ClientMessageHostSession;
function ClientMessageIsLinked(params) {
  return Object.assign({
    type: "IsLinked"
  }, params);
}
ClientMessage.ClientMessageIsLinked = ClientMessageIsLinked;
function ClientMessageGetSessionConfig(params) {
  return Object.assign({
    type: "GetSessionConfig"
  }, params);
}
ClientMessage.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
function ClientMessageSetSessionConfig(params) {
  return Object.assign({
    type: "SetSessionConfig"
  }, params);
}
ClientMessage.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
function ClientMessagePublishEvent(params) {
  return Object.assign({
    type: "PublishEvent"
  }, params);
}
ClientMessage.ClientMessagePublishEvent = ClientMessagePublishEvent;
var RxWebSocket = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.RxWebSocket = exports2.ConnectionState = void 0;
  const rxjs_12 = require$$1;
  const operators_12 = require$$2;
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
    ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
    ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
  })(ConnectionState = exports2.ConnectionState || (exports2.ConnectionState = {}));
  class RxWebSocket2 {
    constructor(url, WebSocketClass = WebSocket) {
      this.WebSocketClass = WebSocketClass;
      this.webSocket = null;
      this.connectionStateSubject = new rxjs_12.BehaviorSubject(ConnectionState.DISCONNECTED);
      this.incomingDataSubject = new rxjs_12.Subject();
      this.url = url.replace(/^http/, "ws");
    }
    connect() {
      if (this.webSocket) {
        return (0, rxjs_12.throwError)(new Error("webSocket object is not null"));
      }
      return new rxjs_12.Observable((obs) => {
        let webSocket;
        try {
          this.webSocket = webSocket = new this.WebSocketClass(this.url);
        } catch (err) {
          obs.error(err);
          return;
        }
        this.connectionStateSubject.next(ConnectionState.CONNECTING);
        webSocket.onclose = (evt) => {
          this.clearWebSocket();
          obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
          this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        };
        webSocket.onopen = (_2) => {
          obs.next();
          obs.complete();
          this.connectionStateSubject.next(ConnectionState.CONNECTED);
        };
        webSocket.onmessage = (evt) => {
          this.incomingDataSubject.next(evt.data);
        };
      }).pipe((0, operators_12.take)(1));
    }
    disconnect() {
      const {
        webSocket
      } = this;
      if (!webSocket) {
        return;
      }
      this.clearWebSocket();
      this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
      try {
        webSocket.close();
      } catch (_a2) {
      }
    }
    get connectionState$() {
      return this.connectionStateSubject.asObservable();
    }
    get incomingData$() {
      return this.incomingDataSubject.asObservable();
    }
    get incomingJSONData$() {
      return this.incomingData$.pipe((0, operators_12.flatMap)((m2) => {
        let j2;
        try {
          j2 = JSON.parse(m2);
        } catch (err) {
          return (0, rxjs_12.empty)();
        }
        return (0, rxjs_12.of)(j2);
      }));
    }
    sendData(data) {
      const {
        webSocket
      } = this;
      if (!webSocket) {
        throw new Error("websocket is not connected");
      }
      webSocket.send(data);
    }
    clearWebSocket() {
      const {
        webSocket
      } = this;
      if (!webSocket) {
        return;
      }
      this.webSocket = null;
      webSocket.onclose = null;
      webSocket.onerror = null;
      webSocket.onmessage = null;
      webSocket.onopen = null;
    }
  }
  exports2.RxWebSocket = RxWebSocket2;
})(RxWebSocket);
var ServerMessage = {};
Object.defineProperty(ServerMessage, "__esModule", {
  value: true
});
ServerMessage.isServerMessageFail = void 0;
function isServerMessageFail(msg) {
  return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
}
ServerMessage.isServerMessageFail = isServerMessageFail;
Object.defineProperty(WalletSDKConnection$1, "__esModule", {
  value: true
});
WalletSDKConnection$1.WalletSDKConnection = void 0;
const rxjs_1$1 = require$$1;
const operators_1$1 = require$$2;
const Session_1$1 = Session$1;
const types_1$1 = types$2;
const ClientMessage_1 = ClientMessage;
const DiagnosticLogger_1$1 = DiagnosticLogger;
const RxWebSocket_1 = RxWebSocket;
const ServerMessage_1 = ServerMessage;
const HEARTBEAT_INTERVAL = 1e4;
const REQUEST_TIMEOUT = 6e4;
class WalletSDKConnection {
  constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {
    this.sessionId = sessionId;
    this.sessionKey = sessionKey;
    this.diagnostic = diagnostic;
    this.subscriptions = new rxjs_1$1.Subscription();
    this.destroyed = false;
    this.lastHeartbeatResponse = 0;
    this.nextReqId = (0, types_1$1.IntNumber)(1);
    this.connectedSubject = new rxjs_1$1.BehaviorSubject(false);
    this.linkedSubject = new rxjs_1$1.BehaviorSubject(false);
    this.sessionConfigSubject = new rxjs_1$1.ReplaySubject(1);
    const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + "/rpc", WebSocketClass);
    this.ws = ws;
    this.subscriptions.add(ws.connectionState$.pipe(
      (0, operators_1$1.tap)((state2) => {
        var _a2;
        return (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.CONNECTED_STATE_CHANGE, {
          state: state2,
          sessionIdHash: Session_1$1.Session.hash(sessionId)
        });
      }),
      (0, operators_1$1.skip)(1),
      (0, operators_1$1.filter)((cs) => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),
      (0, operators_1$1.delay)(5e3),
      (0, operators_1$1.filter)((_2) => !this.destroyed),
      (0, operators_1$1.flatMap)((_2) => ws.connect()),
      (0, operators_1$1.retry)()
    ).subscribe());
    this.subscriptions.add(ws.connectionState$.pipe(
      (0, operators_1$1.skip)(2),
      (0, operators_1$1.switchMap)((cs) => (0, rxjs_1$1.iif)(
        () => cs === RxWebSocket_1.ConnectionState.CONNECTED,
        this.authenticate().pipe((0, operators_1$1.tap)((_2) => this.sendIsLinked()), (0, operators_1$1.tap)((_2) => this.sendGetSessionConfig()), (0, operators_1$1.map)((_2) => true)),
        (0, rxjs_1$1.of)(false)
      )),
      (0, operators_1$1.distinctUntilChanged)(),
      (0, operators_1$1.catchError)((_2) => (0, rxjs_1$1.of)(false))
    ).subscribe((connected) => this.connectedSubject.next(connected)));
    this.subscriptions.add(ws.connectionState$.pipe(
      (0, operators_1$1.skip)(1),
      (0, operators_1$1.switchMap)((cs) => (0, rxjs_1$1.iif)(
        () => cs === RxWebSocket_1.ConnectionState.CONNECTED,
        (0, rxjs_1$1.timer)(0, HEARTBEAT_INTERVAL)
      ))
    ).subscribe((i) => i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));
    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1$1.filter)((m2) => m2 === "h")).subscribe((_2) => this.updateLastHeartbeat()));
    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => ["IsLinkedOK", "Linked"].includes(m2.type))).subscribe((m2) => {
      var _a2;
      const msg = m2;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.LINKED, {
        sessionIdHash: Session_1$1.Session.hash(sessionId),
        linked: msg.linked,
        type: m2.type,
        onlineGuests: msg.onlineGuests
      });
      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
    }));
    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m2.type))).subscribe((m2) => {
      var _a2;
      const msg = m2;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.SESSION_CONFIG_RECEIVED, {
        sessionIdHash: Session_1$1.Session.hash(sessionId),
        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
      });
      this.sessionConfigSubject.next({
        webhookId: msg.webhookId,
        webhookUrl: msg.webhookUrl,
        metadata: msg.metadata
      });
    }));
  }
  connect() {
    var _a2;
    if (this.destroyed) {
      throw new Error("instance is destroyed");
    }
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.STARTED_CONNECTING, {
      sessionIdHash: Session_1$1.Session.hash(this.sessionId)
    });
    this.ws.connect().subscribe();
  }
  destroy() {
    var _a2;
    this.subscriptions.unsubscribe();
    this.ws.disconnect();
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1$1.EVENTS.DISCONNECTED, {
      sessionIdHash: Session_1$1.Session.hash(this.sessionId)
    });
    this.destroyed = true;
  }
  get isDestroyed() {
    return this.destroyed;
  }
  get connected$() {
    return this.connectedSubject.asObservable();
  }
  get onceConnected$() {
    return this.connected$.pipe((0, operators_1$1.filter)((v2) => v2), (0, operators_1$1.take)(1), (0, operators_1$1.map)(() => void 0));
  }
  get linked$() {
    return this.linkedSubject.asObservable();
  }
  get onceLinked$() {
    return this.linked$.pipe((0, operators_1$1.filter)((v2) => v2), (0, operators_1$1.take)(1), (0, operators_1$1.map)(() => void 0));
  }
  get sessionConfig$() {
    return this.sessionConfigSubject.asObservable();
  }
  get incomingEvent$() {
    return this.ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => {
      if (m2.type !== "Event") {
        return false;
      }
      const sme = m2;
      return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
    }), (0, operators_1$1.map)((m2) => m2));
  }
  setSessionMetadata(key2, value) {
    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      metadata: {
        [key2]: value
      }
    });
    return this.onceConnected$.pipe((0, operators_1$1.flatMap)((_2) => this.makeRequest(message)), (0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to set session metadata");
      }
    }));
  }
  publishEvent(event, data, callWebhook = false) {
    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      event,
      data,
      callWebhook
    });
    return this.onceLinked$.pipe((0, operators_1$1.flatMap)((_2) => this.makeRequest(message)), (0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to publish event");
      }
      return res.eventId;
    }));
  }
  sendData(message) {
    this.ws.sendData(JSON.stringify(message));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch (_a2) {
    }
  }
  makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
    const reqId = message.id;
    try {
      this.sendData(message);
    } catch (err) {
      return (0, rxjs_1$1.throwError)(err);
    }
    return this.ws.incomingJSONData$.pipe((0, operators_1$1.timeoutWith)(timeout2, (0, rxjs_1$1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1$1.filter)((m2) => m2.id === reqId), (0, operators_1$1.take)(1));
  }
  authenticate() {
    const msg = (0, ClientMessage_1.ClientMessageHostSession)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      sessionKey: this.sessionKey
    });
    return this.makeRequest(msg).pipe((0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to authentcate");
      }
    }));
  }
  sendIsLinked() {
    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(msg);
  }
  sendGetSessionConfig() {
    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
      id: (0, types_1$1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(msg);
  }
}
WalletSDKConnection$1.WalletSDKConnection = WalletSDKConnection;
var aes256gcm$1 = {};
Object.defineProperty(aes256gcm$1, "__esModule", {
  value: true
});
aes256gcm$1.decrypt = aes256gcm$1.encrypt = void 0;
const util_1$3 = util$3;
async function encrypt(plainText, secret) {
  if (secret.length !== 64)
    throw Error(`secret must be 256 bits`);
  const ivBytes = crypto.getRandomValues(new Uint8Array(12));
  const secretKey = await crypto.subtle.importKey("raw", (0, util_1$3.hexStringToUint8Array)(secret), {
    name: "aes-gcm"
  }, false, ["encrypt", "decrypt"]);
  const enc = new TextEncoder();
  const encryptedResult = await window.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: ivBytes
  }, secretKey, enc.encode(plainText));
  const tagLength = 16;
  const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
  const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
  const authTagBytes = new Uint8Array(authTag);
  const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
  const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
  return (0, util_1$3.uint8ArrayToHex)(concatted);
}
aes256gcm$1.encrypt = encrypt;
function decrypt(cipherText, secret) {
  if (secret.length !== 64)
    throw Error(`secret must be 256 bits`);
  return new Promise((resolve, reject) => {
    void async function() {
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1$3.hexStringToUint8Array)(secret), {
        name: "aes-gcm"
      }, false, ["encrypt", "decrypt"]);
      const encrypted = (0, util_1$3.hexStringToUint8Array)(cipherText);
      const ivBytes = encrypted.slice(0, 12);
      const authTagBytes = encrypted.slice(12, 28);
      const encryptedPlaintextBytes = encrypted.slice(28);
      const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
      const algo = {
        name: "AES-GCM",
        iv: new Uint8Array(ivBytes)
      };
      try {
        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
        const decoder = new TextDecoder();
        resolve(decoder.decode(decrypted));
      } catch (err) {
        reject(err);
      }
    }();
  });
}
aes256gcm$1.decrypt = decrypt;
var Web3RequestCanceledMessage$1 = {};
var RelayMessage = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.RelayMessageType = void 0;
  (function(RelayMessageType) {
    RelayMessageType["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
    RelayMessageType["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
    RelayMessageType["LINKED"] = "LINKED";
    RelayMessageType["UNLINKED"] = "UNLINKED";
    RelayMessageType["WEB3_REQUEST"] = "WEB3_REQUEST";
    RelayMessageType["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
    RelayMessageType["WEB3_RESPONSE"] = "WEB3_RESPONSE";
  })(exports2.RelayMessageType || (exports2.RelayMessageType = {}));
})(RelayMessage);
Object.defineProperty(Web3RequestCanceledMessage$1, "__esModule", {
  value: true
});
Web3RequestCanceledMessage$1.Web3RequestCanceledMessage = void 0;
const RelayMessage_1$2 = RelayMessage;
function Web3RequestCanceledMessage(id2) {
  return {
    type: RelayMessage_1$2.RelayMessageType.WEB3_REQUEST_CANCELED,
    id: id2
  };
}
Web3RequestCanceledMessage$1.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
var Web3RequestMessage$1 = {};
Object.defineProperty(Web3RequestMessage$1, "__esModule", {
  value: true
});
Web3RequestMessage$1.Web3RequestMessage = void 0;
const RelayMessage_1$1 = RelayMessage;
function Web3RequestMessage(params) {
  return Object.assign({
    type: RelayMessage_1$1.RelayMessageType.WEB3_REQUEST
  }, params);
}
Web3RequestMessage$1.Web3RequestMessage = Web3RequestMessage;
var Web3ResponseMessage$1 = {};
Object.defineProperty(Web3ResponseMessage$1, "__esModule", {
  value: true
});
Web3ResponseMessage$1.isWeb3ResponseMessage = Web3ResponseMessage$1.Web3ResponseMessage = void 0;
const RelayMessage_1 = RelayMessage;
function Web3ResponseMessage(params) {
  return Object.assign({
    type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE
  }, params);
}
Web3ResponseMessage$1.Web3ResponseMessage = Web3ResponseMessage;
function isWeb3ResponseMessage(msg) {
  return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
}
Web3ResponseMessage$1.isWeb3ResponseMessage = isWeb3ResponseMessage;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  Object.defineProperty(o2, k22, {
    enumerable: true,
    get: function() {
      return m2[k2];
    }
  });
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", {
    enumerable: true,
    value: v2
  });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(WalletSDKRelay$1, "__esModule", {
  value: true
});
WalletSDKRelay$1.WalletSDKRelay = void 0;
const bind_decorator_1 = __importDefault(bindDecorator);
const rxjs_1 = require$$1;
const operators_1 = require$$2;
const DiagnosticLogger_1 = DiagnosticLogger;
const WalletSDKConnection_1 = WalletSDKConnection$1;
const errors_1 = errors$1;
const types_1 = types$2;
const util_1$2 = util$3;
const aes256gcm = __importStar(aes256gcm$1);
const Session_1 = Session$1;
const WalletSDKRelayAbstract_1 = WalletSDKRelayAbstract$1;
const Web3Method_1 = Web3Method;
const Web3RequestCanceledMessage_1 = Web3RequestCanceledMessage$1;
const Web3RequestMessage_1 = Web3RequestMessage$1;
const Web3Response_1 = Web3Response;
const Web3ResponseMessage_1 = Web3ResponseMessage$1;
class WalletSDKRelay extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {
  constructor(options) {
    var _a2;
    super();
    this.accountsCallback = null;
    this.chainCallback = null;
    this.dappDefaultChainSubject = new rxjs_1.BehaviorSubject(1);
    this.dappDefaultChain = 1;
    this.appName = "";
    this.appLogoUrl = null;
    this.subscriptions = new rxjs_1.Subscription();
    this.linkAPIUrl = options.linkAPIUrl;
    this.storage = options.storage;
    this.options = options;
    const {
      session,
      ui,
      connection
    } = this.subscribe();
    this._session = session;
    this.connection = connection;
    this.relayEventManager = options.relayEventManager;
    if (options.diagnosticLogger && options.eventListener) {
      throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
    }
    if (options.eventListener) {
      this.diagnostic = {
        log: options.eventListener.onEvent
      };
    } else {
      this.diagnostic = options.diagnosticLogger;
    }
    this._reloadOnDisconnect = (_a2 = options.reloadOnDisconnect) !== null && _a2 !== void 0 ? _a2 : true;
    this.ui = ui;
  }
  subscribe() {
    this.subscriptions.add(this.dappDefaultChainSubject.subscribe((chainId) => {
      if (this.dappDefaultChain !== chainId) {
        this.dappDefaultChain = chainId;
      }
    }));
    const session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();
    const connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);
    this.subscriptions.add(connection.sessionConfig$.subscribe({
      next: (sessionConfig) => {
        this.onSessionConfigChanged(sessionConfig);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "error while invoking session config callback"
        });
      }
    }));
    this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)((m2) => m2.event === "Web3Response")).subscribe({
      next: this.handleIncomingEvent
    }));
    this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
      var _a2;
      this.isLinked = linked;
      const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
      if (linked) {
        this.session.linked = linked;
      }
      this.isUnlinkedErrorState = false;
      if (cachedAddresses) {
        const addresses = cachedAddresses.split(" ");
        const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
        if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
          this.isUnlinkedErrorState = true;
          const sessionIdHash = this.getSessionIdHash();
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {
            sessionIdHash
          });
        }
      }
    })).subscribe());
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => !!c2.metadata && c2.metadata.__destroyed === "1")).subscribe(() => {
      var _a2;
      const alreadyDestroyed = connection.isDestroyed;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {
        alreadyDestroyed,
        sessionIdHash: this.getSessionIdHash()
      });
      return this.resetAndReload();
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.WalletUsername, session.secret))).subscribe({
      next: (walletUsername) => {
        this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "username"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.AppVersion, session.secret))).subscribe({
      next: (appVersion) => {
        this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appversion"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.ChainId !== void 0 && c2.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c2) => (0, rxjs_1.zip)(aes256gcm.decrypt(c2.metadata.ChainId, session.secret), aes256gcm.decrypt(c2.metadata.JsonRpcUrl, session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
      next: ([chainId, jsonRpcUrl]) => {
        if (this.chainCallback) {
          this.chainCallback(chainId, jsonRpcUrl);
        }
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "chainId|jsonRpcUrl"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.EthereumAddress, session.secret))).subscribe({
      next: (selectedAddress) => {
        if (this.accountsCallback) {
          this.accountsCallback([selectedAddress]);
        }
        if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {
          Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach((id2) => {
            const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.RequestEthereumAccountsResponse)([selectedAddress])
            });
            this.invokeCallback(Object.assign(Object.assign({}, message), {
              id: id2
            }));
          });
          WalletSDKRelay.accountRequestCallbackIds.clear();
        }
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "selectedAddress"
        });
      }
    }));
    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.AppSrc !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.AppSrc, session.secret))).subscribe({
      next: (appSrc) => {
        this.ui.setAppSrc(appSrc);
      },
      error: () => {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appSrc"
        });
      }
    }));
    const ui = this.options.uiConstructor({
      linkAPIUrl: this.options.linkAPIUrl,
      version: this.options.version,
      darkMode: this.options.darkMode,
      session,
      connected$: connection.connected$,
      chainId$: this.dappDefaultChainSubject
    });
    connection.connect();
    return {
      session,
      ui,
      connection
    };
  }
  attachUI() {
    this.ui.attach();
  }
  resetAndReload() {
    this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_2) => (0, rxjs_1.of)(null))).subscribe((_2) => {
      var _a2, _b2, _c2;
      const isStandalone = this.ui.isStandalone();
      try {
        this.subscriptions.unsubscribe();
      } catch (err) {
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
          message: "Had error unsubscribing"
        });
      }
      (_b2 = this.diagnostic) === null || _b2 === void 0 ? void 0 : _b2.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {
        method: "relay::resetAndReload",
        sessionMetadataChange: "__destroyed, 1",
        sessionIdHash: this.getSessionIdHash()
      });
      this.connection.destroy();
      const storedSession = Session_1.Session.load(this.storage);
      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
        this.storage.clear();
      } else if (storedSession) {
        (_c2 = this.diagnostic) === null || _c2 === void 0 ? void 0 : _c2.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: Session_1.Session.hash(storedSession.id)
        });
      }
      if (this._reloadOnDisconnect) {
        this.ui.reloadUI();
        return;
      }
      if (this.accountsCallback) {
        this.accountsCallback([], true);
      }
      this.subscriptions = new rxjs_1.Subscription();
      const {
        session,
        ui,
        connection
      } = this.subscribe();
      this._session = session;
      this.connection = connection;
      this.ui = ui;
      if (isStandalone && this.ui.setStandalone)
        this.ui.setStandalone(true);
      this.attachUI();
    }, (err) => {
      var _a2;
      (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.FAILURE, {
        method: "relay::resetAndReload",
        message: `failed to reset and reload with ${err}`,
        sessionIdHash: this.getSessionIdHash()
      });
    });
  }
  setAppInfo(appName, appLogoUrl) {
    this.appName = appName;
    this.appLogoUrl = appLogoUrl;
  }
  getStorageItem(key2) {
    return this.storage.getItem(key2);
  }
  get session() {
    return this._session;
  }
  setStorageItem(key2, value) {
    this.storage.setItem(key2, value);
  }
  signEthereumMessage(message, address, addPrefix, typedDataJson) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumMessage,
      params: {
        message: (0, util_1$2.hexStringFromBuffer)(message, true),
        address,
        addPrefix,
        typedDataJson: typedDataJson || null
      }
    });
  }
  ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
      params: {
        message: (0, util_1$2.hexStringFromBuffer)(message, true),
        signature: (0, util_1$2.hexStringFromBuffer)(signature2, true),
        addPrefix
      }
    });
  }
  signEthereumTransaction(params) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: (0, util_1$2.bigIntStringFromBN)(params.weiValue),
        data: (0, util_1$2.hexStringFromBuffer)(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxFeePerGas: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        gasLimit: params.gasLimit ? (0, util_1$2.bigIntStringFromBN)(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: false
      }
    });
  }
  signAndSubmitEthereumTransaction(params) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: (0, util_1$2.bigIntStringFromBN)(params.weiValue),
        data: (0, util_1$2.hexStringFromBuffer)(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxFeePerGas: params.maxFeePerGas ? (0, util_1$2.bigIntStringFromBN)(params.maxFeePerGas) : null,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1$2.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
        gasLimit: params.gasLimit ? (0, util_1$2.bigIntStringFromBN)(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: true
      }
    });
  }
  submitEthereumTransaction(signedTransaction, chainId) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.submitEthereumTransaction,
      params: {
        signedTransaction: (0, util_1$2.hexStringFromBuffer)(signedTransaction, true),
        chainId
      }
    });
  }
  scanQRCode(regExp) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.scanQRCode,
      params: {
        regExp
      }
    });
  }
  getQRCodeUrl() {
    return (0, util_1$2.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);
  }
  genericRequest(data, action) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.generic,
      params: {
        action,
        data
      }
    });
  }
  sendGenericMessage(request) {
    return this.sendRequest(request);
  }
  sendRequest(request) {
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    const promise = new Promise((resolve, reject) => {
      if (!this.ui.isStandalone()) {
        hideSnackbarItem = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
        });
      }
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      if (this.ui.isStandalone()) {
        this.sendRequestStandalone(id2, request);
      } else {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return {
      promise,
      cancel
    };
  }
  setConnectDisabled(disabled) {
    this.ui.setConnectDisabled(disabled);
  }
  setAccountsCallback(accountsCallback) {
    this.accountsCallback = accountsCallback;
  }
  setChainCallback(chainCallback) {
    this.chainCallback = chainCallback;
  }
  setDappDefaultChainCallback(chainId) {
    this.dappDefaultChainSubject.next(chainId);
  }
  publishWeb3RequestEvent(id2, request) {
    var _a2;
    const message = (0, Web3RequestMessage_1.Web3RequestMessage)({
      id: id2,
      request
    });
    const storedSession = Session_1.Session.load(this.storage);
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {
      eventId: message.id,
      method: `relay::${message.request.method}`,
      sessionIdHash: this.getSessionIdHash(),
      storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
      isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
    });
    this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
      next: (_2) => {
        var _a3;
        (_a3 = this.diagnostic) === null || _a3 === void 0 ? void 0 : _a3.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
      },
      error: (err) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: message.id,
          response: {
            method: message.request.method,
            errorMessage: err.message
          }
        }));
      }
    }));
  }
  publishWeb3RequestCanceledEvent(id2) {
    const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id2);
    this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
  }
  publishEvent(event, message, callWebhook) {
    const secret = this.session.secret;
    return new rxjs_1.Observable((subscriber) => {
      void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), {
        origin: location.origin
      })), secret).then((encrypted) => {
        subscriber.next(encrypted);
        subscriber.complete();
      });
    }).pipe((0, operators_1.mergeMap)((encrypted) => {
      return this.connection.publishEvent(event, encrypted, callWebhook);
    }));
  }
  handleIncomingEvent(event) {
    try {
      this.subscriptions.add((0, rxjs_1.from)(aes256gcm.decrypt(event.data, this.session.secret)).pipe((0, operators_1.map)((c2) => JSON.parse(c2))).subscribe({
        next: (json2) => {
          const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json2) ? json2 : null;
          if (!message) {
            return;
          }
          this.handleWeb3ResponseMessage(message);
        },
        error: () => {
          var _a2;
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent"
          });
        }
      }));
    } catch (_a2) {
      return;
    }
  }
  handleWeb3ResponseMessage(message) {
    var _a2;
    const {
      response
    } = message;
    (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {
      eventId: message.id,
      method: `relay::${response.method}`,
      sessionIdHash: this.getSessionIdHash()
    });
    if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
      WalletSDKRelay.accountRequestCallbackIds.forEach((id2) => this.invokeCallback(Object.assign(Object.assign({}, message), {
        id: id2
      })));
      WalletSDKRelay.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(message);
  }
  handleErrorResponse(id2, method, error, errorCode) {
    var _a2;
    const errorMessage = (_a2 = error === null || error === void 0 ? void 0 : error.message) !== null && _a2 !== void 0 ? _a2 : (0, errors_1.standardErrorMessage)(errorCode);
    this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
      id: id2,
      response: {
        method,
        errorMessage,
        errorCode
      }
    }));
  }
  invokeCallback(message) {
    const callback = this.relayEventManager.callbacks.get(message.id);
    if (callback) {
      callback(message.response);
      this.relayEventManager.callbacks.delete(message.id);
    }
  }
  requestEthereumAccounts() {
    const request = {
      method: Web3Method_1.Web3Method.requestEthereumAccounts,
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl || null
      }
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
    };
    const promise = new Promise((resolve, reject) => {
      var _a2;
      this.relayEventManager.callbacks.set(id2, (response) => {
        this.ui.hideRequestEthereumAccounts();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const userAgent = ((_a2 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) || null;
      if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
        let location2;
        try {
          if ((0, util_1$2.isInIFrame)() && window.top) {
            location2 = window.top.location;
          } else {
            location2 = window.location;
          }
        } catch (e2) {
          location2 = window.location;
        }
        location2.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(location2.href)}`;
        return;
      }
      if (this.ui.inlineAccountsResponse()) {
        const onAccounts = (accounts) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
          }));
        };
        this.ui.requestEthereumAccounts({
          onCancel: cancel,
          onAccounts
        });
      } else {
        const err = errors_1.standardErrors.provider.userRejectedRequest("User denied account authorization");
        this.ui.requestEthereumAccounts({
          onCancel: () => cancel(err)
        });
      }
      WalletSDKRelay.accountRequestCallbackIds.add(id2);
      if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return {
      promise,
      cancel
    };
  }
  selectProvider(providerOptions) {
    const request = {
      method: Web3Method_1.Web3Method.selectProvider,
      params: {
        providerOptions
      }
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
    };
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (_error) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)
        }));
      };
      const approve = (selectedProviderKey) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)
        }));
      };
      if (this.ui.selectProvider)
        this.ui.selectProvider({
          onApprove: approve,
          onCancel: _cancel,
          providerOptions
        });
    });
    return {
      cancel,
      promise
    };
  }
  watchAsset(type2, address, symbol, decimals, image, chainId) {
    const request = {
      method: Web3Method_1.Web3Method.watchAsset,
      params: {
        type: type2,
        options: {
          address,
          symbol,
          decimals,
          image
        },
        chainId
      }
    };
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    if (!this.ui.inlineWatchAsset()) {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
      });
    }
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (_error) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.WatchAssetReponse)(false)
        }));
      };
      const approve = () => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.WatchAssetReponse)(true)
        }));
      };
      if (this.ui.inlineWatchAsset()) {
        this.ui.watchAsset({
          onApprove: approve,
          onCancel: _cancel,
          type: type2,
          address,
          symbol,
          decimals,
          image,
          chainId
        });
      }
      if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return {
      cancel,
      promise
    };
  }
  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
    const request = {
      method: Web3Method_1.Web3Method.addEthereumChain,
      params: {
        chainId,
        rpcUrls,
        blockExplorerUrls,
        chainName,
        iconUrls,
        nativeCurrency
      }
    };
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    if (!this.ui.inlineAddEthereumChain(chainId)) {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
      });
    }
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (_error) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.AddEthereumChainResponse)({
            isApproved: false,
            rpcUrl: ""
          })
        }));
      };
      const approve = (rpcUrl) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.AddEthereumChainResponse)({
            isApproved: true,
            rpcUrl
          })
        }));
      };
      if (this.ui.inlineAddEthereumChain(chainId)) {
        this.ui.addEthereumChain({
          onCancel: _cancel,
          onApprove: approve,
          chainId: request.params.chainId,
          rpcUrls: request.params.rpcUrls,
          blockExplorerUrls: request.params.blockExplorerUrls,
          chainName: request.params.chainName,
          iconUrls: request.params.iconUrls,
          nativeCurrency: request.params.nativeCurrency
        });
      }
      if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return {
      promise,
      cancel
    };
  }
  switchEthereumChain(chainId, address) {
    const request = {
      method: Web3Method_1.Web3Method.switchEthereumChain,
      params: Object.assign({
        chainId
      }, {
        address
      })
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request.method, error);
    };
    const promise = new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        if ((0, Web3Response_1.isErrorResponse)(response) && response.errorCode) {
          return reject(errors_1.standardErrors.provider.custom({
            code: response.errorCode,
            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
          }));
        } else if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      const _cancel = (error) => {
        var _a2;
        if (error) {
          const errorCode = (_a2 = (0, errors_1.getErrorCode)(error)) !== null && _a2 !== void 0 ? _a2 : errors_1.standardErrorCodes.provider.unsupportedChain;
          this.handleErrorResponse(id2, Web3Method_1.Web3Method.switchEthereumChain, error instanceof Error ? error : errors_1.standardErrors.provider.unsupportedChain(chainId), errorCode);
        } else {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.SwitchEthereumChainResponse)({
              isApproved: false,
              rpcUrl: ""
            })
          }));
        }
      };
      const approve = (rpcUrl) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SwitchEthereumChainResponse)({
            isApproved: true,
            rpcUrl
          })
        }));
      };
      this.ui.switchEthereumChain({
        onCancel: _cancel,
        onApprove: approve,
        chainId: request.params.chainId,
        address: request.params.address
      });
      if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return {
      promise,
      cancel
    };
  }
  inlineAddEthereumChain(chainId) {
    return this.ui.inlineAddEthereumChain(chainId);
  }
  getSessionIdHash() {
    return Session_1.Session.hash(this._session.id);
  }
  sendRequestStandalone(id2, request) {
    const _cancel = (error) => {
      this.handleErrorResponse(id2, request.method, error);
    };
    const onSuccess = (response) => {
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response
      }));
    };
    switch (request.method) {
      case Web3Method_1.Web3Method.signEthereumMessage:
        this.ui.signEthereumMessage({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.signEthereumTransaction:
        this.ui.signEthereumTransaction({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.submitEthereumTransaction:
        this.ui.submitEthereumTransaction({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
        this.ui.ethereumAddressFromSignedMessage({
          request,
          onSuccess
        });
        break;
      default:
        _cancel();
        break;
    }
  }
  onSessionConfigChanged(_nextSessionConfig) {
  }
}
WalletSDKRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();
__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, "resetAndReload", null);
__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, "handleIncomingEvent", null);
WalletSDKRelay$1.WalletSDKRelay = WalletSDKRelay;
var WalletSDKRelayEventManager$1 = {};
Object.defineProperty(WalletSDKRelayEventManager$1, "__esModule", {
  value: true
});
WalletSDKRelayEventManager$1.WalletSDKRelayEventManager = void 0;
const util_1$1 = util$3;
class WalletSDKRelayEventManager {
  constructor() {
    this._nextRequestId = 0;
    this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const id2 = this._nextRequestId;
    const idStr = (0, util_1$1.prepend0x)(id2.toString(16));
    const callback = this.callbacks.get(idStr);
    if (callback) {
      this.callbacks.delete(idStr);
    }
    return id2;
  }
}
WalletSDKRelayEventManager$1.WalletSDKRelayEventManager = WalletSDKRelayEventManager;
const name = "@coinbase/wallet-sdk";
const version = "3.7.1";
const description = "Coinbase Wallet JavaScript SDK";
const keywords = [
  "cipher",
  "cipherbrowser",
  "coinbase",
  "coinbasewallet",
  "eth",
  "ether",
  "ethereum",
  "etherium",
  "injection",
  "toshi",
  "wallet",
  "walletlink",
  "web3"
];
const main = "dist/index.js";
const types = "dist/index.d.ts";
const repository = "https://github.com/coinbase/coinbase-wallet-sdk.git";
const author = "Coinbase, Inc.";
const license = "Apache-2.0";
const scripts = {
  "pretest:unit": "node compile-assets.js",
  "test:unit": "jest",
  "test:unit:coverage": "yarn test:unit && open coverage/lcov-report/index.html",
  "test:karma": "yarn build-npm && karma start",
  prebuild: `rm -rf ./build && node -p "'export const LIB_VERSION = ' + JSON.stringify(require('./package.json').version) + ';'" > src/version.ts`,
  build: "node compile-assets.js && webpack --config webpack.config.js",
  "build-npm": "tsc -p ./tsconfig.build.json",
  "build:dev": "export LINK_API_URL='http://localhost:3000'; yarn build",
  "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --exec 'yarn build:dev'",
  "build:prod": `yarn prebuild && yarn build && yarn build-npm && cp ./package.json ../../README.md ./LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
  "lint:types": "tsc --noEmit",
  "lint:prettier": 'prettier --check "{src,__tests__}/**/*.(js|ts|tsx)"',
  "lint:eslint": "eslint ./src --ext .ts,.tsx",
  lint: "yarn lint:eslint && yarn lint:types && yarn lint:prettier",
  "fix:eslint": "yarn lint:eslint --fix",
  "fix:prettier": "prettier . --write",
  release: "./scripts/release.sh"
};
const dependencies = {
  "@metamask/safe-event-emitter": "2.0.0",
  "@solana/web3.js": "^1.70.1",
  "bind-decorator": "^1.0.11",
  "bn.js": "^5.1.1",
  buffer: "^6.0.3",
  clsx: "^1.1.0",
  "eth-block-tracker": "6.1.0",
  "eth-json-rpc-filters": "5.1.0",
  "eth-rpc-errors": "4.0.2",
  "json-rpc-engine": "6.1.0",
  keccak: "^3.0.1",
  preact: "^10.5.9",
  qs: "^6.10.3",
  rxjs: "^6.6.3",
  "sha.js": "^2.4.11",
  "stream-browserify": "^3.0.0",
  util: "^0.12.4"
};
const devDependencies = {
  "@babel/core": "^7.17.9",
  "@babel/plugin-proposal-decorators": "^7.17.9",
  "@babel/plugin-transform-react-jsx": "^7.17.3",
  "@babel/preset-env": "^7.16.11",
  "@babel/preset-typescript": "^7.16.7",
  "@peculiar/webcrypto": "^1.3.3",
  "@testing-library/jest-dom": "^5.16.4",
  "@testing-library/preact": "^2.0.1",
  "@types/bn.js": "^4.11.6",
  "@types/jest": "^27.4.1",
  "@types/node": "^14.14.20",
  "@types/qs": "^6.9.7",
  "@types/sha.js": "^2.4.0",
  "@typescript-eslint/eslint-plugin": "^5.7.0",
  "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
  "@typescript-eslint/parser": "^5.7.0",
  "babel-jest": "^27.5.1",
  browserify: "17.0.0",
  "copy-webpack-plugin": "^6.4.1",
  "core-js": "^3.8.2",
  eslint: "^8.4.1",
  "eslint-config-prettier": "^8.3.0",
  "eslint-plugin-import": "^2.25.3",
  "eslint-plugin-preact": "^0.1.0",
  "eslint-plugin-prettier": "^4.0.0",
  "eslint-plugin-simple-import-sort": "^7.0.0",
  jasmine: "3.8.0",
  jest: "^27.5.1",
  "jest-chrome": "^0.7.2",
  "jest-websocket-mock": "^2.3.0",
  karma: "^6.4.0",
  "karma-browserify": "8.1.0",
  "karma-chrome-launcher": "^3.1.0",
  "karma-jasmine": "^4.0.1",
  nodemon: "^2.0.6",
  prettier: "^2.5.1",
  "raw-loader": "^4.0.2",
  "regenerator-runtime": "^0.13.7",
  sass: "^1.50.0",
  svgo: "^2.8.0",
  "ts-jest": "^27.1.4",
  "ts-loader": "^8.0.13",
  "ts-node": "^10.7.0",
  tslib: "^2.0.3",
  typescript: "^4.1.3",
  watchify: "4.0.0",
  webpack: "^5.76.0",
  "webpack-cli": "^4.9.2",
  "whatwg-fetch": "^3.5.0"
};
const engines = {
  node: ">= 10.0.0"
};
const require$$7 = {
  name,
  version,
  description,
  keywords,
  main,
  types,
  repository,
  author,
  license,
  scripts,
  dependencies,
  devDependencies,
  engines
};
Object.defineProperty(CoinbaseWalletSDK$1, "__esModule", {
  value: true
});
CoinbaseWalletSDK$1.CoinbaseWalletSDK = void 0;
const wallet_logo_1 = walletLogo$1;
const ScopedLocalStorage_1 = ScopedLocalStorage$1;
const CoinbaseWalletProvider_1 = CoinbaseWalletProvider$1;
const WalletSDKUI_1 = WalletSDKUI$1;
const WalletSDKRelay_1 = WalletSDKRelay$1;
const WalletSDKRelayEventManager_1 = WalletSDKRelayEventManager$1;
const util_1 = util$3;
const LINK_API_URL = process.env.LINK_API_URL || "https://www.walletlink.org";
const SDK_VERSION = process.env.SDK_VERSION || require$$7.version || "unknown";
class CoinbaseWalletSDK {
  constructor(options) {
    var _a2, _b2, _c2;
    this._appName = "";
    this._appLogoUrl = null;
    this._relay = null;
    this._relayEventManager = null;
    const linkAPIUrl = options.linkAPIUrl || LINK_API_URL;
    let uiConstructor;
    if (!options.uiConstructor) {
      uiConstructor = (opts) => new WalletSDKUI_1.WalletSDKUI(opts);
    } else {
      uiConstructor = options.uiConstructor;
    }
    if (typeof options.overrideIsMetaMask === "undefined") {
      this._overrideIsMetaMask = false;
    } else {
      this._overrideIsMetaMask = options.overrideIsMetaMask;
    }
    this._overrideIsCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
    this._overrideIsCoinbaseBrowser = (_b2 = options.overrideIsCoinbaseBrowser) !== null && _b2 !== void 0 ? _b2 : false;
    if (options.diagnosticLogger && options.eventListener) {
      throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
    }
    if (options.eventListener) {
      this._diagnosticLogger = {
        log: options.eventListener.onEvent
      };
    } else {
      this._diagnosticLogger = options.diagnosticLogger;
    }
    this._reloadOnDisconnect = (_c2 = options.reloadOnDisconnect) !== null && _c2 !== void 0 ? _c2 : true;
    const url = new URL(linkAPIUrl);
    const origin = `${url.protocol}//${url.host}`;
    this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`);
    this._storage.setItem("version", CoinbaseWalletSDK.VERSION);
    if (this.walletExtension || this.coinbaseBrowser) {
      return;
    }
    this._relayEventManager = new WalletSDKRelayEventManager_1.WalletSDKRelayEventManager();
    this._relay = new WalletSDKRelay_1.WalletSDKRelay({
      linkAPIUrl,
      version: SDK_VERSION,
      darkMode: !!options.darkMode,
      uiConstructor,
      storage: this._storage,
      relayEventManager: this._relayEventManager,
      diagnosticLogger: this._diagnosticLogger,
      reloadOnDisconnect: this._reloadOnDisconnect
    });
    this.setAppInfo(options.appName, options.appLogoUrl);
    if (!!options.headlessMode)
      return;
    this._relay.attachUI();
  }
  makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
    const extension = this.walletExtension;
    if (extension) {
      if (!this.isCipherProvider(extension)) {
        extension.setProviderInfo(jsonRpcUrl, chainId);
      }
      if (this._reloadOnDisconnect === false && typeof extension.disableReloadOnDisconnect === "function")
        extension.disableReloadOnDisconnect();
      return extension;
    }
    const dappBrowser = this.coinbaseBrowser;
    if (dappBrowser) {
      return dappBrowser;
    }
    const relay = this._relay;
    if (!relay || !this._relayEventManager || !this._storage) {
      throw new Error("Relay not initialized, should never happen");
    }
    if (!jsonRpcUrl)
      relay.setConnectDisabled(true);
    return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
      relayProvider: () => Promise.resolve(relay),
      relayEventManager: this._relayEventManager,
      storage: this._storage,
      jsonRpcUrl,
      chainId,
      qrUrl: this.getQrUrl(),
      diagnosticLogger: this._diagnosticLogger,
      overrideIsMetaMask: this._overrideIsMetaMask,
      overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
      overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
    });
  }
  setAppInfo(appName, appLogoUrl) {
    var _a2;
    this._appName = appName || "DApp";
    this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
    const extension = this.walletExtension;
    if (extension) {
      if (!this.isCipherProvider(extension)) {
        extension.setAppInfo(this._appName, this._appLogoUrl);
      }
    } else {
      (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.setAppInfo(this._appName, this._appLogoUrl);
    }
  }
  disconnect() {
    var _a2;
    const extension = this.walletExtension;
    if (extension) {
      void extension.close();
    } else {
      (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.resetAndReload();
    }
  }
  getQrUrl() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.getQRCodeUrl()) !== null && _b2 !== void 0 ? _b2 : null;
  }
  getCoinbaseWalletLogo(type2, width = 240) {
    return (0, wallet_logo_1.walletLogo)(type2, width);
  }
  get walletExtension() {
    var _a2;
    return (_a2 = window.coinbaseWalletExtension) !== null && _a2 !== void 0 ? _a2 : window.walletLinkExtension;
  }
  get coinbaseBrowser() {
    var _a2, _b2;
    try {
      const ethereum = (_a2 = window.ethereum) !== null && _a2 !== void 0 ? _a2 : (_b2 = window.top) === null || _b2 === void 0 ? void 0 : _b2.ethereum;
      if (!ethereum) {
        return void 0;
      }
      if ("isCoinbaseBrowser" in ethereum && ethereum.isCoinbaseBrowser) {
        return ethereum;
      } else {
        return void 0;
      }
    } catch (e2) {
      return void 0;
    }
  }
  isCipherProvider(provider) {
    return typeof provider.isCipher === "boolean" && provider.isCipher;
  }
}
CoinbaseWalletSDK$1.CoinbaseWalletSDK = CoinbaseWalletSDK;
CoinbaseWalletSDK.VERSION = SDK_VERSION;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.CoinbaseWalletProvider = exports2.CoinbaseWalletSDK = void 0;
  const CoinbaseWalletSDK_1 = CoinbaseWalletSDK$1;
  const CoinbaseWalletProvider_12 = CoinbaseWalletProvider$1;
  var CoinbaseWalletSDK_2 = CoinbaseWalletSDK$1;
  Object.defineProperty(exports2, "CoinbaseWalletSDK", {
    enumerable: true,
    get: function() {
      return CoinbaseWalletSDK_2.CoinbaseWalletSDK;
    }
  });
  var CoinbaseWalletProvider_2 = CoinbaseWalletProvider$1;
  Object.defineProperty(exports2, "CoinbaseWalletProvider", {
    enumerable: true,
    get: function() {
      return CoinbaseWalletProvider_2.CoinbaseWalletProvider;
    }
  });
  exports2.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
  if (typeof window !== "undefined") {
    window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    window.CoinbaseWalletProvider = CoinbaseWalletProvider_12.CoinbaseWalletProvider;
    window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    window.WalletLinkProvider = CoinbaseWalletProvider_12.CoinbaseWalletProvider;
  }
})(dist$5);
const index = /* @__PURE__ */ getDefaultExportFromCjs(dist$5);
const $$26 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [dist$5]);
var _client, _provider, _isUserRejectedRequestError, isUserRejectedRequestError_fn;
var CoinbaseWalletConnector = class extends Connector {
  constructor({
    chains,
    options
  }) {
    super({
      chains,
      options: {
        reloadOnDisconnect: false,
        ...options
      }
    });
    __privateAdd(this, _isUserRejectedRequestError);
    __publicField(this, "id", "coinbaseWallet");
    __publicField(this, "name", "Coinbase Wallet");
    __publicField(this, "ready", true);
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _provider, void 0);
    __publicField(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: utils$e.getAddress(accounts[0])
        });
    });
    __publicField(this, "onChainChanged", (chainId) => {
      const id2 = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", {
        chain: {
          id: id2,
          unsupported
        }
      });
    });
    __publicField(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect({
    chainId
  } = {}) {
    try {
      const provider = await this.getProvider();
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      this.emit("message", {
        type: "connecting"
      });
      const accounts = await provider.enable();
      const account = utils$e.getAddress(accounts[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain = await this.switchChain(chainId);
        id2 = chain.id;
        unsupported = this.isChainUnsupported(id2);
      }
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider: new ethers.providers.Web3Provider(provider)
      };
    } catch (error) {
      if (/(user closed modal|accounts received is empty)/i.test(error.message))
        throw new UserRejectedRequestError(error);
      throw error;
    }
  }
  async disconnect() {
    if (!__privateGet(this, _provider))
      return;
    const provider = await this.getProvider();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    provider.disconnect();
    provider.close();
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return utils$e.getAddress(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  async getProvider() {
    var _a2;
    if (!__privateGet(this, _provider)) {
      let CoinbaseWalletSDK2 = (await Promise.resolve($$26)).default;
      if (typeof CoinbaseWalletSDK2 !== "function" && typeof CoinbaseWalletSDK2.default === "function")
        CoinbaseWalletSDK2 = CoinbaseWalletSDK2.default;
      __privateSet(this, _client, new CoinbaseWalletSDK2(this.options));
      const walletExtensionChainId = (_a2 = __privateGet(this, _client).walletExtension) == null ? void 0 : _a2.getChainId();
      const chain = this.chains.find((chain2) => this.options.chainId ? chain2.id === this.options.chainId : chain2.id === walletExtensionChainId) || this.chains[0];
      const chainId = this.options.chainId || (chain == null ? void 0 : chain.id);
      const jsonRpcUrl = this.options.jsonRpcUrl || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
      __privateSet(this, _provider, __privateGet(this, _client).makeWeb3Provider(jsonRpcUrl, chainId));
    }
    return __privateGet(this, _provider);
  }
  async getSigner({
    chainId
  } = {}) {
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);
    return new ethers.providers.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    var _a2, _b2, _c2;
    const provider = await this.getProvider();
    const id2 = utils$e.hexValue(chainId);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id2
        }]
      });
      return (_a2 = this.chains.find((x2) => x2.id === chainId)) != null ? _a2 : {
        id: chainId,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: {
          name: "Ether",
          decimals: 18,
          symbol: "ETH"
        },
        rpcUrls: {
          default: {
            http: [""]
          },
          public: {
            http: [""]
          }
        }
      };
    } catch (error) {
      const chain = this.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new ChainNotConfiguredError({
          chainId,
          connectorId: this.id
        });
      if (error.code === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: id2,
              chainName: chain.name,
              nativeCurrency: chain.nativeCurrency,
              rpcUrls: [(_c2 = (_b2 = chain.rpcUrls.public) == null ? void 0 : _b2.http[0]) != null ? _c2 : ""],
              blockExplorerUrls: this.getBlockExplorerUrls(chain)
            }]
          });
          return chain;
        } catch (addError) {
          if (__privateMethod(this, _isUserRejectedRequestError, isUserRejectedRequestError_fn).call(this, addError))
            throw new UserRejectedRequestError(addError);
          throw new AddChainError();
        }
      }
      if (__privateMethod(this, _isUserRejectedRequestError, isUserRejectedRequestError_fn).call(this, error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
};
_client = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_isUserRejectedRequestError = /* @__PURE__ */ new WeakSet();
isUserRejectedRequestError_fn = function(error) {
  return /(user rejected)/i.test(error.message);
};
var _UNSTABLE_shimOnConnectSelectAccount;
var MetaMaskConnector = class extends InjectedConnector {
  constructor({
    chains,
    options: options_
  } = {}) {
    const options = {
      name: "MetaMask",
      shimDisconnect: true,
      getProvider() {
        function getReady(ethereum2) {
          const isMetaMask2 = !!(ethereum2 == null ? void 0 : ethereum2.isMetaMask);
          if (!isMetaMask2)
            return;
          if (ethereum2.isBraveWallet && !ethereum2._events && !ethereum2._state)
            return;
          if (ethereum2.isApexWallet)
            return;
          if (ethereum2.isAvalanche)
            return;
          if (ethereum2.isBitKeep)
            return;
          if (ethereum2.isBlockWallet)
            return;
          if (ethereum2.isKuCoinWallet)
            return;
          if (ethereum2.isMathWallet)
            return;
          if (ethereum2.isOkxWallet || ethereum2.isOKExWallet)
            return;
          if (ethereum2.isOneInchIOSWallet || ethereum2.isOneInchAndroidWallet)
            return;
          if (ethereum2.isOpera)
            return;
          if (ethereum2.isPortal)
            return;
          if (ethereum2.isRabby)
            return;
          if (ethereum2.isTokenPocket)
            return;
          if (ethereum2.isTokenary)
            return;
          if (ethereum2.isZerion)
            return;
          return ethereum2;
        }
        if (typeof window === "undefined")
          return;
        const ethereum = window.ethereum;
        if (ethereum == null ? void 0 : ethereum.providers)
          return ethereum.providers.find(getReady);
        return getReady(ethereum);
      },
      ...options_
    };
    super({
      chains,
      options
    });
    __publicField(this, "id", "metaMask");
    __publicField(this, "shimDisconnectKey", `${this.id}.shimDisconnect`);
    __privateAdd(this, _UNSTABLE_shimOnConnectSelectAccount, void 0);
    __privateSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);
  }
  async connect({
    chainId
  } = {}) {
    var _a2, _b2, _c2, _d;
    try {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", {
        type: "connecting"
      });
      let account = null;
      if (__privateGet(this, _UNSTABLE_shimOnConnectSelectAccount) && ((_a2 = this.options) == null ? void 0 : _a2.shimDisconnect) && !((_b2 = getClient().storage) == null ? void 0 : _b2.getItem(this.shimDisconnectKey))) {
        account = await this.getAccount().catch(() => null);
        const isConnected = !!account;
        if (isConnected)
          try {
            await provider.request({
              method: "wallet_requestPermissions",
              params: [{
                eth_accounts: {}
              }]
            });
            account = await this.getAccount();
          } catch (error) {
            if (this.isUserRejectedRequestError(error))
              throw new UserRejectedRequestError(error);
            if (error.code === new ResourceUnavailableError(error).code)
              throw error;
          }
      }
      if (!account) {
        const accounts = await provider.request({
          method: "eth_requestAccounts"
        });
        account = utils$e.getAddress(accounts[0]);
      }
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId && id2 !== chainId) {
        const chain = await this.switchChain(chainId);
        id2 = chain.id;
        unsupported = this.isChainUnsupported(id2);
      }
      if ((_c2 = this.options) == null ? void 0 : _c2.shimDisconnect)
        (_d = getClient().storage) == null ? void 0 : _d.setItem(this.shimDisconnectKey, true);
      return {
        account,
        chain: {
          id: id2,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableError(error);
      throw error;
    }
  }
};
_UNSTABLE_shimOnConnectSelectAccount = /* @__PURE__ */ new WeakMap();
function omitUndefinedValues(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([_key, value]) => value !== void 0));
}
var connectorsForWallets = (walletList) => {
  return () => {
    let index2 = -1;
    const connectors = [];
    const visibleWallets = [];
    const potentiallyHiddenWallets = [];
    const walletInstances = [];
    walletList.forEach(({
      groupName,
      wallets: wallets2
    }, groupIndex) => {
      wallets2.forEach((wallet) => {
        index2++;
        if ((wallet == null ? void 0 : wallet.iconAccent) && !isHexString$5(wallet == null ? void 0 : wallet.iconAccent)) {
          throw new Error(`Property \`iconAccent\` is not a hex value for wallet: ${wallet.name}`);
        }
        const walletListItem = {
          ...wallet,
          groupIndex,
          groupName,
          index: index2
        };
        if (typeof wallet.hidden === "function") {
          potentiallyHiddenWallets.push(walletListItem);
        } else {
          visibleWallets.push(walletListItem);
        }
      });
    });
    const walletListItems = [...visibleWallets, ...potentiallyHiddenWallets];
    walletListItems.forEach(({
      createConnector: createConnector2,
      groupIndex,
      groupName,
      hidden,
      index: index22,
      ...walletMeta
    }) => {
      if (typeof hidden === "function") {
        const isHidden = hidden({
          wallets: [...walletInstances.map(({
            connector: connector2,
            id: id2,
            installed
          }) => ({
            connector: connector2,
            id: id2,
            installed
          }))]
        });
        if (isHidden) {
          return;
        }
      }
      const {
        connector,
        ...connectionMethods
      } = omitUndefinedValues(createConnector2());
      let walletConnectModalConnector;
      if (walletMeta.id === "walletConnect" && connectionMethods.qrCode && !isMobile$1()) {
        const {
          chains,
          options
        } = connector;
        walletConnectModalConnector = new WalletConnectLegacyConnector({
          chains,
          options: {
            ...options,
            qrcode: true
          }
        });
        connectors.push(walletConnectModalConnector);
      }
      const walletInstance = {
        connector,
        groupIndex,
        groupName,
        index: index22,
        walletConnectModalConnector,
        ...walletMeta,
        ...connectionMethods
      };
      walletInstances.push(walletInstance);
      if (!connectors.includes(connector)) {
        connectors.push(connector);
        connector._wallets = [];
      }
      connector._wallets.push(walletInstance);
    });
    return connectors;
  };
};
var braveWallet = ({
  chains,
  shimDisconnect
}) => {
  var _a2;
  return {
    id: "brave",
    name: "Brave Wallet",
    iconUrl: async () => (await Promise.resolve($$0)).default,
    iconBackground: "#fff",
    installed: typeof window !== "undefined" && ((_a2 = window.ethereum) == null ? void 0 : _a2.isBraveWallet) === true,
    downloadUrls: {},
    createConnector: () => ({
      connector: new InjectedConnector({
        chains,
        options: {
          shimDisconnect
        }
      })
    })
  };
};
var coinbaseWallet = ({
  appName,
  chains
}) => {
  var _a2;
  const isCoinbaseWalletInjected = typeof window !== "undefined" && ((_a2 = window.ethereum) == null ? void 0 : _a2.isCoinbaseWallet) === true;
  return {
    id: "coinbase",
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    iconUrl: async () => (await Promise.resolve($$1$1)).default,
    iconAccent: "#2c5ff6",
    iconBackground: "#2c5ff6",
    installed: isCoinbaseWalletInjected || void 0,
    downloadUrls: {
      browserExtension: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/us/app/coinbase-wallet-store-crypto/id1278383455",
      qrCode: "https://coinbase-wallet.onelink.me/q5Sx/fdb9b250"
    },
    createConnector: () => {
      const ios = isIOS$1();
      const connector = new CoinbaseWalletConnector({
        chains,
        options: {
          appName,
          headlessMode: true
        }
      });
      const getUri = async () => (await connector.getProvider()).qrUrl;
      return {
        connector,
        ...ios ? {} : {
          qrCode: {
            getUri,
            instructions: {
              learnMoreUrl: "https://www.coinbase.com/learn/tips-and-tutorials/how-to-set-up-a-crypto-wallet",
              steps: [{
                description: "We recommend putting Coinbase Wallet on your home screen for quicker access.",
                step: "install",
                title: "Open the Coinbase Wallet app"
              }, {
                description: "You can easily backup your wallet using the cloud backup feature.",
                step: "create",
                title: "Create or Import a Wallet"
              }, {
                description: "After you scan, a connection prompt will appear for you to connect your wallet.",
                step: "scan",
                title: "Tap the scan button"
              }]
            }
          },
          extension: {
            instructions: {
              steps: [{
                description: "We recommend pinning Coinbase Wallet to your taskbar for quicker access to your wallet.",
                step: "install",
                title: "Install the Coinbase Wallet extension"
              }, {
                description: "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
                step: "create",
                title: "Create or Import a Wallet"
              }, {
                description: "Once you set up your wallet, click below to refresh the browser and load up the extension.",
                step: "refresh",
                title: "Refresh your browser"
              }]
            }
          }
        }
      };
    }
  };
};
var injectedWallet = ({
  chains,
  shimDisconnect
}) => ({
  id: "injected",
  name: "Injected Wallet",
  iconUrl: async () => (await Promise.resolve($$2)).default,
  iconBackground: "#fff",
  hidden: ({
    wallets: wallets2
  }) => wallets2.some((wallet) => wallet.installed && (wallet.connector instanceof InjectedConnector || wallet.id === "coinbase")),
  createConnector: () => ({
    connector: new InjectedConnector({
      chains,
      options: {
        shimDisconnect
      }
    })
  })
});
var sharedConnectors = /* @__PURE__ */ new Map();
function createConnector(options) {
  const connector = new WalletConnectLegacyConnector(options);
  sharedConnectors.set(JSON.stringify(options), connector);
  return connector;
}
function getWalletConnectConnector({
  chains,
  qrcode: qrcode2 = false
}) {
  const options = {
    chains,
    options: {
      qrcode: qrcode2
    }
  };
  const serializedOptions = JSON.stringify(options);
  const sharedConnector = sharedConnectors.get(serializedOptions);
  return sharedConnector != null ? sharedConnector : createConnector(options);
}
function isMetaMask(ethereum) {
  const isMetaMask2 = Boolean(ethereum.isMetaMask);
  if (!isMetaMask2) {
    return false;
  }
  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) {
    return false;
  }
  if (ethereum.isTokenPocket) {
    return false;
  }
  if (ethereum.isTokenary) {
    return false;
  }
  return true;
}
var metaMaskWallet = ({
  chains,
  shimDisconnect
}) => {
  const isMetaMaskInjected = typeof window !== "undefined" && typeof window.ethereum !== "undefined" && isMetaMask(window.ethereum);
  const shouldUseWalletConnect = !isMetaMaskInjected;
  return {
    id: "metaMask",
    name: "MetaMask",
    iconUrl: async () => (await Promise.resolve($$3)).default,
    iconAccent: "#f6851a",
    iconBackground: "#fff",
    installed: !shouldUseWalletConnect ? isMetaMaskInjected : void 0,
    downloadUrls: {
      browserExtension: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en",
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/us/app/metamask/id1438144202",
      qrCode: "https://metamask.io/download/"
    },
    createConnector: () => {
      const connector = shouldUseWalletConnect ? getWalletConnectConnector({
        chains
      }) : new MetaMaskConnector({
        chains,
        options: {
          shimDisconnect
        }
      });
      const getUri = async () => {
        const {
          uri
        } = (await connector.getProvider()).connector;
        return isAndroid$1() ? uri : `https://metamask.app.link/wc?uri=${encodeURIComponent(uri)}`;
      };
      return {
        connector,
        mobile: {
          getUri: shouldUseWalletConnect ? getUri : void 0
        },
        qrCode: shouldUseWalletConnect ? {
          getUri,
          instructions: {
            learnMoreUrl: "https://metamask.io/faqs/",
            steps: [{
              description: "We recommend putting MetaMask on your home screen for quicker access.",
              step: "install",
              title: "Open the MetaMask app"
            }, {
              description: "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
              step: "create",
              title: "Create or Import a Wallet"
            }, {
              description: "After you scan, a connection prompt will appear for you to connect your wallet.",
              step: "scan",
              title: "Tap the scan button"
            }]
          }
        } : void 0,
        extension: {
          learnMoreUrl: "https://metamask.io/faqs/",
          instructions: {
            steps: [{
              description: "We recommend pinning MetaMask to your taskbar for quicker access to your wallet.",
              step: "install",
              title: "Install the MetaMask extension"
            }, {
              description: "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.",
              step: "create",
              title: "Create or Import a Wallet"
            }, {
              description: "Once you set up your wallet, click below to refresh the browser and load up the extension.",
              step: "refresh",
              title: "Refresh your browser"
            }]
          }
        }
      };
    }
  };
};
function isRainbow(ethereum) {
  const isRainbow2 = Boolean(ethereum.isRainbow);
  if (!isRainbow2) {
    return false;
  }
  return true;
}
var rainbowWallet = ({
  chains,
  shimDisconnect
}) => {
  const isRainbowInjected = typeof window !== "undefined" && typeof window.ethereum !== "undefined" && isRainbow(window.ethereum);
  const shouldUseWalletConnect = !isRainbowInjected;
  return {
    id: "rainbow",
    name: "Rainbow",
    iconUrl: async () => (await Promise.resolve($$4)).default,
    iconBackground: "#0c2f78",
    downloadUrls: {
      android: "https://play.google.com/store/apps/details?id=me.rainbow",
      ios: "https://apps.apple.com/us/app/rainbow-ethereum-wallet/id1457119021",
      qrCode: "https://rainbow.download"
    },
    createConnector: () => {
      const connector = shouldUseWalletConnect ? getWalletConnectConnector({
        chains
      }) : new InjectedConnector({
        chains,
        options: {
          shimDisconnect
        }
      });
      const getUri = async () => {
        const {
          uri
        } = (await connector.getProvider()).connector;
        return isAndroid$1() ? uri : `https://rnbwapp.com/wc?uri=${encodeURIComponent(uri)}`;
      };
      return {
        connector,
        mobile: {
          getUri: shouldUseWalletConnect ? getUri : void 0
        },
        qrCode: shouldUseWalletConnect ? {
          getUri,
          instructions: {
            learnMoreUrl: "https://learn.rainbow.me/connect-your-wallet-to-a-website-or-app",
            steps: [{
              description: "We recommend putting Rainbow on your home screen for faster access to your wallet.",
              step: "install",
              title: "Open the Rainbow app"
            }, {
              description: "You can easily backup your wallet using our backup feature on your phone.",
              step: "create",
              title: "Create or Import a Wallet"
            }, {
              description: "After you scan, a connection prompt will appear for you to connect your wallet.",
              step: "scan",
              title: "Tap the scan button"
            }]
          }
        } : void 0
      };
    }
  };
};
var walletConnectWallet = ({
  chains
}) => ({
  id: "walletConnect",
  name: "WalletConnect",
  iconUrl: async () => (await Promise.resolve($$5)).default,
  iconBackground: "#3b99fc",
  createConnector: () => {
    const ios = isIOS$1();
    const connector = getWalletConnectConnector({
      chains,
      qrcode: ios
    });
    const getUri = async () => (await connector.getProvider()).connector.uri;
    return {
      connector,
      ...ios ? {} : {
        mobile: {
          getUri
        },
        qrCode: {
          getUri
        }
      }
    };
  }
});
var getDefaultWallets = ({
  appName,
  chains
}) => {
  const wallets2 = [{
    groupName: "Popular",
    wallets: [injectedWallet({
      chains
    }), rainbowWallet({
      chains
    }), coinbaseWallet({
      appName,
      chains
    }), metaMaskWallet({
      chains
    }), walletConnectWallet({
      chains
    }), braveWallet({
      chains
    })]
  }];
  return {
    connectors: connectorsForWallets(wallets2),
    wallets: wallets2
  };
};
function useAddRecentTransaction() {
  const store = useTransactionStore();
  const {
    address
  } = wagmi.useAccount();
  const chainId = useChainId();
  return React48.useCallback((transaction) => {
    if (!address || !chainId) {
      throw new Error("No address or chain ID found");
    }
    store.addTransaction(address, chainId, transaction);
  }, [store, address, chainId]);
}
var __private__ = {
  DesktopOptions,
  dialogContent,
  dialogContentMobile,
  MobileOptions
};
const rainbowkit = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConnectButton: ConnectButton$1,
  RainbowKitAuthenticationProvider,
  RainbowKitProvider,
  __private__,
  connectorsForWallets,
  createAuthenticationAdapter,
  cssObjectFromTheme,
  cssStringFromTheme,
  darkTheme,
  getDefaultWallets,
  getWalletConnectConnector,
  lightTheme,
  midnightTheme,
  useAccountModal,
  useAddRecentTransaction,
  useChainModal,
  useConnectModal
}, Symbol.toStringTag, { value: "Module" }));
module.exports = rainbowkit;
